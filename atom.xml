<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Obito Blog</title>
  
  
  <link href="http://www.obito.top/atom.xml" rel="self"/>
  
  <link href="http://www.obito.top/"/>
  <updated>2024-12-21T14:42:27.067Z</updated>
  <id>http://www.obito.top/</id>
  
  <author>
    <name>Obito</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重装系统后重新配置hexo环境</title>
    <link href="http://www.obito.top/2024/12/21/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AEhexo%E7%8E%AF%E5%A2%83/"/>
    <id>http://www.obito.top/2024/12/21/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AEhexo%E7%8E%AF%E5%A2%83/</id>
    <published>2024-12-21T13:59:07.000Z</published>
    <updated>2024-12-21T14:42:27.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重装系统后重新配置hexo环境">重装系统后重新配置hexo环境</h1><h2 id="序言">序言</h2><p>电脑重装系统后 hexo 环境没了，但还留着 hexo 的本地目录，就不用重头来过了，只需要配置一下基础环境就可以继续玩耍了。</p><h2 id="过程">过程</h2><h3 id="1-安装-node-js-和-hexo">1. 安装 Node.js 和 hexo</h3><blockquote><p><a href="https://nodejs.org/zh-cn">Node.js — 在任何地方运行 JavaScript (nodejs.org)</a></p></blockquote><p>查看版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v </span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>安装 hexo 环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><h3 id="2-git-安装与配置">2. git 安装与配置</h3><p>安装 git bash：</p><blockquote><p><a href="https://git-scm.com/downloads/win">Git - Downloading Package (git-scm.com)</a></p></blockquote><p>git config：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;GitHub账户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>配置 SSH KEY，在 <code>C:\Users\用户名\.ssh</code> 目录下打开 git bash：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>使用 cat 命令输出 <code>id_rsa.pub</code> 文件内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> id_rsa.pub</span><br></pre></td></tr></table></figure><p>进入 GitHub 主页新建 SSH KEY，Key 粘贴 cat 输出内容。</p><p>测试是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h3 id="3-配置远程仓库">3. 配置远程仓库</h3><p>防止误删请提前备份！删除本地文件中的 <code>.deploy_git</code>、<code>.git</code>、<code>public</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf .deploy_git</span><br><span class="line"><span class="built_in">rm</span> -rf .git</span><br><span class="line"><span class="built_in">rm</span> -rf public</span><br></pre></td></tr></table></figure><p>建立本地仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add 别名 仓库git</span><br></pre></td></tr></table></figure><p>由于是初次建立仓库，默认分支名是 master，如果需要改变分支名，需要先随便提交一下初始化仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .或者随便文件</span><br><span class="line">git commit -m <span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure><p>最后就可以成功部署了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo c &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;重装系统后重新配置hexo环境&quot;&gt;重装系统后重新配置hexo环境&lt;/h1&gt;
&lt;h2 id=&quot;序言&quot;&gt;序言&lt;/h2&gt;
&lt;p&gt;电脑重装系统后 hexo 环境没了，但还留着 hexo 的本地目录，就不用重头来过了，只需要配置一下基础环境就可以继续玩耍了。&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Qt-Android环境搭建</title>
    <link href="http://www.obito.top/2024/12/21/Qt-Android%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.obito.top/2024/12/21/Qt-Android%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2024-12-21T13:44:27.000Z</published>
    <updated>2024-12-21T13:44:59.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="qt-安卓环境搭建">Qt 安卓环境搭建</h1><h2 id="序言">序言</h2><p>Qt 开发 Android 需要 jdk、ndk、sdk 三个包，并且 Qt 的版本要与这些包的版本对应，否则会出现一堆奇怪的 bug，我的环境如下：</p><ul><li>qt 版本：5.14.2</li><li>JDK：1.8.0_172</li><li>NDK：r20b</li><li>SDK：24.4.1</li></ul><p>安装时注意安装目录不能有中文，这一点不用多说，网上有些说不能带空格，但我是直接使用默认安装目录的，而默认目录是有空格的，所以这个应该不是大问题，最终我使用默认目录也可以成功。</p><p>Qt 和 Android 版本依赖关系：</p><blockquote><p><a href="https://doc.qt.io/qt-5/android-getting-started.html">Getting Started with Qt for Android | Qt 5.15</a></p></blockquote><p><img src="image-20241221181401964.png" alt="image-20241221181401964"></p><h2 id="搭建过程">搭建过程</h2><blockquote><p><a href="https://blog.51cto.com/u_15950551/6032388">Qt | Qt For Android、Qt5.14.2安卓开发环境搭建详细步骤_觉皇不秃头的技术博客_51CTO博客</a></p></blockquote><h3 id="1-安装-qt">1. 安装 qt</h3><p>我选择的版本为：5.14.2，勾上 Android 组件，其他按需选择即可，</p><p>下载地址（这个可能需要开梯子，镜像源中没找到这个版本，所以我直接开梯子下载了）：</p><blockquote><p><a href="https://download.qt.io/archive/qt/5.14/5.14.2/">Index of /archive/qt/5.14/5.14.2</a></p></blockquote><h3 id="2-安装-java-jdk">2. 安装 JAVA JDK</h3><p>我选择的版本为：JDK：1.8.0_172，这里我直接使用 exe 程序安装的，安装过程会自动配置环境变量，就不用再手动配置环境变量了。</p><p>安装完使用命令查看版本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;java <span class="literal">-version</span></span><br><span class="line">java version <span class="string">&quot;1.8.0_172&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build <span class="number">1.8</span>.<span class="number">0</span>_172<span class="literal">-b11</span>)</span><br><span class="line">Java HotSpot(TM) <span class="number">64</span><span class="literal">-Bit</span> Server VM (build <span class="number">25.172</span><span class="literal">-b11</span>, mixed mode)</span><br></pre></td></tr></table></figure><p>JDK 下载镜像网站：</p><blockquote><p><a href="https://repo.huaweicloud.com/java/jdk/">Index of java-local/jdk (huaweicloud.com)</a></p></blockquote><h3 id="3-ndk">3. NDK</h3><p>我选择的版本为：r20b，下载完解压到没有中文的英文目录即可（最好也别带空格，没试过）。</p><p>下载 Android NDK：</p><blockquote><p><a href="https://github.com/android/ndk/wiki/Unsupported-Downloads">Unsupported Downloads · android/ndk Wiki · GitHub</a></p></blockquote><h3 id="4-安装-android-studio">4. 安装 Android Studio</h3><p>安装 Android Studio 软件，这个软件是专门用来开发 Android 的，这里主要借用其来安装 Android SDK。为什么要借用这个软件呢：原因是我直接使用 SDK Manager 工具来安装组件时，一直出现网络问题获取不到库（放在 Google 上的），使用梯子和镜像源都不能解决，所以最终选择这种方法。</p><p>下载地址：</p><blockquote><p><a href="https://developer.android.google.cn/studio?hl=zh-cn#downloads">下载 Android Studio 和应用工具 - Android 开发者  | Android Developers (google.cn)</a></p></blockquote><p>安装教程：</p><blockquote><p><a href="https://blog.csdn.net/Y74364/article/details/96121530">android studio安装教程(持续更新中，包安装成功，不成功你找我)-CSDN博客</a></p></blockquote><h3 id="5-qt-配置-android-环境">5. Qt 配置 Android 环境</h3><p>前面都安装完后，进入到 Qt Creator 进行配置 Android 环境：</p><p><img src="image-20241221175614105.png" alt="image-20241221175614105"></p><p>这是最后成功的情况，我使用 Android Studio 软件下载安装后组件时，Qt 这里还是出现 SDK tools installed 和 Platform SDK installed 这两个选项打×的情况，查找资料发现是 SDK 目录下缺少 tools 目录（Android Studio 软件可能不需要用到这个 tools 目录或者是放在其他目录，我们只是借其下载安装组件，所以手动下载 tools 即可）。</p><blockquote><p><a href="https://blog.csdn.net/qq_43265832/article/details/124518165">Qt6.3.0安卓配置提示缺少Platform SDK installed-CSDN博客</a></p></blockquote><p>于是就去手动下载 SDK Tools，并接压缩包内的 Tools 目录复制到原来的 SDK 目录下，即可解决。</p><blockquote><p><a href="https://www.androiddevtools.cn/">AndroidDevTools - Android开发工具 Android SDK下载 Android Studio下载 Gradle下载 SDK Tools下载</a></p></blockquote><p>Qt 配置 Android 环境的选项：</p><blockquote><p><a href="https://blog.csdn.net/qq_56857879/article/details/139290052">Qt5.14.2 for Android 环境配置及开发_qt 5.14 android-CSDN博客</a></p></blockquote><h2 id="出现的问题">出现的问题</h2><p>下载 gradle 时出现网络问题，可以手动下载放到对应目录或者修改镜像源：</p><p>Gradle 下载：</p><blockquote><p><a href="https://services.gradle.org/distributions/">https://services.gradle.org/distributions/</a></p></blockquote><p>jdk 版本不对应出现错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoClassDefFoundError: Could not initialize class org.codehaus.groovy.vmplugin.v7.Java7</span><br><span class="line">at org.codehaus.groovy.vmplugin.VMPluginFactory.&lt;clinit&gt;(VMPluginFactory.java:43)</span><br><span class="line">at org.codehaus.groovy.reflection.GroovyClassValueFactory.&lt;clinit&gt;(GroovyClassValueFactory.java:35)</span><br><span class="line">at org.codehaus.groovy.reflection.ClassInfo.&lt;clinit&gt;(ClassInfo.java:109)</span><br><span class="line">at org.codehaus.groovy.reflection.ReflectionCache.getCachedClass(ReflectionCache.java:95)</span><br><span class="line">at org.codehaus.groovy.reflection.ReflectionCache.&lt;clinit&gt;(ReflectionCache.java:39)</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">at java.base/jdk.internal.reflect.MethodHandleAccessorFactory.ensureClassInitialized(Unknown Source)</span><br><span class="line">at java.base/jdk.internal.reflect.MethodHandleAccessorFactory.newConstructorAccessor(Unknown Source)</span><br><span class="line">at java.base/jdk.internal.reflect.ReflectionFactory.newConstructorAccessor(Unknown Source)</span><br><span class="line">at java.base/java.lang.reflect.Constructor.acquireConstructorAccessor(Unknown Source)</span><br><span class="line">at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Unknown Source)</span><br><span class="line">at java.base/java.lang.reflect.ReflectAccess.newInstance(Unknown Source)</span><br><span class="line">at java.base/jdk.internal.reflect.ReflectionFactory.newInstance(Unknown Source)</span><br><span class="line">at java.base/java.lang.Class.newInstance(Unknown Source)</span><br><span class="line">at org.codehaus.groovy.vmplugin.VMPluginFactory.createPlugin(VMPluginFactory.java:57)</span><br><span class="line">at org.codehaus.groovy.vmplugin.VMPluginFactory.&lt;clinit&gt;(VMPluginFactory.java:39)</span><br><span class="line">... 119 more</span><br><span class="line"></span><br><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">Could not initialize class org.codehaus.groovy.reflection.ReflectionCache</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Exception java.lang.NoClassDefFoundError: Could not initialize class org.codehaus.groovy.vmplugin.v7.Java7 [<span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span>]</span></span><br><span class="line"></span><br><span class="line">* Try:</span><br><span class="line">Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.</span><br><span class="line"></span><br><span class="line">* Get more help at https://help.gradle.org</span><br><span class="line"></span><br><span class="line">BUILD FAILED in 1s</span><br><span class="line">  -- Skipping C:/Qt/Qt5.14.2/5.14.2/android/plugins/iconengines/libplugins_iconengines_qsvgicon_armeabi-v7a.so. It has unmet dependencies: lib/libQt5Svg_armeabi-v7a.so.</span><br><span class="line">  -- Skipping C:/Qt/Qt5.14.2/5.14.2/android/plugins/imageformats/libplugins_imageformats_qsvg_armeabi-v7a.so. It has unmet dependencies: lib/libQt5Svg_armeabi-v7a.so.</span><br><span class="line">Skipping createRCC</span><br><span class="line">Building the android package failed!</span><br><span class="line">  -- For more information, run this command with --verbose.</span><br><span class="line">15:06:47: 进程&quot;C:\Qt\Qt5.14.2\5.14.2\android\bin\androiddeployqt.exe&quot;退出，退出代码 14 。</span><br><span class="line">Error while building/deploying project untitled (kit: Android for armeabi-v7a,arm64-v8a,x86,x86_64 (Clang Qt 5.14.2 for Android))</span><br><span class="line">When executing step &quot;Build Android APK&quot;</span><br></pre></td></tr></table></figure><p>Android SDK 版本太高了，但项目依赖的工具或库不兼容。sdk tools 版本使用的是 24.4.1，但是这里用了 android-35，版本不对应出错，后面改成 android-29 可解决。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &#x27;:processDebugResources&#x27;.</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">A failure occurred <span class="keyword">while</span> executing com.android.build.gradle.internal.tasks.Workers<span class="variable">$ActionFacade</span></span></span><br><span class="line"><span class="meta prompt_">   &gt; </span><span class="language-bash">Android resource linking failed</span></span><br><span class="line">     AAPT: aapt2.exe E 12-21 15:11:16 17732 10564 LoadedArsc.cpp:112] RES_TABLE_TYPE_TYPE entry offsets overlap actual entry data.</span><br><span class="line">     aapt2.exe E 12-21 15:11:16 17732 10564 ApkAssets.cpp:157] Failed to load &#x27;resources.arsc&#x27; in APK &#x27;C:\Users\Administrator\AppData\Local\Android\Sdk\platforms\android-35\android.jar&#x27;.</span><br><span class="line">     error: failed to load include path C:\Users\Administrator\AppData\Local\Android\Sdk\platforms\android-35\android.jar.</span><br><span class="line">     </span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">* Try:</span><br><span class="line">Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.</span><br><span class="line"></span><br><span class="line">* Get more help at https://help.gradle.org</span><br><span class="line"></span><br><span class="line">BUILD FAILED in 24s</span><br><span class="line">19 actionable tasks: 19 executed</span><br><span class="line">Building the android package failed!</span><br><span class="line">  -- For more information, run this command with --verbose.</span><br><span class="line">15:11:17: 进程&quot;C:\Qt\Qt5.14.2\5.14.2\android\bin\androiddeployqt.exe&quot;退出，退出代码 14 。</span><br><span class="line">Error while building/deploying project untitled1 (kit: Android for armeabi-v7a,arm64-v8a,x86,x86_64 (Clang Qt 5.14.2 for Android))</span><br><span class="line">When executing step &quot;Build Android APK&quot;</span><br></pre></td></tr></table></figure><p>编译时出现架构不对，需要选择 ABIs 支持的架构，可单选或多选。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb: failed to install Failure [INSTALL_FAILED_NO_MATCHING_ABIS: INSTALL_FAILED_NO_MATCHING_ABIS: Failed to extract native libraries, res=-113] Installing to device failed! 13:19:31: The process &quot;C:\Qt\Qt5.14.2\5.14.2\android\bin\androiddeployqt.exe&quot; exited with code 16.</span><br></pre></td></tr></table></figure><p><img src="image-20241221184344322.png" alt="image-20241221184344322"></p><p>构建时还会出现目录名太长的情况，在 Qt 内手动修改减少目录名字即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;qt-安卓环境搭建&quot;&gt;Qt 安卓环境搭建&lt;/h1&gt;
&lt;h2 id=&quot;序言&quot;&gt;序言&lt;/h2&gt;
&lt;p&gt;Qt 开发 Android 需要 jdk、ndk、sdk 三个包，并且 Qt 的版本要与这些包的版本对应，否则会出现一堆奇怪的 bug，我的环境如下：&lt;/p&gt;
&lt;ul</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建TeamSpeak服务器</title>
    <link href="http://www.obito.top/2024/09/25/%E6%90%AD%E5%BB%BATeamSpeak%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://www.obito.top/2024/09/25/%E6%90%AD%E5%BB%BATeamSpeak%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2024-09-25T08:18:47.000Z</published>
    <updated>2024-10-26T13:21:21.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建teamspeak服务器">搭建TeamSpeak服务器</h1><p>需要一台长时间开机以及拥有公网 IP 的电脑，因为没有公网 IP，所以这里就购买了云服务器进行搭建，经过价格对比最终选择了[腾讯云](<a href="https://cloud.tencent.com/">腾讯云 产业智变·云启未来 - 腾讯 (tencent.com)</a>)服务器，初次购买优惠一年 79 元，2 核 2 G、系统盘 50 G、流量包 300 GB/月、带宽 4 Mbps。</p><h2 id="linux-环境安装服务器">Linux 环境安装服务器</h2><h3 id="准备工作">准备工作</h3><p>考虑到安全性，这里新建一个用户存放服务器文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd teamspeak</span><br></pre></td></tr></table></figure><p>下载和解压压缩包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://files.teamspeak-services.com/releases/server/3.13.7/teamspeak3-server_linux_amd64-3.13.7.tar.bz2</span><br><span class="line"></span><br><span class="line">tar -xvf teamspeak3-server_linux_amd64-3.13.7.tar.bz2</span><br></pre></td></tr></table></figure><p>修改下目录名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv teamspeak3-server_linux_amd64-3.13.7 teamspeak3</span><br></pre></td></tr></table></figure><p>赋予目录给新建的用户权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R teamspeak:teamspeak teamspeak3</span><br><span class="line">cd teamspeak3</span><br></pre></td></tr></table></figure><p>同意许可条款</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch .ts3server_license_accepted</span><br></pre></td></tr></table></figure><p>数据库配置，TeamSpeak 默认使用 SQLite，执行以下操作<strong>自动配置并启动服务器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ts3server_startscript.sh start</span><br></pre></td></tr></table></figure><p>打印信息，<strong>保存 token 和 管理员账号和密码。</strong></p><p><img src="image-20240925163621472.png" alt="image-20240925163621472"></p><h3 id="设置自启动">设置自启动</h3><p>创建并编辑文件：<code>/lib/systemd/system/teamspeak.service</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /lib/systemd/system/teamspeak.service</span><br></pre></td></tr></table></figure><p>添加内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Teamspeak, The most superior online voice communication solution.</span><br><span class="line">Wants=network-online.target</span><br><span class="line">After=syslog.target network.target network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=teamspeak</span><br><span class="line">Group=teamspeak</span><br><span class="line">WorkingDirectory=/home/teamspeak/teamspeak3</span><br><span class="line">ExecStart=/home/teamspeak/teamspeak3/ts3server_startscript.sh start</span><br><span class="line">ExecStop=/home/teamspeak/teamspeak3/ts3server_startscript.sh stop</span><br><span class="line">PIDFile=/home/teamspeak/teamspeak3/ts3server.pid</span><br><span class="line">Type=forking</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>User和 Group 为前面设置的用户及用户所在组。</li><li>WorkingDirectory：工作目录</li><li>ExecStart：启动命令</li><li>ExecStop：接收命令</li><li><strong>目录路径必须修改为直接服务器文件存放位置</strong></li></ul><p>重新加载 systemd：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>开启自启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable teamspeak.service</span><br></pre></td></tr></table></figure><p>启动 TeamSpeak：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start teamspeak.service</span><br></pre></td></tr></table></figure><p>停止 TeamSpeak：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop teamspeak.service</span><br></pre></td></tr></table></figure><p>重启TeamSpeak：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart teamspeak.service</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.wevg.org/archives/teamspeak-server-build/#%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5">TeamSpeak 服务器搭建方法 | Vigorous Pro (wevg.org)</a></p></blockquote><h3 id="移植服务器">移植服务器</h3><p>移植前先保存必要文件，然后在新的服务器重新安装 ts 服务器将文件放到目录下并重新添加 license 许可证就可以正常使用了。</p><h4 id="重要文件">重要文件</h4><p>查询接口的白名单 IP：<code>query_ip_allowlist.txt</code></p><p>查询接口的黑名单 IP：<code>query_ip_denylist.txt</code></p><p>数据库：<code>ts3server.sqlitedb </code></p><p>密钥：<code>ssh_host_rsa_key</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv query_ip_* ts3server.sqlitedb ssh_host_rsa_key 服务器目录下</span><br></pre></td></tr></table></figure><p>如果要频道有图标或文件，则需要保存 <code>file</code> 目录。</p><p>若有配置 tsdns，则还需要保存 <code>tsdns/tsdns_settings.ini</code>。</p><blockquote><p><a href="https://www.bilibili.com/read/cv36119499/?jump_opus=1">【星荧璃果】Teamspeak服务器搭建、绑定域名、迁移 - 哔哩哔哩 (bilibili.com)</a></p></blockquote><h2 id="tsaudioboot">TSAudioboot</h2><p>直接使用 linux 搭建后，wyy api 用不了，改成 docker 目前可以正常使用。</p><p>初始化生成配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --rm --mount type=bind,source=&quot;$(pwd)/data&quot;,target=/app/data -it ancieque/ts3audiobot:0.12.0</span><br></pre></td></tr></table></figure><p>运行启动，必须<strong>添加映射端口 58913</strong>，否则网页打不开。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --name ts3audiobot -d -p 58913:58913 --mount type=bind,source=&quot;$(pwd)/data&quot;,target=/app/data ancieque/ts3audiobot:0.12.0</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/getdrunkonmovies-com/TS3AudioBot_docker?tab=readme-ov-file">getdrunkonmovies-com/TS3AudioBot_docker (github.com)</a></p></blockquote><h3 id="tsaudioboot-四个重要配置文件">TSAudioboot 四个重要配置文件</h3><ul><li>ts3audiobot.db：bot 的数据库。</li><li>ts3audiobot.toml：配置文件，里面有 web 的网页配置信息。</li><li>rights.toml：用户权限参数设置，在 userid 添加自己的 uid。</li><li>bot/default/bot.toml：存放 bot 连接的服务器和频道信息。</li></ul><p>bot/default/bot.toml 需要自己创建，添加一下内容（权限需要改为 docker 用户）：添加服务器地址和密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Starts the instance when the TS3AudioBot is launched.</span></span><br><span class="line">run = true</span><br><span class="line"></span><br><span class="line">[commands]</span><br><span class="line"></span><br><span class="line">[commands.alias]</span><br><span class="line"></span><br><span class="line">[connect]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">The server password. Leave empty <span class="keyword">for</span> none.</span></span><br><span class="line">server_password = &#123; pw = &quot;服务器密码&quot; &#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">The default channel password. Leave empty <span class="keyword">for</span> none.</span></span><br><span class="line">channel_password = &#123;  &#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Overrides the displayed version <span class="keyword">for</span> the ts3 client. Leave empty <span class="keyword">for</span> default.</span></span><br><span class="line">client_version = &#123;  &#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">The address, ip or nickname (and port; default: 9987) of the TeamSpeak3 server</span></span><br><span class="line">address = &quot;ip:port&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Client nickname when connecting.</span></span><br><span class="line">name = &quot;Music Bot&quot;</span><br><span class="line"></span><br><span class="line">[connect.identity]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">||| DO NOT MAKE THIS KEY PUBLIC ||| The client identity. You can import a teamspeak3 identity here too.</span></span><br><span class="line">key = &quot;MCoDAgbAAgEgAiEAijUpF210Wd4+9/07+43GcLC02o09gEqxkNvBC3fq38U=&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">The client identity offset determining the security level.</span></span><br><span class="line">offset = 249</span><br><span class="line"></span><br><span class="line">[reconnect]</span><br><span class="line"></span><br><span class="line">[audio]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">When a new song starts the volume will be trimmed to between min and max.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">When the current volume already is between min and max nothing will happen.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">To completely or partially <span class="built_in">disable</span> this feature, <span class="built_in">set</span> min to 0 and/or max to 100.</span></span><br><span class="line">volume = &#123;  &#125;</span><br><span class="line"></span><br><span class="line">[playlists]</span><br><span class="line"></span><br><span class="line">[history]</span><br><span class="line"></span><br><span class="line">[events]</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.bilibili.com/read/cv12676008/">TS3AudioBot安装配置教程 - 哔哩哔哩 (bilibili.com)</a></p></blockquote><p>可以打开网页手动添加本地音乐，这里使用的是 docker，所以<strong>添加时需要是 docker 的目录</strong>。</p><p>例如我宿主机本地目录为 <code>/home/teamspeak/ts3AudioBot/data</code>，挂载 docker 容器的目录为 <code>/app/data</code>，所以将在本地目录创建 music 目录后，在 docker 容器下的目录应该为 <code>/app/data/music</code>，eg：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">宿主机目录：/home/teamspeak/ts3AudioBot/data/music/test.mp3</span><br><span class="line">docker容器目录：/app/data/music/test.mp3</span><br></pre></td></tr></table></figure><p>使用脚本批量添加音乐（还未尝试）：</p><blockquote><p><a href="https://www.bilibili.com/video/BV19M4m1f7HV/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=170970c6528ce8b04fb449814b901de5">https://www.bilibili.com/video/BV19M4m1f7HV/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=170970c6528ce8b04fb449814b901de5</a></p></blockquote><h3 id="wyy-api">WYY API</h3><p>列出当前 plugin 和加载 plugin。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!plugin list</span><br><span class="line"></span><br><span class="line">!plugin load 0</span><br></pre></td></tr></table></figure><p>命令使用方法：</p><blockquote><p><a href="https://blog.csdn.net/weixin_46419890/article/details/139286994">关于TeamSpeak3-网易音乐机器人的基础使用方法（胎教级教程）_ts3audiobot-CSDN博客</a></p></blockquote><p>接口解析：</p><blockquote><p><a href="https://binaryify.github.io/NeteaseCloudMusicApi/#/?id=%E8%BF%90%E8%A1%8C">网易云音乐 NodeJS 版 API (binaryify.github.io)</a></p></blockquote><p>插件 windows 版本的，里面分支有 linux 版本的，出现问题看一下 tissue。</p><blockquote><p><a href="https://github.com/ZHANGTIANYAO1/TS3AudioBot-NetEaseCloudmusic-plugin?tab=readme-ov-file">ZHANGTIANYAO1/TS3AudioBot-NetEaseCloudmusic-plugin: 这是一个用C#给TS3AudioBot编写网易云插件,让你的TS可以有一个音乐机器人。如果觉得好的话，还请给个星星支持一下 (github.com)</a></p></blockquote><p>linux 版本的：</p><blockquote><p><a href="https://github.com/FiveHair/TS3AudioBot-NetEaseCloudmusic-plugin-UNM">FiveHair/TS3AudioBot-NetEaseCloudmusic-plugin-UNM: 重构ZHANGTIANYAO1的TS3AudioBot网易云插件，支持Windows、Docker和Linux，支持无版权歌曲解锁。 (github.com)</a></p></blockquote><h3 id="linux-命令-docker">linux 命令 &amp; docker</h3><p>在搭建的时候，经常需要查看端口是否开放，使用 netstat 命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// t:tcp u:tdp l:表示仅显示监听的端口 n:数字形式显示端口号</span><br><span class="line">netstat -tuln</span><br><span class="line">// 使用 grep 查找具体</span><br><span class="line">netstat -tuln | grep :80</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/oldboyedu1/article/details/142386143">Linux如何查看端口是否开放?-CSDN博客</a></p><p>docker run 创建并启动容器</p><p>当使用 docker run 命令时，除了常见参数 -d（后台运行）和 -p（端口映射）之外，还有一些其他常用参数：</p><ul><li>-v：挂载主机目录到容器内部，用于数据持久化。</li><li>-e：设置容器内的环境变量。</li><li>–name：为容器指定一个自定义的名称。</li><li>-i：启动一个交互式容器。</li><li>-t：为容器分配一个伪终端。</li><li>–restart：指定容器退出时的重启策略。</li><li>–network：指定容器所属的网络模式。</li><li>–link：链接另一个容器。</li></ul><p>docker start 启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器名</span><br></pre></td></tr></table></figure><p>docker stop 停止容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器名</span><br></pre></td></tr></table></figure><p>docker restart 重启容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 容器名</span><br></pre></td></tr></table></figure><p>docker rm 删除容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器名</span><br></pre></td></tr></table></figure><p>docker logs 查看容器日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker logs 容器名</span><br><span class="line"></span><br><span class="line">// 实时显示</span><br><span class="line">docker logs -f 容器名</span><br></pre></td></tr></table></figure><p>docker images 查看已下载的 docker 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>进入 docker 容器的目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器名 /bin/bash</span><br><span class="line">or</span><br><span class="line">docker exec -it 容器名 sh</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/xuzhengzhe/article/details/136248661">【Docker】初学者 Docker 基础操作指南：从拉取镜像到运行、停止、删除容器_docker停止一个镜像的拉取-CSDN博客</a></p></blockquote><h3 id="设置docker以及容器开机自启动">设置docker以及容器开机自启动</h3><h4 id="docker">docker</h4><p>docker 设置开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable docker.service</span><br></pre></td></tr></table></figure><p>docker 关闭开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl disable docker.service</span><br></pre></td></tr></table></figure><p>重新设置 docker 在系统中的自启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl reenable docker.service</span><br></pre></td></tr></table></figure><h4 id="容器">容器</h4><p>创建时设置自启动在 docker run 中添加选项 --restart=always</p><p>如果已经创建的容器，则使用 update 命令进行更新：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker update --restart=always 容器名或者id</span><br></pre></td></tr></table></figure><p>取消容器开机自启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker update --restart=no 容器名或者id</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/qq_45558497/article/details/123970473">ubuntu中设置docker以及容器开机自启_ubuntu docker 开机启动-CSDN博客</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;搭建teamspeak服务器&quot;&gt;搭建TeamSpeak服务器&lt;/h1&gt;
&lt;p&gt;需要一台长时间开机以及拥有公网 IP 的电脑，因为没有公网 IP，所以这里就购买了云服务器进行搭建，经过价格对比最终选择了[腾讯云](&lt;a href=&quot;https://cloud.ten</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux内核锁机制</title>
    <link href="http://www.obito.top/2024/08/24/Linux%E5%86%85%E6%A0%B8%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.obito.top/2024/08/24/Linux%E5%86%85%E6%A0%B8%E9%94%81%E6%9C%BA%E5%88%B6/</id>
    <published>2024-08-24T07:59:39.000Z</published>
    <updated>2024-09-16T07:59:59.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux内核锁机制">Linux内核锁机制</h1><h2 id="linux-并发与竞争">Linux 并发与竞争</h2><p><strong>并发</strong>：Linux 系统是个多任务操作系统，会存在<strong>多个任务同时访问同一片内存空间</strong>，这些任务可能会相互覆盖这段内存中数据，造成内存数据混乱。</p><p><strong>并发访问带来的问题就是竞争</strong>，竞争并发的执行单元对共享资源（硬件资源和软件上的全局变量）的访问而导致的竞争状态。因此我们需要<strong>对共享数据进行保护处理，防止多个任务同时访问它</strong>。</p><p>并发的原因一般有：</p><ul><li>多线程并发访问：Linux 是多任务（线程）的系统，多线程访问是最基本的原因。</li><li>抢占式并发访问：Linux 内核支持抢占，调度程序可以在任意时刻抢占正在运行的线程，从而运行其他的线程。</li><li>中断程序并发访问：硬件中断的优先级很高。</li><li>SMP（多核）核间并发访问：多个 CPU 核存在核间并发访问。</li></ul><p><strong>临界资源</strong>：多个进程访问的资源，共享数据段。</p><p><strong>临界区</strong>：多个进程访问的代码段。</p><h2 id="linux-内核锁机制">Linux 内核锁机制</h2><p>Linux 内核提供解决竞争的手段有如下几个方法：原子操作、自旋锁、信号量、互斥体。</p><h3 id="原子操作">原子操作</h3><p>原子操作是指<strong>不能再进一步分割的操作</strong>，一般原子操作用于<strong>整型变量或者位操作</strong></p><p>例如 C 语言中的整型变量 a 进行赋值操作，C 语言编译转换为汇编指令，但 ARM 架构不支持直接对寄存器进行读写操作，需要借助寄存器来完成赋值操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c语言</span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能转换成如下汇编指令</span></span><br><span class="line">ldr r0, = <span class="number">0x30000000</span></span><br><span class="line">ldr r1, = <span class="number">3</span></span><br><span class="line">str r1, [r0]</span><br></pre></td></tr></table></figure><p>假设现在线程 A 要向 a 变量写入 10 这个值，而线程 B 也要向 a 变量写入 20 这个值，理想执行顺序如下：</p><p><img src="image-20240701134438484.png" alt="image-20240701134438484"></p><p>但实际情况可能如下：</p><p><img src="image-20240701134503941.png" alt="image-20240701134503941"></p><p>为了防止出现该问题，我们需要<strong>保证这三行汇编指令作为一个整体运行</strong>。</p><p>Linux 内核定义了叫做 <code>atomic_t</code> 结构体来<strong>完成整型数据的原子操作</strong>，在使用中<strong>用原子变量代替整型变量</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  include/linux/types.h </span></span><br><span class="line"><span class="comment">// 32位</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> counter;</span><br><span class="line">&#125; <span class="type">atomic_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 64位</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> counter;</span><br><span class="line">&#125; <span class="type">atomic64_t</span>;</span><br></pre></td></tr></table></figure><p>原子操作的 API 函数：</p><p><img src="image-20240701135113024.png" alt="image-20240701135113024"></p><p>原子位操作的 API 函数：原子位操作是直接对内存进行操作</p><p><img src="image-20240701135255467.png" alt="image-20240701135255467"></p><p>eg：使用原子变量 lock，用来实现一次只能一个应用程序访问 LED。</p><ul><li>驱动入口函数将 lock 值设置为 1</li><li>打开驱动设备时用 <code>atomic_dec_and_test</code> 函数将 lock 减 1，<code>atomic_dec_and_test</code> 函数返回值为真就表示 lock 当前值为 0，表示设备可用</li><li>q若返回值为假，表示 lock 减 1 之后为负数，即有其他设备将正在使用 LED 使得 lock 为 0；需要将 lock 加 1，使得 lock 为 0 表示设备正在使用，并返回 -EBUSY</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_t</span> lock;<span class="comment">/* 原子变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 通过判断原子变量的值来检查LED有没有被别的应用使用 */</span></span><br><span class="line"><span class="keyword">if</span> (!atomic_dec_and_test(&amp;lock)) </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">atomic_inc</span>(&amp;lock);<span class="comment">/* 小于0的话就加1,使其原子变量等于0 */</span></span><br><span class="line"><span class="keyword">return</span> -EBUSY;<span class="comment">/* LED被使用，返回忙 */</span></span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 关闭驱动文件的时候释放原子变量 */</span></span><br><span class="line"><span class="type">atomic_inc</span>(&amp;lock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 初始化原子变量 */</span></span><br><span class="line"><span class="type">atomic_set</span>(&amp;lock, <span class="number">1</span>);<span class="comment">/* 原子变量初始值为1 */</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自旋锁">自旋锁</h3><p>原子操作只能对整型变量或者位进行保护，自旋锁可以对更多的资源进行保护。</p><p>如果自旋锁正在被线程 A 持有，而线程 B 想要获取自旋锁，那么线程 B 就会处于<strong>忙循环—旋转—等待状态</strong>，线程 B <strong>不会进入休眠状态或者说去做其他的处理</strong>，直到线程 A 释放自旋锁，线程 B 才可以访问共享资源。</p><ul><li>自旋锁适用于短时期的轻量级加锁，否则会降低系统性能。</li><li>被自旋锁保护的临界区一定不能调用睡眠和阻塞的函数，否则可能会导致死锁现象。</li><li>获取锁之前要禁止本地中断，防止死锁现象。如一个线程获取锁之后被中断打断，而这个中断要想申请该锁，则会发送死锁现象。</li></ul><p>Linux 内核定义了 <code>spinlock_t</code> 结构体表示自旋锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            u8 __padding[LOCK_PADSIZE];</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="type">spinlock_t</span>;</span><br></pre></td></tr></table></figure><p><img src="image-20240701143902523.png" alt="image-20240701143902523"></p><p>eg：使用自旋锁，用来实现一次只能一个应用程序访问 LED。</p><ul><li>dev_stats 表示设备使用状态，0：设备未使用； &gt;0：设备已经被使用</li><li>驱动入口函数<strong>初始化自旋锁</strong></li><li>打开驱动设备时调用 <code>spin_lock_irqsave</code> 函数<strong>获取自旋锁</strong>，保存本地中断状态</li><li>判断 dev_stats 是否大于 0，若设备已被使用，则调用 <code>spin_unlock_irqrestore</code> 函数<strong>解锁</strong>并返回 -EBUSY</li><li>若设备未被使用，dev_stats 加 1，表示设备开始使用了，接着调用 <code>spin_unlock_irqrestore</code> 函数<strong>解锁</strong></li><li>退出驱动设备将 dev_stats 减 1，表示设备释放</li><li>这里的<strong>自旋锁的工作就是保护 dev_stats 变量不被其他程序访问修改</strong>，这里的 dev_stats 是该文件的全局变量，但实际上这个变量可能会被各种文件使用，因此需要用自旋锁可以用来保护其不被访问。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dev_stats;<span class="comment">/* 设备使用状态，0，设备未使用;&gt;0,设备已经被使用 */</span></span><br><span class="line"><span class="type">spinlock_t</span> lock;<span class="comment">/* 自旋锁 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">spin_lock_irqsave(&amp;lock, flags);<span class="comment">/* 上锁 */</span></span><br><span class="line"><span class="keyword">if</span> (dev_stats) </span><br><span class="line">&#123;<span class="comment">/* 如果设备被使用了 */</span></span><br><span class="line">spin_unlock_irqrestore(&amp;lock, flags);<span class="comment">/* 解锁 */</span></span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line">&#125;</span><br><span class="line">dev_stats++;<span class="comment">/* 如果设备没有打开，那么就标记已经打开了 */</span></span><br><span class="line">spin_unlock_irqrestore(&amp;lock, flags);<span class="comment">/* 解锁 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* 关闭驱动文件的时候将dev_stats减1 */</span></span><br><span class="line">spin_lock_irqsave(&amp;lock, flags);<span class="comment">/* 上锁 */</span></span><br><span class="line"><span class="keyword">if</span> (dev_stats) </span><br><span class="line">&#123;</span><br><span class="line">dev_stats--;</span><br><span class="line">&#125;</span><br><span class="line">spin_unlock_irqrestore(&amp;lock, flags);<span class="comment">/* 解锁 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  初始化自旋锁 */</span></span><br><span class="line">spin_lock_init(&amp;lock);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号量">信号量</h3><p>Linux 内核提供了信号量机制，信号量常常用于<strong>控制对共享资源的访问</strong>。它是一个<strong>计数器</strong>，常用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。<strong>相比于自旋锁，信号量可以使线程进入休眠状态</strong></p><ul><li>因为信号量可以使等待资源线程进入<strong>休眠状态</strong>，因此适用于那些占用资源比较久的场合。</li><li>因此信号量<strong>不能用于中断中</strong>，因为信号量会引起休眠，中断不能休眠。</li><li>如果共享资源的持有时间比较短，那就不适合使用信号量了，因为频繁的休眠、切换线程引起的开销要远大于信号量带来的那点优势。</li></ul><blockquote><p>比如 A 与 B、C 合租了一套房子，这个房子只有一个厕所，一次只能一个人使用。某一天早上 A 去上厕所了，过了一会 B 也想用厕所，因为 A 在厕所里面，所以 B 只能等到 A 用来了才能进去。B 要么就一直在厕所门口等着，等 A 出来，这个时候就相当于自旋锁。B 也可以告诉 A，让 A 出来以后通知他一下，然后 B 继续回房间睡觉，这个时候相当于信号量。可以看出，使用信号量会提高处理器的使用效率，毕竟不用一直傻乎乎的在那里“自旋”等待。但是，信号量的开销要比自旋锁大，因为信号量使线程进入休眠状态以后会切换线程，切换线程就会有开销。</p></blockquote><p>Linux 内核使用 <code>semaphore</code> 结构体表示信号量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="type">raw_spinlock_t</span> lock;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="image-20240701145543856.png" alt="image-20240701145543856"></p><p>eg：</p><ul><li>信号量 sem 为1 的时候表示 LED 灯还没有被使用，如果应用程序 A 要使用 LED 灯，先调用 open 函数打开设备节点，这个时候会获取信号量 sem，获取成功以后 sem 的值减 1 变为 0。</li><li>如果此时应用程序 B 也要使用 LED 灯，调用 open 函数打开设备节点就会<strong>因为信号量无效(值为 0)而进入休眠状态。</strong></li><li>当应用程序 A 运行完毕，<strong>调用 close 函数的时候就会释放信号量 sem</strong>，此时信号量 sem 的值就会加 1，变为 1。</li><li>信号量 sem 再次有效，表示其他应用程序可以使用 LED 灯了，此时在休眠状态的应用程序 B 就会获取到信号量 sem，获取成功以后就开始使用 LED 灯。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span><span class="comment">/* 信号量 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* 获取信号量 */</span></span><br><span class="line"><span class="keyword">if</span> (down_interruptible(&amp;sem)) &#123; <span class="comment">/* 获取信号量,进入休眠状态的进程可以被信号打断 */</span></span><br><span class="line"><span class="keyword">return</span> -ERESTARTSYS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">down(&amp;sem);<span class="comment">/* 不能被信号打断 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">up(&amp;sem);<span class="comment">/* 释放信号量，信号量值加1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 初始化信号量 值为1 即二值信号量 */</span></span><br><span class="line">sema_init(&amp;sem, <span class="number">1</span>);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥体">互斥体</h3><p>将信号量的值设置为 1 也可以使用信号量进行互斥，但是 Linux 内核提供了一个更专业的机制来进行互斥——互斥体（mutex）。互斥访问表示<strong>一次只有一个线程</strong>可以访问共享资源，不能递归申请互斥体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 1: unlocked, 0: locked, negative: locked, possible waiters */</span></span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="type">spinlock_t</span> wait_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>mutex 可以导致休眠，不能中断中使用 mutex，<strong>中断中只能使用自旋锁</strong>。</li><li>同信号量一样，mutex 保护的临界区可以调用引起阻塞的 API 函数。</li><li>一次只有一个线程可以持有 mutex，因此 <strong>mutex 的持有者必须自己释放 mutex</strong>，并且 mutex 不能递归上锁和解锁。</li></ul><p><img src="image-20240701150632326.png" alt="image-20240701150632326"></p><p>eg：过程跟使用二值信号量一样，<strong>信号量为二值信号量时就是互斥体</strong>，只不过互斥体是专门用来互斥的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span><span class="comment">/* 互斥体 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* 获取互斥体,可以被信号打断 */</span></span><br><span class="line"><span class="keyword">if</span> (mutex_lock_interruptible(&amp;lock)) &#123;</span><br><span class="line"><span class="keyword">return</span> -ERESTARTSYS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">mutex_lock(&amp;lock);<span class="comment">/* 不能被信号打断 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* 释放互斥锁 */</span></span><br><span class="line">mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 初始化互斥体 */</span></span><br><span class="line">mutex_init(&amp;lock);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux内核锁机制&quot;&gt;Linux内核锁机制&lt;/h1&gt;
&lt;h2 id=&quot;linux-并发与竞争&quot;&gt;Linux 并发与竞争&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;并发&lt;/strong&gt;：Linux 系统是个多任务操作系统，会存在&lt;strong&gt;多个任务同时访问同一片内存空</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/Linux/"/>
    
    
    <category term="Linux 嵌入式" scheme="http://www.obito.top/tags/Linux-%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux-V4L2-USB-Camera</title>
    <link href="http://www.obito.top/2024/08/11/Linux-V4L2-USB-Camera/"/>
    <id>http://www.obito.top/2024/08/11/Linux-V4L2-USB-Camera/</id>
    <published>2024-08-11T14:48:46.000Z</published>
    <updated>2024-08-23T07:38:21.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-v4l2-usb-camera">Linux-V4L2-USB-Camera</h1><h2 id="序言">序言</h2><p>在 Linux 开发板上使用 V4L2 框架驱动 usb 摄像头。</p><h2 id="v4l2-简述">V4L2 简述</h2><p>V4L2（Video for Linux 2）是 Linux 内核中用于视频捕获设备的一个 API（应用程序编程接口），它提供了一套标准的方法来访问和控制视频捕获硬件，如摄像头、视频编码器等。</p><p>市面上有各种型号各种厂商的摄像头，驱动需要一个一个写很麻烦，于是出现了 v4l2 框架。现在大多数摄像头都适配 v4l2 框架，使用 v4l2 框架可以很方便地驱动各种接口的摄像头。</p><p>V4L2 在<code>include/uapi/linux/videodev2.h</code> 文件中定义了一些重要的数据结构，在采集图像的过程中，就是通过对这些数据的操作来获得最终的图像数据。</p><p>V4L2 支持两种方式来采集图像：内存映射方式(mmap)和直接读取方式(read)，前者一般用于连续视频数据的采集，后者常用于静态图片数据的采集，本次是用摄像头进行视频采集所以使用 mmap 的方式。</p><h3 id="应用程序通过-v4l2-接口采集视频数据步骤：">应用程序通过 V4L2 接口采集视频数据步骤：</h3><ol><li>打开视频设备文件(/dev/videoX)，进行视频采集的参数初始化，通过 V4L2 接口设置视频图像的采集窗口、采集的点阵大小和格式;</li><li>申请若干视频采集的帧缓冲区，并将这些帧缓冲区从内核空间映射到用户空间，便于应用程序读取/处理视频数据;</li><li>将申请到的帧缓冲区在视频采集输入队列排队，并启动视频采集;</li><li>驱动开始视频数据的采集，应用程序从视频采集输出队列取出帧缓冲区，处理完后，将帧缓冲区重新放入视频采集输入队列，循环往复采集连续的视频数据;</li><li>停止视频采集。</li></ol><p>具体的程序实现流程可以参考下面的流程图:</p><p><img src="image-20240812142300309.png" alt="image-20240812142300309"></p><p>实现方式基本就是<strong>使用 ioctl 函数去设置和获取参数</strong>。</p><p>最重要的是缓冲区的管理，摄像头启动视频采集后，驱动程序开始<strong>采集一帧数据</strong>，把采集的数据放入<strong>视频采集输入队列</strong>的第一个<strong>帧缓冲区</strong>，一帧数据<strong>采集完成</strong>（第一个帧缓冲区存放一帧数据），<strong>驱动程序</strong>将该<strong>帧缓冲区</strong>移至<strong>视频采集输出队列</strong>，<strong>等待应用程序从输出队列取出</strong>。驱动程序接下来采集下一帧数据，放入第二个帧缓冲区，同样帧缓冲区存满下一帧数据后，就被放入视频采集输出队列。</p><p><strong>应用程序</strong>从<strong>视频采集输出队列中取出</strong>含有视频数据的<strong>帧缓冲区</strong>，处理帧缓冲区中的视频数据，如存储或压缩。</p><p>最后，应用程序将处理完数据的帧缓冲区<strong>重新放入视频采集输入队列</strong>，这样可以循环采集，如图所示。</p><p><img src="image-20240812142848398.png" alt="image-20240812142848398"></p><p><img src="image-20240812143030377.png" alt="image-20240812143030377"></p><h3 id="v4l2-使用">V4L2 使用</h3><p>应用程序使用 V4L2 获取视频数据的过程都是通过 ioctl 命令与驱动程序进行交互，v4l2 常用的 ioctl 控制符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">VIDIOC_QUERYCAP     <span class="comment">/* 获取设备支持的操作 */</span></span><br><span class="line">VIDIOC_G_FMT        <span class="comment">/* 获取设置支持的视频格式 */</span></span><br><span class="line">VIDIOC_S_FMT        <span class="comment">/* 设置捕获视频的格式 */</span></span><br><span class="line">VIDIOC_REQBUFS      <span class="comment">/* 向驱动提出申请内存的请求 */</span></span><br><span class="line">VIDIOC_QUERYBUF     <span class="comment">/* 向驱动查询申请到的内存 */</span></span><br><span class="line">VIDIOC_QBUF         <span class="comment">/* 将空闲的内存加入可捕获视频的队列 */</span></span><br><span class="line">VIDIOC_DQBUF        <span class="comment">/* 将已经捕获好视频的内存拉出已捕获视频的队列 */</span></span><br><span class="line">VIDIOC_STREAMON     <span class="comment">/* 打开视频流 */</span></span><br><span class="line">VIDIOC_STREAMOFF    <span class="comment">/* 关闭视频流 */</span></span><br><span class="line">VIDIOC_QUERYCTRL    <span class="comment">/* 查询驱动是否支持该命令 */</span></span><br><span class="line">VIDIOC_G_CTRL       <span class="comment">/* 获取当前命令值 */</span></span><br><span class="line">VIDIOC_S_CTRL       <span class="comment">/* 设置新的命令值 */</span></span><br><span class="line">VIDIOC_G_TUNER      <span class="comment">/* 获取调谐器信息 */</span></span><br><span class="line">VIDIOC_S_TUNER      <span class="comment">/* 设置调谐器信息 */</span></span><br><span class="line">VIDIOC_G_FREQUENCY  <span class="comment">/* 获取调谐器频率 */</span></span><br><span class="line">VIDIOC_S_FREQUENCY  <span class="comment">/* 设置调谐器频率 */</span></span><br></pre></td></tr></table></figure><h4 id="打开-关闭摄像头">打开/关闭摄像头</h4><p>open 打开摄像头设备节点 <code>/dev/videoX</code></p><p>close 关闭摄像头</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd=open(“/dev/videoX”, O_RDWR);<span class="comment">// 打开设备</span></span><br><span class="line">close(fd);<span class="comment">// 关闭设备</span></span><br></pre></td></tr></table></figure><h4 id="查询设备能力">查询设备能力</h4><p><code>VIDIOC_QUERYCAP</code>：Query Capability，查看是否为捕获设备，是否支持 mmap 操作还是仅支持 read/write 操作。</p><p>v4l2_capability 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * struct v4l2_capability - Describes V4L2 device caps returned by VIDIOC_QUERYCAP</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @driver:   name of the driver module (e.g. &quot;bttv&quot;)</span></span><br><span class="line"><span class="comment">  * @card:   name of the card (e.g. &quot;Hauppauge WinTV&quot;)</span></span><br><span class="line"><span class="comment">  * @bus_info:   name of the bus (e.g. &quot;PCI:&quot; + pci_name(pci_dev) )</span></span><br><span class="line"><span class="comment">  * @version:   KERNEL_VERSION</span></span><br><span class="line"><span class="comment">  * @capabilities: capabilities of the physical device as a whole</span></span><br><span class="line"><span class="comment">  * @device_caps:  capabilities accessed via this particular device (node)</span></span><br><span class="line"><span class="comment">  * @reserved:   reserved fields for future extensions</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_capability</span> &#123;</span></span><br><span class="line">__u8driver[<span class="number">16</span>];</span><br><span class="line">__u8card[<span class="number">32</span>];</span><br><span class="line">__u8bus_info[<span class="number">32</span>];</span><br><span class="line">__u32   version;</span><br><span class="line">__u32capabilities;</span><br><span class="line">__u32device_caps;</span><br><span class="line">__u32reserved[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="查询支持帧格式">查询支持帧格式</h4><p><code>VIDIOC_ENUM_FMT</code> 枚举摄像头支持的格式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *F O R M A T   E N U M E R A T I O N</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_fmtdesc</span> &#123;</span></span><br><span class="line">__u32    index;             <span class="comment">/* Format number      */</span></span><br><span class="line">__u32    type;              <span class="comment">/* enum v4l2_buf_type */</span></span><br><span class="line">__u32               flags;</span><br><span class="line">__u8    description[<span class="number">32</span>];   <span class="comment">/* Description string */</span></span><br><span class="line">__u32    pixelformat;       <span class="comment">/* Format fourcc      */</span></span><br><span class="line">__u32    reserved[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="设置帧格式">设置帧格式</h4><p><code>VIDIOC_G_FMT</code>  和 <code>VIDIOC_S_FMT</code>，v4l2_format 结构体存放视频格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct v4l2_format - stream data format</span></span><br><span class="line"><span class="comment"> * @type:enum v4l2_buf_type; type of the data stream</span></span><br><span class="line"><span class="comment"> * @pix:definition of an image format</span></span><br><span class="line"><span class="comment"> * @pix_mp:definition of a multiplanar image format</span></span><br><span class="line"><span class="comment"> * @win:definition of an overlaid image</span></span><br><span class="line"><span class="comment"> * @vbi:raw VBI capture or output parameters</span></span><br><span class="line"><span class="comment"> * @sliced:sliced VBI capture or output parameters</span></span><br><span class="line"><span class="comment"> * @raw_data:placeholder for future extensions and custom formats</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_format</span> &#123;</span></span><br><span class="line">__u32 type;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_pix_format</span><span class="title">pix</span>;</span>     <span class="comment">/* V4L2_BUF_TYPE_VIDEO_CAPTURE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_pix_format_mplane</span><span class="title">pix_mp</span>;</span>  <span class="comment">/* V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_window</span><span class="title">win</span>;</span>     <span class="comment">/* V4L2_BUF_TYPE_VIDEO_OVERLAY */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_vbi_format</span><span class="title">vbi</span>;</span>     <span class="comment">/* V4L2_BUF_TYPE_VBI_CAPTURE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_sliced_vbi_format</span><span class="title">sliced</span>;</span>  <span class="comment">/* V4L2_BUF_TYPE_SLICED_VBI_CAPTURE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_sdr_format</span><span class="title">sdr</span>;</span>     <span class="comment">/* V4L2_BUF_TYPE_SDR_CAPTURE */</span></span><br><span class="line">__u8raw_data[<span class="number">200</span>];                   <span class="comment">/* user-defined */</span></span><br><span class="line">&#125; fmt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>type 为枚举体 v4l2_buf_type 的一项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">v4l2_buf_type</span> &#123;</span></span><br><span class="line">V4L2_BUF_TYPE_VIDEO_CAPTURE        = <span class="number">1</span>,</span><br><span class="line">V4L2_BUF_TYPE_VIDEO_OUTPUT         = <span class="number">2</span>,</span><br><span class="line">V4L2_BUF_TYPE_VIDEO_OVERLAY        = <span class="number">3</span>,</span><br><span class="line">V4L2_BUF_TYPE_VBI_CAPTURE          = <span class="number">4</span>,</span><br><span class="line">V4L2_BUF_TYPE_VBI_OUTPUT           = <span class="number">5</span>,</span><br><span class="line">V4L2_BUF_TYPE_SLICED_VBI_CAPTURE   = <span class="number">6</span>,</span><br><span class="line">V4L2_BUF_TYPE_SLICED_VBI_OUTPUT    = <span class="number">7</span>,</span><br><span class="line">V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = <span class="number">8</span>,</span><br><span class="line">V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = <span class="number">9</span>,</span><br><span class="line">V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE  = <span class="number">10</span>,</span><br><span class="line">V4L2_BUF_TYPE_SDR_CAPTURE          = <span class="number">11</span>,</span><br><span class="line">V4L2_BUF_TYPE_SDR_OUTPUT           = <span class="number">12</span>,</span><br><span class="line"><span class="comment">/* Deprecated, do not use */</span></span><br><span class="line">V4L2_BUF_TYPE_PRIVATE              = <span class="number">0x80</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>v4l2_pix_format 结构体存放捕获设备的帧格式属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *V I D E O   I M A G E   F O R M A T</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_pix_format</span> &#123;</span></span><br><span class="line">__u32         width;</span><br><span class="line">__u32height;</span><br><span class="line">__u32pixelformat;</span><br><span class="line">__u32field;<span class="comment">/* enum v4l2_field */</span></span><br><span class="line">__u32            bytesperline;<span class="comment">/* for padding, zero if unused */</span></span><br><span class="line">__u32          sizeimage;</span><br><span class="line">__u32colorspace;<span class="comment">/* enum v4l2_colorspace */</span></span><br><span class="line">__u32priv;<span class="comment">/* private data, depends on pixelformat */</span></span><br><span class="line">__u32flags;<span class="comment">/* format flags (V4L2_PIX_FMT_FLAG_*) */</span></span><br><span class="line">__u32ycbcr_enc;<span class="comment">/* enum v4l2_ycbcr_encoding */</span></span><br><span class="line">__u32quantization;<span class="comment">/* enum v4l2_quantization */</span></span><br><span class="line">__u32xfer_func;<span class="comment">/* enum v4l2_xfer_func */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="申请缓冲区">申请缓冲区</h4><p><code>VIDIOC_REQBUFS</code> 申请缓冲区需要应用程序来做，可以申请多个 buffer，但驱动程序不一定能申请到。通过结构体 v4l2_requestbuffers 请求驱动申请一片连续的内存用于缓存视频信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *M E M O R Y - M A P P I N G   B U F F E R S</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_requestbuffers</span> &#123;</span></span><br><span class="line">__u32count;<span class="comment">// 缓冲区内缓冲帧的数目</span></span><br><span class="line">__u32type;<span class="comment">/* enum v4l2_buf_type 缓冲帧数据格式 */</span></span><br><span class="line">__u32memory;<span class="comment">/* enum v4l2_memory 区别是内存映射还是用户指针方式 */</span></span><br><span class="line">__u32reserved[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>枚举体 v4l2_memory，一般使用 mmap 方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">v4l2_memory</span> &#123;</span></span><br><span class="line">V4L2_MEMORY_MMAP             = <span class="number">1</span>,</span><br><span class="line">V4L2_MEMORY_USERPTR          = <span class="number">2</span>,</span><br><span class="line">V4L2_MEMORY_OVERLAY          = <span class="number">3</span>,</span><br><span class="line">V4L2_MEMORY_DMABUF           = <span class="number">4</span>,<span class="comment">// 这个应该是新版本的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="查询缓冲区">查询缓冲区</h4><p><code>VIDIOC_QUERYBUF</code> 查询 buffer 信息，如果申请了 N 个 buffer，ioctl 就应该执行 N 次，执行 mmap 后，应用程序就可以直接读写这些 buffer 了。</p><p>v4l2_buffer 结构体存放 buffer 的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct v4l2_buffer - video buffer info</span></span><br><span class="line"><span class="comment"> * @index:id number of the buffer</span></span><br><span class="line"><span class="comment"> * @type:enum v4l2_buf_type; buffer type (type == *_MPLANE for</span></span><br><span class="line"><span class="comment"> *multiplanar buffers);</span></span><br><span class="line"><span class="comment"> * @bytesused:number of bytes occupied by data in the buffer (payload);</span></span><br><span class="line"><span class="comment"> *unused (set to 0) for multiplanar buffers</span></span><br><span class="line"><span class="comment"> * @flags:buffer informational flags</span></span><br><span class="line"><span class="comment"> * @field:enum v4l2_field; field order of the image in the buffer</span></span><br><span class="line"><span class="comment"> * @timestamp:frame timestamp</span></span><br><span class="line"><span class="comment"> * @timecode:frame timecode</span></span><br><span class="line"><span class="comment"> * @sequence:sequence count of this frame</span></span><br><span class="line"><span class="comment"> * @memory:enum v4l2_memory; the method, in which the actual video data is</span></span><br><span class="line"><span class="comment"> *passed</span></span><br><span class="line"><span class="comment"> * @offset:for non-multiplanar buffers with memory == V4L2_MEMORY_MMAP;</span></span><br><span class="line"><span class="comment"> *offset from the start of the device memory for this plane,</span></span><br><span class="line"><span class="comment"> *(or a &quot;cookie&quot; that should be passed to mmap() as offset)</span></span><br><span class="line"><span class="comment"> * @userptr:for non-multiplanar buffers with memory == V4L2_MEMORY_USERPTR;</span></span><br><span class="line"><span class="comment"> *a userspace pointer pointing to this buffer</span></span><br><span class="line"><span class="comment"> * @fd:for non-multiplanar buffers with memory == V4L2_MEMORY_DMABUF;</span></span><br><span class="line"><span class="comment"> *a userspace file descriptor associated with this buffer</span></span><br><span class="line"><span class="comment"> * @planes:for multiplanar buffers; userspace pointer to the array of plane</span></span><br><span class="line"><span class="comment"> *info structs for this buffer</span></span><br><span class="line"><span class="comment"> * @length:size in bytes of the buffer (NOT its payload) for single-plane</span></span><br><span class="line"><span class="comment"> *buffers (when type != *_MPLANE); number of elements in the</span></span><br><span class="line"><span class="comment"> *planes array for multi-plane buffers</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Contains data exchanged by application and driver using one of the Streaming</span></span><br><span class="line"><span class="comment"> * I/O methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> &#123;</span></span><br><span class="line">__u32index;</span><br><span class="line">__u32type;</span><br><span class="line">__u32bytesused;</span><br><span class="line">__u32flags;</span><br><span class="line">__u32field;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span><span class="title">timestamp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_timecode</span><span class="title">timecode</span>;</span></span><br><span class="line">__u32sequence;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* memory location */</span></span><br><span class="line">__u32memory;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__u32           offset;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>   userptr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_plane</span> *<span class="title">planes</span>;</span></span><br><span class="line">__s32fd;</span><br><span class="line">&#125; m;</span><br><span class="line">__u32length;</span><br><span class="line">__u32reserved2;</span><br><span class="line">__u32reserved;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="放入-取出队列">放入/取出队列</h4><p><code>VIDIOC_QBUF</code> 把 buffer 放入队列，如果申请了 N 个 buffer，ioctl 就应该执行 N 次。</p><p><code>VIDIOC_DQBUF</code> 把 buffer 从队列中取出。</p><h4 id="启动-停止摄像头数据流">启动/停止摄像头数据流</h4><p><code>VIDIOC_STREAMON</code> 和 <code>VIDIOC_STREAMOFF</code>，开启摄像头数据流后一般是一个循环，使用 poll/select 监测 buffer 是否有数据，然后从输出队列中取出 buffer，处理后再放入输入队列。</p><blockquote><p><a href="https://blog.csdn.net/eastmoon502136/article/details/8190262">和菜鸟一起学linux之V4L2摄像头应用流程-CSDN博客</a></p><p><a href="https://blog.csdn.net/g_salamander/article/details/8107692">v4l2 编程接口(一) — ioctl_v4l2 帧id-CSDN博客</a></p></blockquote><h2 id="配置内核支持-usb-摄像头">配置内核支持 USB 摄像头</h2><p>摄像头有多种接口 MIPI、DVP、USB 等，这里先使用了 USB 摄像头上手一下，后续再改用其他接口的摄像头。使用 USB 摄像头是因为支持 UVC（USB Video Capture）协议，可以不用写驱动文件先熟悉下 v4l2 框架，也就是常说的 USB 免驱。</p><h3 id="使能-uvc-驱动">使能 UVC 驱动</h3><p>Linux 内核已经帮我们写好了 UVC 驱动，我们只需要<strong>在 Linux 内核配置中使能 UVC 驱动</strong>即可。</p><p>进入 Linux 内核图形配置界面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line">Device Drivers -&gt;</span><br><span class="line"><span class="meta prompt_">-&gt;</span><span class="language-bash">Multimedia Support</span></span><br><span class="line"><span class="meta prompt_">-&gt;</span><span class="language-bash">Media USB Adapters--</span></span><br><span class="line"><span class="meta prompt_">-&gt;</span><span class="language-bash">USB Video Class(UVC)</span></span><br></pre></td></tr></table></figure><p><img src="image-20240812151124836.png" alt="image-20240812151124836"></p><p>若没有 USB Video Class（UVC）这一项，则搜索 <code>USB_VIDEO_CLASS</code> 查看其依赖项，然后将其依赖项都选择，保存后重新打开。</p><p><img src="image-20240812151323053.png" alt="image-20240812151323053"></p><p>接着打开 <code>Soc camera support</code> 和 <code>platform camera support</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers -&gt;</span><br><span class="line">-&gt;Multimedia Support</span><br><span class="line">-&gt;Media USB Adapters--</span><br><span class="line">-&gt;V4L platform devices</span><br></pre></td></tr></table></figure><p><img src="image-20240812151643873.png" alt="image-20240812151643873"></p><h3 id="添加摄像头的-pid-和-vid">添加摄像头的 PID 和 VID</h3><p>将摄像头插上电脑上，打开设备管理器查看摄像头的 PID 和 VID：</p><p><img src="image-20240812151947981.png" alt="image-20240812151947981"></p><p>打开内核文件中的 <code>drivers/media/usb/uvc/uvc_driver.c</code>，找到结构体 <code>uvc_ids</code> 仿照其他摄像头的代码，添加摄像头的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* add my camera modify your pid and vid */</span></span><br><span class="line">        &#123; .match_flags          = USB_DEVICE_ID_MATCH_DEVICE</span><br><span class="line">                                | USB_DEVICE_ID_MATCH_INT_INFO,</span><br><span class="line">          .idVendor             = <span class="number">0x1bcf</span>,</span><br><span class="line">          .idProduct            = <span class="number">0x0b09</span>,</span><br><span class="line">          .bInterfaceClass      = USB_CLASS_VIDEO,</span><br><span class="line">          .bInterfaceSubClass   = <span class="number">1</span>,</span><br><span class="line">          .bInterfaceProtocol   = <span class="number">0</span>,</span><br><span class="line">          .driver_info          = UVC_QUIRK_RESTRICT_FRAME_RATE &#125;,</span><br></pre></td></tr></table></figure><p>最后重新编译内核并将新内核重新烧录到开发板上，插上摄像头就可以检测搭配设备了。</p><p><img src="image-20240812153137246.png" alt="image-20240812153137246"></p><p>我的开发板上默认有 <code>/dev/video0</code> 这个节点了，所以插入摄像头后是 <code>/dev/video1</code>。</p><h2 id="编写应用程序测试">编写应用程序测试</h2><p>可参考 mjpg-streamer 项目中的 <code>plugins/input_uvc</code> 目录下的文件。</p><blockquote><p><a href="https://github.com/jacksonliam/mjpg-streamer/tree/master">jacksonliam/mjpg-streamer: Fork of http://sourceforge.net/projects/mjpg-streamer/ (github.com)</a></p></blockquote><p>uvc_camera_capture.h 文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UVC_CAMERA_CAPTURE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UVC_CAMERA_CAPTURE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/videodev2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jpeglib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG(...) printf(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NB_BUFFER 4</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vdIn</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> *videodevice;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_fmtdesc</span> <span class="title">fmtdesc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_frmsizeenum</span> <span class="title">frmsizeenum</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_streamparm</span> <span class="title">streamparm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_capability</span> <span class="title">cap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_format</span> <span class="title">fmt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_requestbuffers</span> <span class="title">rb</span>;</span></span><br><span class="line">    <span class="type">void</span> *mem[NB_BUFFER];</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="type">int</span> fps;</span><br><span class="line">    <span class="type">int</span> formatIn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcdFramebuffer</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">var</span>;</span>   <span class="comment">/* LCD可变参数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *base;          <span class="comment">/* Framebuffer映射基地址 */</span>   </span><br><span class="line">    <span class="type">int</span> width, height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>uvc_camera_capture.c 文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uvc_camera_capture.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">jpeg_to_rgb</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *jpegData, <span class="type">char</span> *rgbData, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">clock_t</span> start_time, end_time;</span><br><span class="line">    start_time = clock();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">jpeg_error_mgr</span> <span class="title">jerr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">jpeg_decompress_struct</span> <span class="title">cinfo</span>;</span></span><br><span class="line">cinfo.err = jpeg_std_error(&amp;jerr);</span><br><span class="line"><span class="comment">// 1. 创建解码对象并且初始化</span></span><br><span class="line">jpeg_create_decompress(&amp;cinfo);</span><br><span class="line"><span class="comment">// 2. 装备解码的数据</span></span><br><span class="line"><span class="comment">//jpeg_stdio_src(&amp;cinfo, infile);</span></span><br><span class="line">jpeg_mem_src(&amp;cinfo, jpegData, size);</span><br><span class="line"><span class="comment">// 3. 获取jpeg图片文件的参数</span></span><br><span class="line">jpeg_read_header(&amp;cinfo, TRUE);</span><br><span class="line"><span class="comment">/* Step 4: set parameters for decompression */</span></span><br><span class="line"><span class="comment">// 5. 开始解码</span></span><br><span class="line">jpeg_start_decompress(&amp;cinfo);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">调用jpeg_start_decompress函数之后，JPEG解压对象dinfo中</span></span><br><span class="line"><span class="comment">下面这几个字段(成员变量)将会比较有用：</span></span><br><span class="line"><span class="comment">dinfo.output_width: 图像输出宽度，一行占多少个像素点</span></span><br><span class="line"><span class="comment">dinfo.output_height:图像输出高度，占多少行</span></span><br><span class="line"><span class="comment">dinfo.output_components:  每个像素点的分量数，每个像素点占多少个字节</span></span><br><span class="line"><span class="comment">3： R G B</span></span><br><span class="line"><span class="comment">4：A R G B</span></span><br><span class="line"><span class="comment">width * height * components</span></span><br><span class="line"><span class="comment">在调用jpeg_start_decompress之后，往往需要为解压后的扫描线上的</span></span><br><span class="line"><span class="comment">所有像素点分配存储空间： </span></span><br><span class="line"><span class="comment">存一行： output_width * output_components</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 6.申请存储一行数据的内存空间</span></span><br><span class="line"><span class="type">int</span> row_stride = cinfo.output_width * cinfo.output_components;</span><br><span class="line">    <span class="comment">//printf(&quot;output_width: %d, output_components: %d\n&quot;, cinfo.output_width, cinfo.output_components);</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buffer = <span class="built_in">malloc</span>(row_stride);</span><br><span class="line">    <span class="comment">// dinfo.output_scanline , 表示的意思是，已经扫描了多少行</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (cinfo.output_scanline &lt; cinfo.output_height) &#123;</span><br><span class="line">        jpeg_read_scanlines(&amp;cinfo, &amp;buffer, <span class="number">1</span>); </span><br><span class="line">    <span class="built_in">memcpy</span>(rgbData + i * <span class="number">640</span> * <span class="number">3</span>, buffer, row_stride);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">对扫描线的读取是按照从上到下的顺序进行的，也就是说图像最上方的扫描线最先</span></span><br><span class="line"><span class="comment">被jpeg_read_scanlines()读入到存储空间中，紧接着是第二行扫描线，最后是</span></span><br><span class="line"><span class="comment">图像底边的扫描线被读入到存储空间中去。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 7.解码完成</span></span><br><span class="line">jpeg_finish_decompress(&amp;cinfo);</span><br><span class="line"><span class="comment">// 8.释放解码对象</span></span><br><span class="line">jpeg_destroy_decompress(&amp;cinfo);</span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line"></span><br><span class="line">    end_time = clock();</span><br><span class="line">    DBG(<span class="string">&quot;mjpeg to rgb waste time %f s\n&quot;</span>, (<span class="type">double</span>)(end_time - start_time)/CLOCKS_PER_SEC);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据流以3字节为单位拷贝到rgb显存中</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">lcd_show_rgb</span><span class="params">(<span class="keyword">struct</span> lcdFramebuffer *lfb, <span class="type">unsigned</span> <span class="type">char</span> *rgbData, <span class="type">int</span> width ,<span class="type">int</span> height)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">clock_t</span> start_time, end_time;</span><br><span class="line">    start_time = clock();</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *row_start = lfb-&gt;base; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *srcData = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> r, g, b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; height; i++)&#123;</span><br><span class="line">        ptr = row_start;     <span class="comment">// 每次指向当前行的起始地址</span></span><br><span class="line">        srcData = rgbData;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; width; j++)&#123;</span><br><span class="line">            <span class="comment">// r = *srcData++;</span></span><br><span class="line">            <span class="comment">// g = *srcData++;</span></span><br><span class="line">            <span class="comment">// b = *srcData++;</span></span><br><span class="line">            <span class="comment">// *ptr++ = (0xFF &lt;&lt; 24) | ((unsigned int)r &lt;&lt; 16) |</span></span><br><span class="line">            <span class="comment">//          ((unsigned int)g &lt;&lt; 8) | (unsigned int)b;</span></span><br><span class="line">            *ptr++ = (<span class="number">0xFF</span> &lt;&lt; <span class="number">24</span>) | ((*srcData++) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">                     ((*srcData++) &lt;&lt; <span class="number">8</span>) | (*srcData++);</span><br><span class="line">        &#125;</span><br><span class="line">        rgbData += width * <span class="number">3</span>;      <span class="comment">// 图像大小的偏移</span></span><br><span class="line">        row_start += lfb-&gt;width;   <span class="comment">// 屏幕大小的偏移</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    end_time = clock();</span><br><span class="line">    DBG(<span class="string">&quot;Write fb waste time %f s\n&quot;</span>, (<span class="type">double</span>)(end_time - start_time)/CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fcc2s - convert pixelformat to string</span></span><br><span class="line"><span class="comment">* (Obtained from vtl-utils: v4l2-ctl.cpp)</span></span><br><span class="line"><span class="comment">* args:</span></span><br><span class="line"><span class="comment">* fmsString - char* to hold string</span></span><br><span class="line"><span class="comment">* size - size of allocated memory for string</span></span><br><span class="line"><span class="comment">* pixelformat - v4l2 pixel format identidifier</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fcc2s</span><span class="params">(<span class="type">char</span>* fmtString, <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> pixelformat)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( size &lt; <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    fmtString[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  fmtString[<span class="number">0</span>] = pixelformat &amp; <span class="number">0x7f</span>;</span><br><span class="line">  fmtString[<span class="number">1</span>] = (pixelformat &gt;&gt;  <span class="number">8</span> ) &amp; <span class="number">0x7f</span>;</span><br><span class="line">  fmtString[<span class="number">2</span>] = (pixelformat &gt;&gt;  <span class="number">16</span> ) &amp; <span class="number">0x7f</span>;</span><br><span class="line">  fmtString[<span class="number">3</span>] = (pixelformat &gt;&gt; <span class="number">24</span> ) &amp; <span class="number">0x7f</span>;</span><br><span class="line">  <span class="keyword">if</span> (pixelformat &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    fmtString[<span class="number">4</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    fmtString[<span class="number">5</span>] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    fmtString[<span class="number">6</span>] = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">    fmtString[<span class="number">7</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    fmtString[<span class="number">4</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">init_v4l2</span><span class="params">(<span class="keyword">struct</span> vdIn *vd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pixelFromatNum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> formatFrameSizeNum = <span class="number">0</span>;</span><br><span class="line">    vd-&gt;fd = open(vd-&gt;videodevice, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(vd-&gt;fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;ERROR opening V4L interface&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取摄像头能力</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;vd-&gt;cap, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_capability));</span><br><span class="line">    ret = ioctl(vd-&gt;fd, VIDIOC_QUERYCAP, &amp;vd-&gt;cap);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error opening device %s: unable to query deivce.\n&quot;</span>, vd-&gt;videodevice);</span><br><span class="line">        <span class="keyword">goto</span> fatal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DBG(<span class="string">&quot;driver:\t\t%s\n&quot;</span>, vd-&gt;cap.driver);</span><br><span class="line">    DBG(<span class="string">&quot;card:\t\t%s\n&quot;</span>, vd-&gt;cap.card);</span><br><span class="line">    DBG(<span class="string">&quot;bus_info:\t%s\n&quot;</span>, vd-&gt;cap.bus_info);</span><br><span class="line">    DBG(<span class="string">&quot;version:\t%d\n&quot;</span>, vd-&gt;cap.version);</span><br><span class="line">    DBG(<span class="string">&quot;capabilities:\t%x\n&quot;</span>, vd-&gt;cap.capabilities);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((vd-&gt;cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error opening device %s: video capture not supported.\n&quot;</span>,</span><br><span class="line">                vd-&gt;videodevice);</span><br><span class="line">        <span class="keyword">goto</span> fatal;;</span><br><span class="line">    &#125;</span><br><span class="line">    DBG(<span class="string">&quot;%s supports capture.\n&quot;</span>, vd-&gt;videodevice);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(vd-&gt;cap.capabilities &amp; V4L2_CAP_STREAMING == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s does not support streaming i/o\n&quot;</span>, vd-&gt;videodevice);</span><br><span class="line">            <span class="keyword">goto</span> fatal;</span><br><span class="line">    &#125;</span><br><span class="line">    DBG(<span class="string">&quot;%s supports streaming.\n&quot;</span>, vd-&gt;videodevice);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取camera信息</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;vd-&gt;fmtdesc, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_fmtdesc));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;vd-&gt;streamparm, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_streamparm));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;vd-&gt;frmsizeenum, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_frmsizeenum));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        vd-&gt;fmtdesc.index = pixelFromatNum++;</span><br><span class="line">        vd-&gt;fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;     <span class="comment">// 设置视频采集设备类型</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取摄像头支持的格式</span></span><br><span class="line">        ret = ioctl(vd-&gt;fd, VIDIOC_ENUM_FMT, &amp;vd-&gt;fmtdesc);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 获取默认帧率</span></span><br><span class="line">        vd-&gt;streamparm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; <span class="comment">// 设置视频采集设备类型</span></span><br><span class="line">        ret = ioctl(vd-&gt;fd, VIDIOC_G_PARM, &amp;vd-&gt;streamparm);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">            DBG(<span class="string">&quot;Default FPS: %d fps\n&quot;</span>, vd-&gt;streamparm.parm.capture.timeperframe.denominator);</span><br><span class="line">           </span><br><span class="line">        <span class="comment">// 列出该格式下支持的分辨率</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vd-&gt;frmsizeenum.index = formatFrameSizeNum++;</span><br><span class="line">            vd-&gt;frmsizeenum.pixel_format = vd-&gt;fmtdesc.pixelformat;</span><br><span class="line">            </span><br><span class="line">            ret = ioctl(vd-&gt;fd, VIDIOC_ENUM_FRAMESIZES, &amp;vd-&gt;frmsizeenum);</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">                DBG(<span class="string">&quot;Support Format:%s, %d, FrameSize %d: %d x %d\n&quot;</span>, vd-&gt;fmtdesc.description, vd-&gt;fmtdesc.pixelformat,</span><br><span class="line">                        formatFrameSizeNum, vd-&gt;frmsizeenum.discrete.width, vd-&gt;frmsizeenum.discrete.height);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        formatFrameSizeNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置采集格式</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;vd-&gt;fmt, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_format));</span><br><span class="line">    vd-&gt;fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    vd-&gt;fmt.fmt.pix.width = vd-&gt;width;</span><br><span class="line">    vd-&gt;fmt.fmt.pix.height = vd-&gt;height;</span><br><span class="line">    vd-&gt;fmt.fmt.pix.pixelformat = vd-&gt;formatIn;</span><br><span class="line">    vd-&gt;fmt.fmt.pix.field = V4L2_FIELD_ANY;</span><br><span class="line">    ret = ioctl(vd-&gt;fd, VIDIOC_S_FMT, &amp;vd-&gt;fmt);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to set format: %d res: %dx%d\n&quot;</span>, vd-&gt;formatIn, vd-&gt;width, vd-&gt;height);</span><br><span class="line">        <span class="keyword">goto</span> fatal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查设置分辨率是否正确 错误则自动设置</span></span><br><span class="line">    <span class="keyword">if</span>((vd-&gt;fmt.fmt.pix.width != vd-&gt;width) || (vd-&gt;fmt.fmt.pix.height != vd-&gt;height))&#123;</span><br><span class="line">        vd-&gt;width = vd-&gt;fmt.fmt.pix.width;</span><br><span class="line">        vd-&gt;height = vd-&gt;fmt.fmt.pix.height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查采集的像素格式是否正确 错误则自动设置</span></span><br><span class="line">    <span class="keyword">if</span>(vd-&gt;formatIn != vd-&gt;fmt.fmt.pix.pixelformat)&#123;</span><br><span class="line">        <span class="type">char</span> fmtStringRequested[<span class="number">8</span>];</span><br><span class="line">        <span class="type">char</span> fmtStringObtained[<span class="number">8</span>];</span><br><span class="line">        fcc2s(fmtStringObtained, <span class="number">8</span>, vd-&gt;fmt.fmt.pix.pixelformat);</span><br><span class="line">        fcc2s(fmtStringRequested, <span class="number">8</span>, vd-&gt;formatIn);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot; i: Could not obtain the requested pixelformat: %s , driver gave us: %s\n&quot;</span>,fmtStringRequested, fmtStringObtained);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot; i: The specified resolution is unavailable, using: width %d height %d instead \n&quot;</span>, vd-&gt;fmt.fmt.pix.width, vd-&gt;fmt.fmt.pix.height);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span>(vd-&gt;fmt.fmt.pix.pixelformat)&#123;</span><br><span class="line">            <span class="keyword">case</span> V4L2_PIX_FMT_JPEG:</span><br><span class="line">            <span class="comment">// Fall-through intentional</span></span><br><span class="line">            <span class="keyword">case</span> V4L2_PIX_FMT_MJPEG:</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;    ... Falling back to the faster MJPG mode (consider changing cmd line options).\n&quot;</span>);</span><br><span class="line">                vd-&gt;formatIn = vd-&gt;fmt.fmt.pix.pixelformat;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> V4L2_PIX_FMT_YUYV:</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;    ... Falling back to YUV mode (consider using -yuv option). Note that this requires much more CPU power\n&quot;</span>);</span><br><span class="line">                vd-&gt;formatIn = vd-&gt;fmt.fmt.pix.pixelformat;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> V4L2_PIX_FMT_UYVY:</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;    ... Falling back to UYVY mode (consider using -uyvy option). Note that this requires much more CPU power\n&quot;</span>);</span><br><span class="line">                vd-&gt;formatIn = vd-&gt;fmt.fmt.pix.pixelformat;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> V4L2_PIX_FMT_RGB24:</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;    ... Falling back to RGB24 mode (consider using -fourcc RGB24 option). Note that this requires much more CPU power\n&quot;</span>);</span><br><span class="line">                vd-&gt;formatIn = vd-&gt;fmt.fmt.pix.pixelformat;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> V4L2_PIX_FMT_RGB565:</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;    ... Falling back to RGB565 mode (consider using -fourcc RGBP option). Note that this requires much more CPU power\n&quot;</span>);</span><br><span class="line">                vd-&gt;formatIn = vd-&gt;fmt.fmt.pix.pixelformat;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">goto</span> fatal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> fmtStringRequested[<span class="number">8</span>];</span><br><span class="line">    fcc2s(fmtStringRequested, <span class="number">8</span>, vd-&gt;formatIn);</span><br><span class="line">    DBG(<span class="string">&quot;Set Format: %s, FrameSize: %d x %d\n&quot;</span>, fmtStringRequested, vd-&gt;width, vd-&gt;height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请内存</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;vd-&gt;rb, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_requestbuffers));</span><br><span class="line">    vd-&gt;rb.count = NB_BUFFER;</span><br><span class="line">    vd-&gt;rb.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    vd-&gt;rb.memory = V4L2_MEMORY_MMAP;   <span class="comment">// mmap方式</span></span><br><span class="line">    ret = ioctl(vd-&gt;fd, VIDIOC_REQBUFS, &amp;vd-&gt;rb);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;Unable to allocate buffers&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> fatal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mmap内存</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NB_BUFFER; i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;vd-&gt;buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_buffer));</span><br><span class="line">        vd-&gt;buf.index = i;</span><br><span class="line">        vd-&gt;buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">        vd-&gt;buf.memory = V4L2_MEMORY_MMAP;   <span class="comment">// mmap方式</span></span><br><span class="line"></span><br><span class="line">        ret = ioctl(vd-&gt;fd, VIDIOC_QUERYBUF, &amp;vd-&gt;buf); <span class="comment">// 查看buffer</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Unable to query buffer&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> fatal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vd-&gt;mem[i] = mmap(<span class="number">0</span>, vd-&gt;buf.length, PROT_READ | PROT_WRITE, </span><br><span class="line">                          MAP_SHARED, vd-&gt;fd, vd-&gt;buf.m.offset);</span><br><span class="line">        <span class="keyword">if</span>(vd-&gt;mem[i] == MAP_FAILED)&#123;</span><br><span class="line">            perror(<span class="string">&quot;Unable to map buffer&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> fatal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入队列</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NB_BUFFER; i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;vd-&gt;buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_buffer));</span><br><span class="line">        vd-&gt;buf.index = i;</span><br><span class="line">        vd-&gt;buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">        vd-&gt;buf.memory = V4L2_MEMORY_MMAP;   <span class="comment">// mmap方式</span></span><br><span class="line">        ret = ioctl(vd-&gt;fd, VIDIOC_QBUF, &amp;vd-&gt;buf);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Unable to queue buffer&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> fatal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fatal:</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Init v4L2 failed !! exit fatal\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">init_videoIn</span><span class="params">(<span class="keyword">struct</span> vdIn *vd, <span class="type">char</span> *device, <span class="type">int</span> width, </span></span><br><span class="line"><span class="params">                     <span class="type">int</span> height, <span class="type">int</span> fps, <span class="type">int</span> format)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(vd == <span class="literal">NULL</span> || device == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(width == <span class="number">0</span> || height == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    vd-&gt;videodevice = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">16</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">snprintf</span>(vd-&gt;videodevice, (<span class="number">16</span> - <span class="number">1</span>), <span class="string">&quot;%s&quot;</span>, device) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(vd-&gt;videodevice);</span><br><span class="line">        vd-&gt;videodevice = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vd-&gt;width = width;</span><br><span class="line">    vd-&gt;height = height;</span><br><span class="line">    vd-&gt;fps = fps;</span><br><span class="line">    vd-&gt;formatIn = format;</span><br><span class="line">    <span class="keyword">if</span>(init_v4l2(vd) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// error</span></span><br><span class="line">        <span class="built_in">free</span>(vd-&gt;videodevice);</span><br><span class="line">        vd-&gt;videodevice = <span class="literal">NULL</span>;</span><br><span class="line">        close(vd-&gt;fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free(vd-&gt;videodevice);</span></span><br><span class="line">    <span class="comment">// close(vd-&gt;fd);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">video_enable</span><span class="params">(<span class="keyword">struct</span> vdIn *vd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = ioctl(vd-&gt;fd, VIDIOC_STREAMON, &amp;type);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Unable to start capture&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//vd-&gt;streamingState = STREAMING_ON;</span></span><br><span class="line">    DBG(<span class="string">&quot;Starting capture\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">video_disable</span><span class="params">(<span class="keyword">struct</span> vdIn *vd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = ioctl(vd-&gt;fd, VIDIOC_STREAMOFF, &amp;type);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Unable to stop capture&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    DBG(<span class="string">&quot;Stopping capture\n&quot;</span>);</span><br><span class="line">    <span class="comment">//vd-&gt;streamingState = disabledState;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">video_handle</span><span class="params">(<span class="keyword">struct</span> vdIn *vd, <span class="keyword">struct</span> lcdFramebuffer *lfb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line">    <span class="type">char</span> filename[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> file_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个空间存储解码后的rgb</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> rgbData[<span class="number">640</span> * <span class="number">480</span> * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">clock_t</span> start_time, end_time;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        start_time = clock();</span><br><span class="line">        <span class="comment">// 1.poll</span></span><br><span class="line">        <span class="built_in">memset</span>(fds, <span class="number">0</span>, <span class="keyword">sizeof</span>(fds));</span><br><span class="line">        fds[<span class="number">0</span>].fd = vd-&gt;fd;</span><br><span class="line">        fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">        <span class="keyword">if</span>(poll(fds, <span class="number">1</span>, <span class="number">-1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 2.把buffer取出队列</span></span><br><span class="line">            <span class="built_in">memset</span>(&amp;vd-&gt;buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_buffer));</span><br><span class="line">            vd-&gt;buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">            vd-&gt;buf.memory = V4L2_MEMORY_MMAP;   <span class="comment">// mmap方式</span></span><br><span class="line"></span><br><span class="line">            ret = ioctl(vd-&gt;fd, VIDIOC_DQBUF, &amp;vd-&gt;buf);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;Unable to dequeue buffer&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// // 3.处理数据，这里将buffer数据存储为文件</span></span><br><span class="line">            <span class="comment">// sprintf(filename, &quot;video_raw_data_%04d.jpg&quot;, file_cnt++);</span></span><br><span class="line">            <span class="comment">// int fd_file = open(filename, O_RDWR | O_CREAT, 0666);</span></span><br><span class="line">            <span class="comment">// if(fd_file &lt; 0)</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     perror(&quot;create file error&quot;);</span></span><br><span class="line">            <span class="comment">//     close(fd);</span></span><br><span class="line">            <span class="comment">//     return -1;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// write(fd_file, userbuf[buffer.index], buffer.bytesused);</span></span><br><span class="line">            <span class="comment">// close(fd_file);</span></span><br><span class="line">            <span class="comment">// printf(&quot;create %s&quot;, filename);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.mjpg转换为rgb并显示在lcd屏幕</span></span><br><span class="line">            jpeg_to_rgb(vd-&gt;mem[vd-&gt;buf.index], rgbData, vd-&gt;buf.length);</span><br><span class="line">            <span class="comment">//read_JPEG_file(vd-&gt;mem[vd-&gt;buf.index], rgbData, vd-&gt;buf.length);</span></span><br><span class="line">            lcd_show_rgb(lfb, rgbData, <span class="number">640</span>, <span class="number">480</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.把buffer放入队列</span></span><br><span class="line">            ret = ioctl(vd-&gt;fd, VIDIOC_QBUF, &amp;vd-&gt;buf);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;Unable to queue buffer&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        end_time = clock();</span><br><span class="line">        DBG(<span class="string">&quot;Each frame waste time: %f s\n&quot;</span>, (<span class="type">double</span>)(end_time - start_time)/CLOCKS_PER_SEC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">init_framebuffer</span><span class="params">(<span class="keyword">struct</span> lcdFramebuffer *lfb, <span class="type">int</span> width, <span class="type">int</span> height)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(lfb == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开LCD</span></span><br><span class="line">    lfb-&gt;fd = open(<span class="string">&quot;/dev/fb0&quot;</span>, O_RDWR); </span><br><span class="line">    <span class="keyword">if</span>(lfb-&gt;fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;/dev/fb0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取LCD屏幕信息</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(lfb-&gt;fd, FBIOGET_VSCREENINFO, &amp;lfb-&gt;var))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Unable to get fb_var_screeninfo&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fb映射 4个字节 ARGB 8888</span></span><br><span class="line">    lfb-&gt;base = (<span class="type">unsigned</span> <span class="type">int</span>*)mmap(<span class="literal">NULL</span>, width * height * <span class="number">4</span>, </span><br><span class="line">                                    PROT_READ | PROT_WRITE, MAP_SHARED, lfb-&gt;fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfb-&gt;base == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Unable to map buffer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vdIn</span> *<span class="title">vd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lcdFramebuffer</span> *<span class="title">lfb</span>;</span></span><br><span class="line">    lfb = (<span class="keyword">struct</span> lcdFramebuffer *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> lcdFramebuffer));</span><br><span class="line">    vd = (<span class="keyword">struct</span> vdIn *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> vdIn));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化结构体</span></span><br><span class="line">    init_videoIn(vd, <span class="string">&quot;/dev/video1&quot;</span>, <span class="number">640</span>, <span class="number">480</span>, <span class="number">30</span>, V4L2_PIX_FMT_MJPEG);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开摄像头</span></span><br><span class="line">    video_enable(vd);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化fb</span></span><br><span class="line">    lfb-&gt;width = <span class="number">1024</span>;</span><br><span class="line">    lfb-&gt;height = <span class="number">600</span>;</span><br><span class="line">    init_framebuffer(lfb, <span class="number">1024</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理数据</span></span><br><span class="line">    video_handle(vd, lfb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁video内存</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NB_BUFFER; i++) &#123;</span><br><span class="line">        munmap(vd-&gt;mem[i], vd-&gt;buf.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(vd-&gt;videodevice);</span><br><span class="line">    vd-&gt;videodevice = <span class="literal">NULL</span>;</span><br><span class="line">    video_disable(vd);</span><br><span class="line">    close(vd-&gt;fd);</span><br><span class="line">    <span class="built_in">free</span>(vd);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 销毁fb内存</span></span><br><span class="line">    munmap(lfb-&gt;base, lfb-&gt;width * lfb-&gt;height);</span><br><span class="line">    <span class="built_in">free</span>(lfb);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行日志：</p><p><img src="image-20240813163957328.png" alt="image-20240813163957328"></p><p>最终显示分辨率 640x480，帧数 25 上下浮动，mjpeg 转为 rgb 格式消耗时间占比较大。</p><p>由于手上的屏幕分辨率为 1024 * 600，其余两种图像分辨率为 1280 x 720 和 1920 x 1080 不能直接写入 fb 进行显示，需要对采集到的图像分辨率进行放大缩小等操作，较为麻烦，后续使用 OpenCV 库来试试水。</p><blockquote><p><a href="https://blog.csdn.net/small_po_kid/article/details/119931147">在linux虚拟机上显示摄像头视频（V4L2编程）_v4l2命令行显示视频-CSDN博客</a></p><p><a href="https://blog.csdn.net/small_po_kid/article/details/119932202">嵌入式linux之在lcd上显示摄像头图像_esp32摄像头显示在lcd上-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_41248872/article/details/83031000">V4L2图像采集+图片格式转换（YUYV、RGB、JPEG）_qt中使用v4l2将jpeg格式的图像转化为rbg-CSDN博客</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux-v4l2-usb-camera&quot;&gt;Linux-V4L2-USB-Camera&lt;/h1&gt;
&lt;h2 id=&quot;序言&quot;&gt;序言&lt;/h2&gt;
&lt;p&gt;在 Linux 开发板上使用 V4L2 框架驱动 usb 摄像头。&lt;/p&gt;
&lt;h2 id=&quot;v4l2-简述&quot;&gt;V4L2</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/Linux/"/>
    
    
    <category term="Linux" scheme="http://www.obito.top/tags/Linux/"/>
    
    <category term="嵌入式" scheme="http://www.obito.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用EMQX搭建MQTT服务器</title>
    <link href="http://www.obito.top/2024/07/22/%E4%BD%BF%E7%94%A8EMQX%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://www.obito.top/2024/07/22/%E4%BD%BF%E7%94%A8EMQX%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2024-07-22T14:37:13.000Z</published>
    <updated>2024-12-21T10:51:02.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用emqx搭建mqtt服务器">使用EMQX搭建MQTT服务器</h1><h2 id="序言">序言</h2><p>早初是使用阿里云和 OneNET 平台作为 MQTT 服务器进行使用，但有些功能需要 money，所以就想着能不能自己搭建个简易的服务器来耍耍，查找资料找到 EMQX 很符合自己的需求。</p><p><a href="https://www.emqx.io/?__hstc=3614191.5d3d4ec83da83fa7c0c3952401d96e93.1717152719095.1717658001243.1721659210194.3&amp;__hssc=3614191.2.1721659210194&amp;__hsfp=886808949">EMQX</a> 是一款大规模可弹性伸缩的云原生分布式物联网 <a href="https://mqtt.org/">MQTT</a> 消息服务器。</p><p>作为全球最具扩展性的 MQTT 消息服务器，EMQX 提供了高效可靠海量物联网设备连接，能够高性能实时移动与处理消息和事件流数据，帮助您快速构建关键业务的物联网平台与应用。</p><p>EMQX 分为两个版本：开源版和商业版，这里作为学习使用，使用开源版即可，文档如下：</p><blockquote><p><a href="https://docs.emqx.com/zh/emqx/v5.0/">产品概览 | EMQX 5.0 文档</a></p></blockquote><h2 id="windows安装emqx">Windows安装EMQX</h2><p>EMQX 支持多平台安装，这里我使用 Windows 来安装，下载地址：</p><blockquote><p><a href="https://github.com/emqx/emqx/releases/tag/v5.3.2">Release EMQX v5.3.2 · emqx/emqx (github.com)</a></p></blockquote><p>目前一些较新的版本好像没有 Windows 版本的。</p><p>解压得到：</p><p><img src="image-20240722225644937.png" alt="image-20240722225644937"></p><p>当前目录下打开 <code>Windows PowerShell</code> 命令行窗口，输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bin\emqx start</span><br></pre></td></tr></table></figure><p>启动的时候会弹出防火墙提示窗口，点击允许访问。成功会提示如下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EMQX_NODE__DB_ROLE [node.role]: core</span><br><span class="line">EMQX_NODE__DB_BACKEND [node.db_backend]: mnesia</span><br></pre></td></tr></table></figure><p>常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.\bin\emqx start    启动</span><br><span class="line">.\bin\emqx stop     停止</span><br><span class="line">.\bin\emqx restart  重启 </span><br></pre></td></tr></table></figure><p>更多命令：</p><blockquote><p><a href="https://docs.emqx.com/zh/emqx/v5.0/admin/cli.html#%E5%91%BD%E4%BB%A4%E8%A1%8C">命令行 | EMQX 5.0 文档</a></p></blockquote><h2 id="配置emqx服务器">配置EMQX服务器</h2><h3 id="登录管理控制台">登录管理控制台</h3><p>启动后，浏览器输入 <code>127.0.0.1:18083</code> 就可以访问 EMQX 的后台管理界面。</p><p>默认用户名：admin，密码：public，第一次登录会提示修改密码，可以选择跳过。</p><p><img src="image-20240723001904503.png" alt="image-20240723001904503"></p><h3 id="mqtt-配置">MQTT 配置</h3><p>可以自定义设置 MQTT 的参数（<code>http://127.0.0.1:18083/#/mqtt/general</code>）：</p><p><img src="image-20240723002354191.png" alt="image-20240723002354191"></p><h3 id="测试-mqtt-通信">测试 MQTT 通信</h3><p>测试 MQTT 通信：打开 WebSocket 客户端（<code>http://127.0.0.1:18083/#/websocket</code>），点击连接——订阅——发布，显示接收消息表示通信正常。</p><p><img src="image-20240723002109740.png" alt="image-20240723002109740"></p><p>主题发布和主题订阅的格式可以自定义。</p><h3 id="qt-mqtt-客户端测试">QT-mqtt 客户端测试</h3><p>可以看到自己的客户端能够接收订阅主题发布的消息和发布消息到对应主题。</p><p><img src="image-20240723004943925.png" alt="image-20240723004943925"></p><p><img src="image-20240723004956314.png" alt="image-20240723004956314"></p><p><code>http://127.0.0.1:18083/#/clients</code> 可以查看连接的设备：</p><p><img src="image-20240723005005465.png" alt="image-20240723005005465"></p><h3 id="设置客户端认证">设置客户端认证</h3><p>EMQX 默认配置中启用了匿名认证，任何客户端都能接入 EMQX，这里可以设置客户端认证（<code>http://127.0.0.1:18083/#/authentication</code>），设置认证方式为 <code>Password-Based</code>，数据源为内置数据库。</p><p><img src="image-20240723005332343.png" alt="image-20240723005332343"></p><p>创建完成后添加用户</p><p><img src="image-20240723005622147.png" alt="image-20240723005622147"></p><p>再次使用客户端测试：</p><p><img src="image-20240723005701911.png" alt="image-20240723005701911"></p><p>没有使用创建好的用户进行连接，连接失败，修改添加的用户信息再次连接：</p><p><img src="image-20240723005806009.png" alt="image-20240723005806009"></p><h2 id="总结">总结</h2><p>EMQX 还有很多功能，例如：</p><ul><li>设置每个客户端的权限，限制它是否可以发布主题和订阅主题；</li><li>数据转发，将数据妆发到自己的 HTTP 服务器或者其他的 MQTT 服务器。</li></ul><p>我目前暂时只需要用到文中介绍的功能，做个记录。</p><blockquote><p><a href="https://xiaolong.blog.csdn.net/article/details/134280836">搭建自己的MQTT服务器、实现设备上云(Windows+EMQX)_mqtt服务器搭建-CSDN博客</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用emqx搭建mqtt服务器&quot;&gt;使用EMQX搭建MQTT服务器&lt;/h1&gt;
&lt;h2 id=&quot;序言&quot;&gt;序言&lt;/h2&gt;
&lt;p&gt;早初是使用阿里云和 OneNET 平台作为 MQTT 服务器进行使用，但有些功能需要 money，所以就想着能不能自己搭建个简易的服务器来耍耍</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>交叉编译QT-MQTT库</title>
    <link href="http://www.obito.top/2024/07/22/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91QT-MQTT%E5%BA%93/"/>
    <id>http://www.obito.top/2024/07/22/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91QT-MQTT%E5%BA%93/</id>
    <published>2024-07-22T12:42:20.000Z</published>
    <updated>2024-07-22T14:31:11.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="交叉编译qt-mqtt库">交叉编译QT-MQTT库</h1><h2 id="序言">序言</h2><p>前置条件：需要有交叉编译好的 arm 环境的 qt 工具，本文不涉及。</p><p>交叉编译 qt-mqtt 库在 arm 开发板上运行 mqtt 客户端连接 mqtt 服务器。</p><h2 id="交叉编译过程">交叉编译过程</h2><p>编译出来的 Qt Mqtt 库，要使用它有两种方式，</p><ul><li>一种是直接在项目中导入外部库和头文件</li><li>一种是将其以模块的形式部署到 Qt 的安装目录，这里采用这种，不需要每次导入外部库</li></ul><p>下载 qt-mqtt 源码，版本需要与 qt 版本相同，下载地址：</p><blockquote><p><a href="https://github.com/qt/qtmqtt">qt/qtmqtt: Qt Module to implement MQTT protocol version 3.1 and 3.1.1 http://mqtt.org/ (github.com)</a></p></blockquote><h3 id="解压得到下列文件：">解压得到下列文件：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router2@ubuntu:~/third_lib/qtmqtt-5.15$ ls</span><br><span class="line">dist      LICENSE.GPL3         qtmqtt.pro  sync.profile</span><br><span class="line">examples  LICENSE.GPL3-EXCEPT  src         tests</span><br></pre></td></tr></table></figure><h3 id="复制头文件">复制头文件</h3><p>先把 <code>qtmqtt-5.15/src/mqtt</code> 目录中的所有 <code>.h</code> 文件复制到 qt 源码的 <code>include</code> 目录中的 <code>QtMqtt</code> 目录，<strong>QtMqtt 目录是自行创建的</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/router2/Third-party-library/QT/qt-5.15.13/include/QtMqtt</span><br><span class="line"></span><br><span class="line">cp src/mqtt/*.h /home/router2/Third-party-library/QT/qt-5.15.13/include/QtMqtt</span><br></pre></td></tr></table></figure><h3 id="编译">编译</h3><p>使用 qmake 进行配置生成 Makefile 文件，然后进行编译生成 lib 库文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/home/router2/Third-party-library/QT/qt-5.15.13/bin/qmake </span><br><span class="line"></span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>文件如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router2@ubuntu:~/third_lib/qtmqtt-5.15$ ls</span><br><span class="line">bin       include       LICENSE.GPL3-EXCEPT  qtmqtt.pro    tests</span><br><span class="line">dist      lib           Makefile             src</span><br><span class="line">examples  LICENSE.GPL3  mkspecs              sync.profile</span><br></pre></td></tr></table></figure><h3 id="复制库文件">复制库文件</h3><p>将编译生成 lib 库文件复制到 qt 源码的 lib 目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -rfa lib/libQt5Mqtt.* /home/router2/Third-party-library/QT/qt-5.15.13/lib/</span><br></pre></td></tr></table></figure><h3 id="复制模块配置文件">复制模块配置文件</h3><p>将 <code>mkspecs/</code> 下的目录都复制到 qt 源码的 <code>mkspecs/</code> 目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -rfa mkspecs/* /home/router2/Third-party-library/QT/qt-5.15.13/mkspecs/</span><br></pre></td></tr></table></figure><p>打开 <code>mkspecs/modules/qt_lib_mqtt.pri</code> 内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QT_MODULE_BIN_BASE = /home/router2/third_lib/qtmqtt-5.15/bin</span><br><span class="line">QT_MODULE_INCLUDE_BASE = /home/router2/third_lib/qtmqtt-5.15/include</span><br><span class="line">QT_MODULE_LIB_BASE = /home/router2/third_lib/qtmqtt-5.15/lib</span><br><span class="line">QT_MODULE_HOST_LIB_BASE = /home/router2/third_lib/qtmqtt-5.15/lib</span><br><span class="line">include(/home/router2/third_lib/qtmqtt-5.15/mkspecs/modules-inst/qt_lib_mqtt.pri)</span><br><span class="line">QT.mqtt.priority = 1</span><br><span class="line">include(/home/router2/third_lib/qtmqtt-5.15/mkspecs/modules-inst/qt_lib_mqtt_private.pri)</span><br><span class="line">QT.mqtt_private.priority = 1</span><br></pre></td></tr></table></figure><p>这里的路径还是使用未复制前的路径，避免以后误删，这里修改一下路径为当前存放的路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QT_MODULE_BIN_BASE = /home/router2/Third-party-library/QT/qt-5.15.13/bin</span><br><span class="line">QT_MODULE_INCLUDE_BASE = /home/router2/Third-party-library/QT/qt-5.15.13/include</span><br><span class="line">QT_MODULE_LIB_BASE = /home/router2/Third-party-library/QT/qt-5.15.13/lib</span><br><span class="line">QT_MODULE_HOST_LIB_BASE = /home/router2/Third-party-library/QT/qt-5.15.13/lib</span><br><span class="line">include(/home/router2/Third-party-library/QT/qt-5.15.13/mkspecs/modules-inst/qt_lib_mqtt.pri)</span><br><span class="line">QT.mqtt.priority = 1</span><br><span class="line">include(/home/router2/Third-party-library/QT/qt-5.15.13/mkspecs/modules-inst/qt_lib_mqtt_private.pri)</span><br><span class="line">QT.mqtt_private.priority = 1</span><br></pre></td></tr></table></figure><p>之后新建工程时直接在 .pro 文件添加 mqtt 模块即可。</p><h2 id="测试">测试</h2><p>将 mqtt 源码的 lib 库文件移植到开发板中，测试的时候由于需要连接服务器，所以<strong>开发板需要能访问网络</strong>。</p><p>使用 qt mqtt 源码中自带的例子来编译运行，打开 <code>example/mqtt/simpleclient</code></p><p><code>.pro</code> 文件修改，将下列内容注释掉，否则无法独立运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target.path = $$[QT_INSTALL_EXAMPLES]/mqtt/simpleclient</span><br><span class="line">INSTALLS += target</span><br></pre></td></tr></table></figure><p><code>mainwindow.h</code> 文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** Copyright (C) 2017 The Qt Company Ltd.</span></span><br><span class="line"><span class="comment">** Contact: https://www.qt.io/licensing/</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** This file is part of the examples of the Qt Toolkit.</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** $QT_BEGIN_LICENSE:BSD$</span></span><br><span class="line"><span class="comment">** Commercial License Usage</span></span><br><span class="line"><span class="comment">** Licensees holding valid commercial Qt licenses may use this file in</span></span><br><span class="line"><span class="comment">** accordance with the commercial license agreement provided with the</span></span><br><span class="line"><span class="comment">** Software or, alternatively, in accordance with the terms contained in</span></span><br><span class="line"><span class="comment">** a written agreement between you and The Qt Company. For licensing terms</span></span><br><span class="line"><span class="comment">** and conditions see https://www.qt.io/terms-conditions. For further</span></span><br><span class="line"><span class="comment">** information use the contact form at https://www.qt.io/contact-us.</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** BSD License Usage</span></span><br><span class="line"><span class="comment">** Alternatively, you may use this file under the terms of the BSD license</span></span><br><span class="line"><span class="comment">** as follows:</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** &quot;Redistribution and use in source and binary forms, with or without</span></span><br><span class="line"><span class="comment">** modification, are permitted provided that the following conditions are</span></span><br><span class="line"><span class="comment">** met:</span></span><br><span class="line"><span class="comment">**   * Redistributions of source code must retain the above copyright</span></span><br><span class="line"><span class="comment">**     notice, this list of conditions and the following disclaimer.</span></span><br><span class="line"><span class="comment">**   * Redistributions in binary form must reproduce the above copyright</span></span><br><span class="line"><span class="comment">**     notice, this list of conditions and the following disclaimer in</span></span><br><span class="line"><span class="comment">**     the documentation and/or other materials provided with the</span></span><br><span class="line"><span class="comment">**     distribution.</span></span><br><span class="line"><span class="comment">**   * Neither the name of The Qt Company Ltd nor the names of its</span></span><br><span class="line"><span class="comment">**     contributors may be used to endorse or promote products derived</span></span><br><span class="line"><span class="comment">**     from this software without specific prior written permission.</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span></span><br><span class="line"><span class="comment">** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span></span><br><span class="line"><span class="comment">** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span></span><br><span class="line"><span class="comment">** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span></span><br><span class="line"><span class="comment">** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span></span><br><span class="line"><span class="comment">** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span></span><br><span class="line"><span class="comment">** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span></span><br><span class="line"><span class="comment">** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span></span><br><span class="line"><span class="comment">** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span></span><br><span class="line"><span class="comment">** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span></span><br><span class="line"><span class="comment">** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** $QT_END_LICENSE$</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">****************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtMqtt/qmqttclient.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span>;</span><br><span class="line">&#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainWindow</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setClientPort</span><span class="params">(<span class="type">int</span> p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_buttonConnect_clicked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_buttonQuit_clicked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateLogStateChange</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">brokerDisconnected</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_buttonPublish_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_buttonSubscribe_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    QMqttClient *m_client;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><p><code>mainwindow.cpp</code> 文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** Copyright (C) 2017 The Qt Company Ltd.</span></span><br><span class="line"><span class="comment">** Contact: https://www.qt.io/licensing/</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** This file is part of the examples of the Qt Toolkit.</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** $QT_BEGIN_LICENSE:BSD$</span></span><br><span class="line"><span class="comment">** Commercial License Usage</span></span><br><span class="line"><span class="comment">** Licensees holding valid commercial Qt licenses may use this file in</span></span><br><span class="line"><span class="comment">** accordance with the commercial license agreement provided with the</span></span><br><span class="line"><span class="comment">** Software or, alternatively, in accordance with the terms contained in</span></span><br><span class="line"><span class="comment">** a written agreement between you and The Qt Company. For licensing terms</span></span><br><span class="line"><span class="comment">** and conditions see https://www.qt.io/terms-conditions. For further</span></span><br><span class="line"><span class="comment">** information use the contact form at https://www.qt.io/contact-us.</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** BSD License Usage</span></span><br><span class="line"><span class="comment">** Alternatively, you may use this file under the terms of the BSD license</span></span><br><span class="line"><span class="comment">** as follows:</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** &quot;Redistribution and use in source and binary forms, with or without</span></span><br><span class="line"><span class="comment">** modification, are permitted provided that the following conditions are</span></span><br><span class="line"><span class="comment">** met:</span></span><br><span class="line"><span class="comment">**   * Redistributions of source code must retain the above copyright</span></span><br><span class="line"><span class="comment">**     notice, this list of conditions and the following disclaimer.</span></span><br><span class="line"><span class="comment">**   * Redistributions in binary form must reproduce the above copyright</span></span><br><span class="line"><span class="comment">**     notice, this list of conditions and the following disclaimer in</span></span><br><span class="line"><span class="comment">**     the documentation and/or other materials provided with the</span></span><br><span class="line"><span class="comment">**     distribution.</span></span><br><span class="line"><span class="comment">**   * Neither the name of The Qt Company Ltd nor the names of its</span></span><br><span class="line"><span class="comment">**     contributors may be used to endorse or promote products derived</span></span><br><span class="line"><span class="comment">**     from this software without specific prior written permission.</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span></span><br><span class="line"><span class="comment">** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span></span><br><span class="line"><span class="comment">** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span></span><br><span class="line"><span class="comment">** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span></span><br><span class="line"><span class="comment">** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span></span><br><span class="line"><span class="comment">** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span></span><br><span class="line"><span class="comment">** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span></span><br><span class="line"><span class="comment">** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span></span><br><span class="line"><span class="comment">** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span></span><br><span class="line"><span class="comment">** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span></span><br><span class="line"><span class="comment">** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** $QT_END_LICENSE$</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">****************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtCore/QDateTime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtMqtt/qmqttclient.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QMessageBox&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    m_client = <span class="keyword">new</span> <span class="built_in">QMqttClient</span>(<span class="keyword">this</span>);</span><br><span class="line">    m_client-&gt;<span class="built_in">setHostname</span>(ui-&gt;lineEditHost-&gt;<span class="built_in">text</span>());</span><br><span class="line">    m_client-&gt;<span class="built_in">setPort</span>(ui-&gt;spinBoxPort-&gt;<span class="built_in">value</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(m_client, &amp;QMqttClient::stateChanged, <span class="keyword">this</span>, &amp;MainWindow::updateLogStateChange);</span><br><span class="line">    <span class="built_in">connect</span>(m_client, &amp;QMqttClient::disconnected, <span class="keyword">this</span>, &amp;MainWindow::brokerDisconnected);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(m_client, &amp;QMqttClient::messageReceived, <span class="keyword">this</span>, [<span class="keyword">this</span>](<span class="type">const</span> QByteArray &amp;message, <span class="type">const</span> QMqttTopicName &amp;topic) &#123;</span><br><span class="line">        <span class="type">const</span> QString content = QDateTime::<span class="built_in">currentDateTime</span>().<span class="built_in">toString</span>()</span><br><span class="line">                    + <span class="built_in">QLatin1String</span>(<span class="string">&quot; Received Topic: &quot;</span>)</span><br><span class="line">                    + topic.<span class="built_in">name</span>()</span><br><span class="line">                    + <span class="built_in">QLatin1String</span>(<span class="string">&quot; Message: &quot;</span>)</span><br><span class="line">                    + message</span><br><span class="line">                    + <span class="built_in">QLatin1Char</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        ui-&gt;editLog-&gt;<span class="built_in">insertPlainText</span>(content);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(m_client, &amp;QMqttClient::pingResponseReceived, <span class="keyword">this</span>, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">        <span class="type">const</span> QString content = QDateTime::<span class="built_in">currentDateTime</span>().<span class="built_in">toString</span>()</span><br><span class="line">                    + <span class="built_in">QLatin1String</span>(<span class="string">&quot; PingResponse&quot;</span>)</span><br><span class="line">                    + <span class="built_in">QLatin1Char</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        ui-&gt;editLog-&gt;<span class="built_in">insertPlainText</span>(content);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;lineEditHost, &amp;QLineEdit::textChanged, m_client, &amp;QMqttClient::setHostname);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;spinBoxPort, QOverload&lt;<span class="type">int</span>&gt;::<span class="built_in">of</span>(&amp;QSpinBox::valueChanged), <span class="keyword">this</span>, &amp;MainWindow::setClientPort);</span><br><span class="line">    <span class="built_in">updateLogStateChange</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_buttonConnect_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_client-&gt;<span class="built_in">state</span>() == QMqttClient::Disconnected) &#123;</span><br><span class="line">        ui-&gt;lineEditHost-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);</span><br><span class="line">        ui-&gt;spinBoxPort-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);</span><br><span class="line">        ui-&gt;buttonConnect-&gt;<span class="built_in">setText</span>(<span class="built_in">tr</span>(<span class="string">&quot;Disconnect&quot;</span>));</span><br><span class="line">        m_client-&gt;<span class="built_in">connectToHost</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ui-&gt;lineEditHost-&gt;<span class="built_in">setEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        ui-&gt;spinBoxPort-&gt;<span class="built_in">setEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        ui-&gt;buttonConnect-&gt;<span class="built_in">setText</span>(<span class="built_in">tr</span>(<span class="string">&quot;Connect&quot;</span>));</span><br><span class="line">        m_client-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_buttonQuit_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QApplication::<span class="built_in">quit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::updateLogStateChange</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> QString content = QDateTime::<span class="built_in">currentDateTime</span>().<span class="built_in">toString</span>()</span><br><span class="line">                    + <span class="built_in">QLatin1String</span>(<span class="string">&quot;: State Change&quot;</span>)</span><br><span class="line">                    + QString::<span class="built_in">number</span>(m_client-&gt;<span class="built_in">state</span>())</span><br><span class="line">                    + <span class="built_in">QLatin1Char</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    ui-&gt;editLog-&gt;<span class="built_in">insertPlainText</span>(content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::brokerDisconnected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;lineEditHost-&gt;<span class="built_in">setEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">    ui-&gt;spinBoxPort-&gt;<span class="built_in">setEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">    ui-&gt;buttonConnect-&gt;<span class="built_in">setText</span>(<span class="built_in">tr</span>(<span class="string">&quot;Connect&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::setClientPort</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_client-&gt;<span class="built_in">setPort</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_buttonPublish_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_client-&gt;<span class="built_in">publish</span>(ui-&gt;lineEditTopic-&gt;<span class="built_in">text</span>(), ui-&gt;lineEditMessage-&gt;<span class="built_in">text</span>().<span class="built_in">toUtf8</span>()) == <span class="number">-1</span>)</span><br><span class="line">        QMessageBox::<span class="built_in">critical</span>(<span class="keyword">this</span>, <span class="built_in">QLatin1String</span>(<span class="string">&quot;Error&quot;</span>), <span class="built_in">QLatin1String</span>(<span class="string">&quot;Could not publish message&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_buttonSubscribe_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> subscription = m_client-&gt;<span class="built_in">subscribe</span>(ui-&gt;lineEditTopic-&gt;<span class="built_in">text</span>());</span><br><span class="line">    <span class="keyword">if</span> (!subscription) &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">critical</span>(<span class="keyword">this</span>, <span class="built_in">QLatin1String</span>(<span class="string">&quot;Error&quot;</span>), <span class="built_in">QLatin1String</span>(<span class="string">&quot;Could not subscribe. Is there a valid connection?&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 ui 文件，先设置为如下进行测试：</p><p><img src="image-20240722222448401.png" alt="image-20240722222448401"></p><p>点击 Connect，点击 Subscribe，然后点击 Publish 运行：</p><p><img src="image-20240722222858919.png" alt="image-20240722222858919"></p><p>State Change2 表示连接成功</p><blockquote><p><a href="https://blog.csdn.net/2301_76250105/article/details/136272584?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-136272584-blog-116145847.235%5Ev43%5Epc_blog_bottom_relevance_base4&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">实现具有mqtt通信功能的qt程序在arm开发板上运行 ，硬件平台是linux arm 开发板imx6ull pro_arm linux mqtt-CSDN博客</a></p><p><a href="https://blog.csdn.net/luoyayun361/article/details/104671603">Qt开发MQTT（一） 之Qt官方Qt MQTT-CSDN博客</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;交叉编译qt-mqtt库&quot;&gt;交叉编译QT-MQTT库&lt;/h1&gt;
&lt;h2 id=&quot;序言&quot;&gt;序言&lt;/h2&gt;
&lt;p&gt;前置条件：需要有交叉编译好的 arm 环境的 qt 工具，本文不涉及。&lt;/p&gt;
&lt;p&gt;交叉编译 qt-mqtt 库在 arm 开发板上运行 mqtt 客户</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/Linux/"/>
    
    
    <category term="Linux" scheme="http://www.obito.top/tags/Linux/"/>
    
    <category term="嵌入式" scheme="http://www.obito.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux-音频驱动</title>
    <link href="http://www.obito.top/2024/07/18/Linux-%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8/"/>
    <id>http://www.obito.top/2024/07/18/Linux-%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8/</id>
    <published>2024-07-18T09:02:31.000Z</published>
    <updated>2024-07-19T12:21:46.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-音频驱动">Linux-音频驱动</h1><h2 id="序言">序言</h2><p>移植了 mplayer 播放器，播放视频时发现没有声音，原来是音频驱动还没移植。100ask 开发板使用到的音频芯片为 WM8690，Linux 内核已经有该驱动文件了，我们仅仅只需要使能驱动和修改设备树。</p><p>音频这一部分对于目前的自己有点困难了，网上齐全的资料也较少，这里最后在开发板上使用 aplay 不能正常播放音频文件，但是使用 mplayer 可以正常播放视频带有音频也能正常单独播放音频，倒也是解决了目前的需求，后续有能力再回头看能不能解决 aplay 的问题。</p><h2 id="环境">环境</h2><h3 id="硬件环境">硬件环境</h3><ul><li><strong>开发板型号</strong>： <a href="https://blog.csdn.net/thisway_diy/article/details/109841372">100ask_imx6ull_pro 开发板</a></li><li><strong>处理器类型</strong>：NXP IMX6ULL</li><li>**处理器架构：**恩单核 Cortex-A7</li><li>**处理器主频：**800MHZ</li><li><strong>内存容量</strong>：512 MB DDR3</li><li><strong>存储介质</strong>：4GB eMMC</li><li><strong>本次测试的驱动</strong>：音频芯片 WM8690</li></ul><h3 id="软件环境">软件环境</h3><ul><li>宿主机<ul><li><strong>宿主机操作系统</strong>：Ubuntu 18.04</li><li><strong>交叉编译器</strong>：100ask 提供的工具链 arm-buildroot-linux-gnueabihf- <strong>支持的最低内核版本</strong>：4.9.0</li></ul></li><li>开发板<ul><li><strong>U-Boot</strong>：一开始用的 NXP 官方提供的版本但不能正常启动内核，后改为 100ask 提供的版本</li><li><strong>内核版本</strong>： <a href="https://github.com/nxp-imx/linux-imx/tree/imx_4.9.88_2.0.0_ga">NXP 提供的 4.9.88 版本</a></li><li><strong>根文件系统类型</strong>：<a href="https://busybox.net/downloads/">BusyBox 1.29.0</a></li></ul></li><li>音频相关软件<ul><li><strong>ALSA 库版本</strong>：1.0.29 版本</li><li><strong>ALSA-Utils 版本</strong>：1.0.29 版本</li><li><strong>音频播放器</strong>：mplayer 1.1 版本</li></ul></li></ul><h2 id="音频接口简介">音频接口简介</h2><h2 id="移植音频驱动">移植音频驱动</h2><p>只需要修改设备树和使能内核音频驱动即可。</p><h3 id="修改设备树">修改设备树</h3><h4 id="i2c-接口">I2C 接口</h4><p>i2c2 接口添加子节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c2 &#123;</span><br><span class="line">clock_frequency = &lt;100000&gt;;</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_i2c2&gt;;</span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line"></span><br><span class="line">codec: wm8960@1a &#123;</span><br><span class="line">compatible = &quot;wlf,wm8960&quot;;</span><br><span class="line">reg = &lt;0x1a&gt;;</span><br><span class="line">clocks = &lt;&amp;clks IMX6UL_CLK_SAI2&gt;;</span><br><span class="line">clock-names = &quot;mclk&quot;;</span><br><span class="line">wlf,shared-lrclk;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="sai-接口">SAI 接口</h4><p>sai2 节点添加一些属性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&amp;sai2 &#123;</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_sai2</span><br><span class="line">     &amp;pinctrl_sai2_hp_det_b&gt;;</span><br><span class="line"></span><br><span class="line">assigned-clocks = &lt;&amp;clks IMX6UL_CLK_SAI2_SEL&gt;,</span><br><span class="line">  &lt;&amp;clks IMX6UL_CLK_SAI2&gt;;</span><br><span class="line">assigned-clock-parents = &lt;&amp;clks IMX6UL_CLK_PLL4_AUDIO_DIV&gt;;</span><br><span class="line">assigned-clock-rates = &lt;0&gt;, &lt;12288000&gt;;</span><br><span class="line"></span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sai2 接口的 IO 配置：<code>pinctrl_sai2</code> 和 <code>pinctrl_sai2_hp_det_b</code>：</p><p><code>iomuxc</code> 节点下的 <code>imx6u-evk</code> 子节点添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_sai2: sai2grp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_JTAG_TDI__SAI2_TX_BCLK0x17088</span><br><span class="line">MX6UL_PAD_JTAG_TDO__SAI2_TX_SYNC0x17088</span><br><span class="line">MX6UL_PAD_JTAG_TRST_B__SAI2_TX_DATA0x11088</span><br><span class="line">MX6UL_PAD_JTAG_TCK__SAI2_RX_DATA0x11088</span><br><span class="line">MX6UL_PAD_JTAG_TMS__SAI2_MCLK0x17088</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>iomuxc_snvs</code> 节点添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_sai2_hp_det_b: sai2_hp_det_grp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6ULL_PAD_SNVS_TAMPER4__GPIO5_IO04   0x17059</span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>pinctrl_sai2_hp_det_b</code> 描述的是耳机插入检测引脚，wm8960 支持耳机插入检测，当耳机插入就通过耳机输出音频，无耳机时通过喇叭播放音乐。</li></ul><p><em><strong>PS：100ask 开发板添加该引脚会报错，查看设备树也没有其他节点用到该引脚，具体原因不知，于是把该节点移除可正常工作，不影响后续操作。</strong></em></p><h4 id="sound-节点">sound 节点</h4><p>根节点 <code>\</code> 下添加节点 <code>sound</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">sound &#123;</span><br><span class="line">compatible = &quot;fsl,imx6ul-evk-wm8960&quot;,</span><br><span class="line">   &quot;fsl,imx-audio-wm8960&quot;;</span><br><span class="line">model = &quot;wm8960-audio&quot;;</span><br><span class="line">cpu-dai = &lt;&amp;sai2&gt;;</span><br><span class="line">audio-codec = &lt;&amp;codec&gt;;</span><br><span class="line">asrc-controller = &lt;&amp;asrc&gt;;</span><br><span class="line">codec-master;</span><br><span class="line">gpr = &lt;&amp;gpr 4 0x100000 0x100000&gt;;</span><br><span class="line">/*</span><br><span class="line">         * hp-det = &lt;hp-det-pin hp-det-polarity&gt;;</span><br><span class="line"> * hp-det-pin: JD1 JD2  or JD3</span><br><span class="line"> * hp-det-polarity = 0: hp detect high for headphone</span><br><span class="line"> * hp-det-polarity = 1: hp detect high for speaker</span><br><span class="line"> */</span><br><span class="line">hp-det = &lt;3 0&gt;;</span><br><span class="line">// hp-det-gpios = &lt;&amp;gpio5 4 0&gt;;</span><br><span class="line">// mic-det-gpios = &lt;&amp;gpio5 4 0&gt;;</span><br><span class="line">audio-routing =</span><br><span class="line">&quot;Headphone Jack&quot;, &quot;HP_L&quot;,</span><br><span class="line">&quot;Headphone Jack&quot;, &quot;HP_R&quot;,</span><br><span class="line">&quot;Ext Spk&quot;, &quot;SPK_LP&quot;,</span><br><span class="line">&quot;Ext Spk&quot;, &quot;SPK_LN&quot;,</span><br><span class="line">&quot;Ext Spk&quot;, &quot;SPK_RP&quot;,</span><br><span class="line">&quot;Ext Spk&quot;, &quot;SPK_RN&quot;,</span><br><span class="line">&quot;LINPUT2&quot;, &quot;Mic Jack&quot;,</span><br><span class="line">&quot;LINPUT3&quot;, &quot;Mic Jack&quot;,</span><br><span class="line">&quot;RINPUT1&quot;, &quot;Main MIC&quot;,</span><br><span class="line">&quot;RINPUT2&quot;, &quot;Main MIC&quot;,</span><br><span class="line">&quot;Mic Jack&quot;, &quot;MICB&quot;,</span><br><span class="line">&quot;Main MIC&quot;, &quot;MICB&quot;,</span><br><span class="line">&quot;CPU-Playback&quot;, &quot;ASRC-Playback&quot;,</span><br><span class="line">&quot;Playback&quot;, &quot;CPU-Playback&quot;,</span><br><span class="line">&quot;ASRC-Capture&quot;, &quot;CPU-Capture&quot;,</span><br><span class="line">&quot;CPU-Capture&quot;, &quot;Capture&quot;;</span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="内核使能驱动">内核使能驱动</h3><p>设备树配置完成以后就可以使能内核自带的 WM8960 驱动，一般是默认打开的这里检查一下，打开 linux 内核的图形化配置界面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>确保这两项 <code>OSS Mixer API</code> 和 <code>OSS PCM (digital audio) API</code> 不选择。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Device Drivers</span></span><br><span class="line">    -&gt; Sound card support (SOUND [=y])</span><br><span class="line">        -&gt; Advanced Linux Sound Architecture (SND [=y])</span><br><span class="line">            -&gt; &lt;&gt; OSS Mixer API //不选择</span><br><span class="line">            -&gt; &lt;&gt; OSS PCM (digital audio) API //不选择</span><br></pre></td></tr></table></figure><p><img src="image-20240718211018169.png" alt="image-20240718211018169"></p><p>使能 WM8690 驱动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Device Drivers</span></span><br><span class="line">    -&gt; Sound card support (SOUND [=y])</span><br><span class="line">        -&gt; Advanced Linux Sound Architecture (SND [=y])</span><br><span class="line">            -&gt; ALSA for SoC audio support (SND_SOC [=y])</span><br><span class="line">                -&gt; SoC Audio for Freescale CPUs</span><br><span class="line">                    -&gt; &lt;*&gt; Asynchronous Sample Rate Converter (ASRC) module support //选中</span><br><span class="line">                    -&gt; &lt;*&gt; SoC Audio support for i.MX boards with wm8960 //选中</span><br></pre></td></tr></table></figure><p><img src="image-20240719165711761.png" alt="image-20240719165711761"></p><p>编译使用新的内核启动开发板启动过程提示：在 ALSA 设备列表中就会找到 <code>wm8960-audio</code> 这个声卡，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALSA device list:</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">0: wm8960-audio</span></span><br></pre></td></tr></table></figure><p>查看一下 <code>/dev/snd</code> 目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[@obito:/]# ls /dev/snd/</span><br><span class="line">controlC0  pcmC0D0c   pcmC0D0p   pcmC0D1c   pcmC0D1p   timer</span><br></pre></td></tr></table></figure><ul><li>controlC0：用于声卡控制，C0 表示声卡 0。</li><li>pcmC0D0c 和 pcmC0D1c：用于<strong>录音</strong>的 pcm 设备，其中的“COD0”和“C0D1”分别表示声卡 0 中的设备 0 和设备 1，最后面的“c”是 capture 的缩写，表示录音。</li><li>pcmC0D0p 和 pcmC0D1p：用于<strong>播放</strong>的pcm 设备，其中的“COD0”和“C0D1”分别表示声卡 0 中的设备 0 和设备 1，最后面的“p”是 playback 的缩写，表示放音。</li><li>timer：定时器。</li></ul><h2 id="交叉编译-alsa">交叉编译 alsa</h2><p>这个库交叉编译 mplayer 时已经交叉编译好了，所以这里直接交叉编译 alsa-utils。</p><h2 id="交叉编译-alsa-utils">交叉编译 alsa-utils</h2><p><strong>由于开发板上的声卡配置默认是关闭的，所以需要使用 <code>alsa-utils</code> 工具集来设置声卡配置。</strong></p><p>alsa-utils 是用来操作 alsa 框架音频的工具集，因此得先交叉编译 alsa 库。</p><p>下载地址：下载版本最好与 alsa 库版本相同，否则可能提示版本不符合的错误</p><blockquote><p><a href="https://github.com/alsa-project/alsa-utils/tree/v1.0.29">https://github.com/alsa-project/alsa-utils/tree/v1.0.29</a></p></blockquote><p>解压完文件结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router2@ubuntu:~/third_lib/alsa-utils-1.2.2$ ls</span><br><span class="line">acinclude.m4  alsamixer  axfer         gitcompile  Makefile.am   TODO</span><br><span class="line">alsaconf      alsaucm    bat           iecset      po            topology</span><br><span class="line">alsactl       amidi      ChangeLog     include     README.md     utils</span><br><span class="line">alsa-info     amixer     configure.ac  INSTALL     seq</span><br><span class="line">alsaloop      aplay      COPYING       m4          speaker-test</span><br></pre></td></tr></table></figure><p>执行 <code>aclocal</code> 命令，提示 <code>warning: macro 'AM_PATH_ALSA' not found in library</code>，这是因为没把交叉编译 alsa 生成的 m4 文件放到系统目录。为了不与宿主机 x86 结构相混乱，<strong>添加 -I 选项添加额外的搜索目录</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">router2@ubuntu:~/third_lib/alsa-utils-1.2.2$ aclocal </span><br><span class="line">configure.ac:22: warning: macro &#x27;AM_PATH_ALSA&#x27; not found in library</span><br><span class="line">router2@ubuntu:~/third_lib/alsa-utils-1.2.2$ ls</span><br><span class="line">acinclude.m4  alsamixer       axfer         iecset       README.md</span><br><span class="line">aclocal.m4    alsaucm         bat           include      seq</span><br><span class="line">alsaconf      amidi           ChangeLog     INSTALL      speaker-test</span><br><span class="line">alsactl       amixer          configure.ac  m4           TODO</span><br><span class="line">alsa-info     aplay           COPYING       Makefile.am  topology</span><br><span class="line">alsaloop      autom4te.cache  gitcompile    po           utils</span><br></pre></td></tr></table></figure><p>添加 aclocal 搜索路径，前面交叉编译好的 alsa 库中的 .m4 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aclocal -I /home/router2/third_lib/tmp/arm-libalsa-1.0.29/share/aclocal</span><br></pre></td></tr></table></figure><p>这个目录是交叉编译 alsa 库生成的，里面有 <code>alsa.m4</code> 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router2@ubuntu:~/third_lib/tmp/arm-libalsa-1.0.29$ ls share/aclocal/</span><br><span class="line">alsa.m4</span><br></pre></td></tr></table></figure><p>gettextize 初始化 GNU gettext 支持，用于多语言支持：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gettextize </span><br></pre></td></tr></table></figure><p>autoheader 生成 <code>config.h.in</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoheader</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">configure.ac:356: error: `po/Makefile.in&#x27; is already registered with AC_CONFIG_FILES.</span><br><span class="line">../../lib/autoconf/status.m4:288: AC_CONFIG_FILES is expanded from...</span><br><span class="line">configure.ac:356: the top level</span><br><span class="line">autom4te: /usr/bin/m4 failed with exit status: 1</span><br><span class="line">autoheader: &#x27;/usr/bin/autom4te&#x27; failed with exit status: 1</span><br></pre></td></tr></table></figure><p>查看 <code>configure.ac</code> 文件发现 <code>AC_OUTPUT</code> 出现了两次 <code>po/Makefile.in </code>，删除其中一个即可。这一个错误找了将近 2 个小时，搜索网上的资料也都未找到合适的解决方法。</p><p><img src="image-20240719003003493.png" alt="image-20240719003003493"></p><p>删除后再次执行 autoheader 成功，执行 autoconf 生成 <code>configure</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoconf</span><br></pre></td></tr></table></figure><p>执行 <code>automake</code> 命令生成 <code>Makefile.in</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">automake --foreign --copy --add-missing</span><br></pre></td></tr></table></figure><p>之后就可以执行 configure 脚本文件生成 Makefile 文件了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --host=arm-buildroot-linux-gnueabihf --prefix=/home/router2/third_lib/tmp/alsa-utils --with-alsa-inc-prefix=/home/router2/third_lib/tmp/arm-libalsa-1.0.29/include/ --with-alsaprefix=/home/router2/third_lib/tmp/arm-libalsa-1.0.29/lib/ --disable-alsamixer --disable-xmlto</span><br></pre></td></tr></table></figure><p>最后执行 make 和 make install 也没出现什么问题了，make install 需要 sudo 加权限否则会报错。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>移植在开发板测试时出现以下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALSA lib conf.c:3512:(snd_config_hook_load) cannot stat file/directory /home/router2/third_lib/tmp/arm-libalsa-1.0.29/share/alsa/cards/aliases.conf</span><br><span class="line">ALSA lib pcm.c:2267:(snd_pcm_open_noupdate) Unknown PCM cards.pcm.default</span><br><span class="line">aplay: main:722: audio open error: No such file or directory</span><br></pre></td></tr></table></figure><p>后查资料发现是由于前面交叉编译 <code>alsa</code> 时未正常设置配置文件出现的错误，因此需要重新交叉编译 <code>alsa</code> 配置时加上 <code>--with-configdir=/usr/share/arm-alsa</code> ，配置文件也放在开发板的此路径即可。</p><h3 id="声卡设置与测试">声卡设置与测试</h3><p>alsa-utils 自带了 amixer 这个声卡设置工具，amixer 软件命令分为两组，scontrols、scontents、sset 和 sget 为一组。controls、contents、cset 和 cget 为另一组，带 s 的是简化版。</p><h4 id="简单使用方法">简单使用方法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 查看amixer 帮助信息</span><br><span class="line">amixer --help</span><br><span class="line"></span><br><span class="line">// 查看所有设置项</span><br><span class="line">amixer scontrols</span><br><span class="line"></span><br><span class="line">// 查看所有设置项</span><br><span class="line">amixer controls</span><br><span class="line"></span><br><span class="line">// 查看设置值</span><br><span class="line">amixer scontents</span><br><span class="line"></span><br><span class="line">// 设置声卡</span><br><span class="line">amixer sset 设置项目 设置值</span><br><span class="line">amixer cset 设置项目 设置值</span><br><span class="line"></span><br><span class="line">// 获取声卡设置值</span><br><span class="line">amixer sget 设置项目</span><br><span class="line">amixer cget 设置项目</span><br></pre></td></tr></table></figure><h4 id="音乐播放测试">音乐播放测试</h4><p>由于 100ask 开发板没有板载喇叭但有预留接口，所以不能直接直接外放，需要<strong>插入有线耳机或者插上喇叭接口</strong>。</p><p>设置声卡，打开耳机和喇叭，并且设置其音量，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">amixer sset Headphone 100,100</span><br><span class="line">amixer sset Speaker 120,120</span><br><span class="line">amixer sset &#x27;Right Output Mixer PCM&#x27; on</span><br><span class="line">amixer sset &#x27;Left Output Mixer PCM&#x27; on</span><br></pre></td></tr></table></figure><p>使用 aplay 软件播放 wav 格式音乐</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aplay test.wav</span><br></pre></td></tr></table></figure><p>提示错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aplay: set_params:1305: Can&#x27;t use period equal to buffer size (0 == 0)</span><br></pre></td></tr></table></figure><p>根据下方博客提供方法重新编译 alsa-lib，仍无法解决：</p><blockquote><p><a href="https://blog.csdn.net/zmlovelx/article/details/105091875">播放时alsa出错Can’t use period equal to buffer size (0 == 0)_signed 16 bit little endian, rate 44100 hz, stereo-CSDN博客</a></p></blockquote><p>问题待解决。</p><h4 id="设置声卡配置文件：">设置声卡配置文件：</h4><p>使用正点原子提供的声卡配置文件：写入脚本文件执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">正点原子@ALIENTEK</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置捕获的音量</span></span><br><span class="line">amixer cset name=&#x27;Capture Volume&#x27; 90,90</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">PCM</span></span><br><span class="line">amixer sset &#x27;PCM Playback&#x27; on</span><br><span class="line">amixer sset &#x27;Playback&#x27; 256</span><br><span class="line">amixer sset &#x27;Right Output Mixer PCM&#x27; on</span><br><span class="line">amixer sset &#x27;Left Output Mixer PCM&#x27; on</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ADC PCM</span></span><br><span class="line">amixer sset &#x27;ADC PCM&#x27; 200</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">耳机/喇叭（扬声器）设置播放音量，直流/交流</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Turn on Headphone</span></span><br><span class="line">amixer sset &#x27;Headphone Playback ZC&#x27; on</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Set the volume of your headphones(98% volume，127 is the MaxVolume)</span></span><br><span class="line">amixer sset Headphone 125,125</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Turn on the speaker</span></span><br><span class="line">amixer sset &#x27;Speaker Playback ZC&#x27; on</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Set the volume of your Speaker(98% volume，127 is the MaxVolume)</span></span><br><span class="line">amixer sset Speaker 125,125</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Set the volume of your Speaker AC(80% volume，100 is the MaxVolume)</span></span><br><span class="line">amixer sset &#x27;Speaker AC&#x27; 4</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Set the volume of your Speaker AC(80% volume，5 is the MaxVolume)</span></span><br><span class="line">amixer sset &#x27;Speaker DC&#x27; 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">音频输入，左声道管理</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Turn on Left Input Mixer Boost</span></span><br><span class="line">amixer sset &#x27;Left Input Mixer Boost&#x27; off</span><br><span class="line">amixer sset &#x27;Left Boost Mixer LINPUT1&#x27; off</span><br><span class="line">amixer sset &#x27;Left Input Boost Mixer LINPUT1&#x27; 0</span><br><span class="line">amixer sset &#x27;Left Boost Mixer LINPUT2&#x27; off</span><br><span class="line">amixer sset &#x27;Left Input Boost Mixer LINPUT2&#x27; 0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Turn off Left Boost Mixer LINPUT3</span></span><br><span class="line">amixer sset &#x27;Left Boost Mixer LINPUT3&#x27; off</span><br><span class="line">amixer sset &#x27;Left Input Boost Mixer LINPUT3&#x27; 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">音频输入，右声道管理，全部关闭</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Turn on Right Input Mixer Boost</span></span><br><span class="line">amixer sset &#x27;Right Input Mixer Boost&#x27; on</span><br><span class="line">amixer sset &#x27;Right Boost Mixer RINPUT1&#x27; off</span><br><span class="line">amixer sset &#x27;Right Input Boost Mixer RINPUT2&#x27; 0</span><br><span class="line">amixer sset &#x27;Right Boost Mixer RINPUT2&#x27; on</span><br><span class="line">amixer sset &#x27;Right Input Boost Mixer RINPUT2&#x27; 127</span><br><span class="line">amixer sset &#x27;Right Boost Mixer RINPUT3&#x27; off</span><br><span class="line">amixer sset &#x27;Right Input Boost Mixer RINPUT3&#x27; 0</span><br></pre></td></tr></table></figure><h4 id="使用-arecord-录制音频">使用 arecord 录制音频</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arecord -f cd -d 10 record.wav</span><br></pre></td></tr></table></figure><p>刷屏提示错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[@obito:/music]# arecord -f cd -d 10 record.wav</span><br><span class="line">Recording WAVE &#x27;record.wav&#x27; : Signed 16 bit Little Endian, Rate 44100 Hz, Stereo</span><br><span class="line">overrun!!! (at least 3.360 ms long)</span><br><span class="line">overrun!!! (at least 3.064 ms long)</span><br><span class="line">overrun!!! (at least 2.956 ms long)</span><br><span class="line">overrun!!! (at least 3.157 ms long)</span><br><span class="line">overrun!!! (at least 2.959 ms long)</span><br><span class="line">overrun!!! (at least 3.087 ms long)</span><br><span class="line">overrun!!! (at least 2.956 ms long)</span><br><span class="line">overrun!!! (at least 2.950 ms long)</span><br><span class="line">overrun!!! (at least 3.026 ms long)</span><br></pre></td></tr></table></figure><p>问题待解决。</p><h4 id="再次测试-mplayer">再次测试 mplayer</h4><p>使用 mplayer 能够正常播放音频和视频，视频输出画面和音频都正常。</p><h4 id="保存声卡配置文件">保存声卡配置文件</h4><p>使用 <code>alsa-utils</code> 工具集中的 <code>alsactl</code> 工具保存声卡配置，默认保存在 <code>/var/lib/alsa</code> 目录下，先创建该目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/lib/alsa -p</span><br></pre></td></tr></table></figure><p>保存声卡配置提示错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[@obito:/music]# alsactl -f /var/lib/alsa/asound.state store</span><br><span class="line">alsactl: state_lock:125: file /var/lib/alsa/asound.state lock error: No such file or directory</span><br></pre></td></tr></table></figure><p>查询资料得知是：制作根文件系统的时候没有 <code>/var/lock</code> 的目录，alsactl 默认会在 <code>/var/lock</code> 目录操作，所以就会失败。</p><blockquote><p><a href="https://blog.csdn.net/JasonTD/article/details/131927546">alsactl: state_lock:125: file /var/lib/alsa/asound.state lock error: No such file or directory_asound.state.lock-CSDN博客</a></p></blockquote><p>新建目录重新保存成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /var/lock</span><br><span class="line">alsactl -f /var/lib/alsa/asound.state store</span><br></pre></td></tr></table></figure><p>以后就可以使用以下命令进行恢复声卡配置了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alsactl -f /var/lib/alsa/asound.state restore</span><br></pre></td></tr></table></figure><p>为了开机自动设置声卡，将其写入 <code>/etc/init.d/rcS</code> 文件中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ -f &quot;/var/lib/alsa/asound.state&quot; ]; then</span><br><span class="line">    echo &quot;ALSA: Restoring mixer setting......&quot;</span><br><span class="line">    /sbin/alsactl -f /var/lib/alsa/asound.state restore &amp;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>先判断文件是否存在，再进行恢复。</p><h2 id="总结">总结</h2><p>移植 WM8690 驱动成功，aplay 和 arecord 问题待解决，mplayer 能够正常使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux-音频驱动&quot;&gt;Linux-音频驱动&lt;/h1&gt;
&lt;h2 id=&quot;序言&quot;&gt;序言&lt;/h2&gt;
&lt;p&gt;移植了 mplayer 播放器，播放视频时发现没有声音，原来是音频驱动还没移植。100ask 开发板使用到的音频芯片为 WM8690，Linux 内核已经有该驱动</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/Linux/"/>
    
    
    <category term="Linux" scheme="http://www.obito.top/tags/Linux/"/>
    
    <category term="嵌入式" scheme="http://www.obito.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>autotools自动生成Makefile</title>
    <link href="http://www.obito.top/2024/07/18/autotools%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90Makefile/"/>
    <id>http://www.obito.top/2024/07/18/autotools%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90Makefile/</id>
    <published>2024-07-18T08:20:22.000Z</published>
    <updated>2024-07-18T08:27:11.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="autotools-自动生成-makefile">autotools 自动生成 Makefile</h1><p>Makefile 可以大大提高编译程序的效率，手写 Makefile 也比较麻烦，所以比较大的项目都是使用 autotools 工具来自动生成 Makefile。</p><p>流程大致如下：</p><p><img src="20150708225200452.jpeg" alt="img"></p><blockquote><p><a href="https://blog.csdn.net/initphp/article/details/7692923">Linux c 开发 - Makefile工具-CSDN博客</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/weixin_38233274/article/details/80077707">Linux中使用autotools自动生成Makefile_automake --add-missing automake: warnings are trea-CSDN博客</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/weixin_42050875/article/details/97113411">automake—configure.in/configure.am和makefile.am编写-CSDN博客</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;autotools-自动生成-makefile&quot;&gt;autotools 自动生成 Makefile&lt;/h1&gt;
&lt;p&gt;Makefile 可以大大提高编译程序的效率，手写 Makefile 也比较麻烦，所以比较大的项目都是使用 autotools 工具来自动生成 Mak</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>IMX6ULL-交叉编译Mplayer</title>
    <link href="http://www.obito.top/2024/07/17/IMX6ULL-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91Mplayer/"/>
    <id>http://www.obito.top/2024/07/17/IMX6ULL-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91Mplayer/</id>
    <published>2024-07-17T05:45:12.000Z</published>
    <updated>2024-07-22T12:12:40.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="imx6ull-交叉编译mplayer">IMX6ULL-交叉编译Mplayer</h1><h2 id="环境">环境</h2><h3 id="硬件环境">硬件环境</h3><ul><li><strong>开发板型号</strong>： <a href="https://blog.csdn.net/thisway_diy/article/details/109841372">100ask_imx6ull_pro 开发板</a></li><li><strong>处理器类型</strong>：NXP IMX6ULL</li><li>**处理器架构：**恩单核 Cortex-A7</li><li>**处理器主频：**800MHZ</li><li><strong>内存容量</strong>：512 MB DDR3</li><li><strong>存储介质</strong>：4GB eMMC</li></ul><h3 id="软件环境">软件环境</h3><ul><li>宿主机<ul><li><strong>宿主机操作系统</strong>：Ubuntu 18.04</li><li><strong>交叉编译器</strong>：100ask 提供的工具链 arm-buildroot-linux-gnueabihf- <strong>支持的最低内核版本</strong>：4.9.0</li></ul></li><li>开发板<ul><li>**U-Boot：**一开始用的 NXP 官方提供的版本但不能正常启动内核，后改为 100ask 提供的版本</li><li><strong>内核版本</strong>： <a href="https://github.com/nxp-imx/linux-imx/tree/imx_4.9.88_2.0.0_ga">NXP 提供的 4.9.88 版本</a></li><li><strong>根文件系统类型</strong>：<a href="https://busybox.net/downloads/">BusyBox 1.29.0</a></li></ul></li></ul><h2 id="编译过程">编译过程</h2><p>mplayer 依赖 alsa 库（音频）和 libmad 库（对 MP3 进行解码），所以先交叉编译 mplayer 和 libmad，</p><h3 id="交叉编译-libmad">交叉编译 libmad</h3><p>libmad 是一个开源的 MP3 解码库，mplayer 使用 libmad 进行对 MP3 的支持。</p><p>下载地址：</p><blockquote><p><a href="https://github.com/sezero/libmad/tags">Tags · sezero/libmad (github.com)</a></p></blockquote><p>解压压缩包有以下文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">acconfig.h    CREDITS    global.h       layer3.c      stamp-h.in  VERSION</span><br><span class="line">bit.c         D.dat      huffman.c      layer3.h      stream.c    version.c</span><br><span class="line">bit.h         decoder.c  huffman.h      mad.h.sed     stream.h    version.h</span><br><span class="line">CHANGES       decoder.h  imdct_l_arm.S  Makefile.am   synth.c</span><br><span class="line">config.h.in   fixed.c    imdct_s.dat    qc_table.dat  synth.h</span><br><span class="line">configure.in  fixed.h    INSTALL        README        timer.c</span><br><span class="line">COPYING       frame.c    layer12.c      rq_table.dat  timer.h</span><br><span class="line">COPYRIGHT     frame.h    layer12.h      sf_table.dat  TODO</span><br></pre></td></tr></table></figure><p>可见有 <a href="http://configure.in">configure.in</a> 和 <a href="http://Makefile.am">Makefile.am</a> 文件，我们需要生成 configure 和 <a href="http://Makefile.in">Makefile.in</a> 文件才能生成 Makefile。</p><p>执行 <code>aclocal</code> ，生成 <code>aclocal.m4</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aclocal</span><br></pre></td></tr></table></figure><p>执行 <code>autoconf</code>， 生成 <code>configure</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoconf</span><br></pre></td></tr></table></figure><p>执行 <code>libtoolize</code>，生成<code>ltmain.sh</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libtoolize</span><br></pre></td></tr></table></figure><p>执行 <code>autoheader</code> ，生成 <code>config.h.in</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoheader</span><br></pre></td></tr></table></figure><p>执行 <code>automake</code>命令，生成 <code>Makefile.in</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">automake --add-missing</span><br></pre></td></tr></table></figure><p>出现错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">automake: warning: autoconf input should be named &#x27;configure.ac&#x27;, not &#x27;configure.in&#x27;</span><br><span class="line">configure.in:25: warning: AM_INIT_AUTOMAKE: two- and three-arguments forms are deprecated.  For more info, see:</span><br><span class="line">configure.in:25: http://www.gnu.org/software/automake/manual/automake.html#Modernize-AM_005fINIT_005fAUTOMAKE-invocation</span><br><span class="line">Makefile.am:50: warning: &#x27;INCLUDES&#x27; is the old name for &#x27;AM_CPPFLAGS&#x27; (or &#x27;*_CPPFLAGS&#x27;)</span><br><span class="line">Makefile.am: error: required file &#x27;./NEWS&#x27; not found</span><br><span class="line">Makefile.am: error: required file &#x27;./AUTHORS&#x27; not found</span><br><span class="line">Makefile.am: error: required file &#x27;./ChangeLog&#x27; not found</span><br><span class="line">automake: warning: autoconf input should be named &#x27;configure.ac&#x27;, not &#x27;configure.in&#x27;</span><br><span class="line">/usr/share/automake-1.15/am/depend2.am: error: am__fastdepCCAS does not appear in AM_CONDITIONAL</span><br><span class="line">/usr/share/automake-1.15/am/depend2.am:   The usual way to define &#x27;am__fastdepCCAS&#x27; is to add &#x27;AM_PROG_AS&#x27;</span><br><span class="line">/usr/share/automake-1.15/am/depend2.am:   to &#x27;configure.in&#x27; and run &#x27;aclocal&#x27; and &#x27;autoconf&#x27; again</span><br><span class="line">Makefile.am: error: Preprocessed Assembler source seen but &#x27;CCAS&#x27; is undefined</span><br><span class="line">Makefile.am:   The usual way to define &#x27;CCAS&#x27; is to add &#x27;AM_PROG_AS&#x27;</span><br><span class="line">Makefile.am:   to &#x27;configure.in&#x27; and run &#x27;aclocal&#x27; and &#x27;autoconf&#x27; again.</span><br><span class="line">Makefile.am: error: Preprocessed Assembler source seen but &#x27;CCASFLAGS&#x27; is undefined</span><br><span class="line">Makefile.am:   The usual way to define &#x27;CCASFLAGS&#x27; is to add &#x27;AM_PROG_AS&#x27;</span><br><span class="line">Makefile.am:   to &#x27;configure.in&#x27; and run &#x27;aclocal&#x27; and &#x27;autoconf&#x27; again.</span><br></pre></td></tr></table></figure><p>发现有两类错误：一类是缺少文件，一种是宏定义缺失。</p><p>第一类错误：加上选项 <code>--add-missing</code> 会自动生成缺少的文件，但是运行之后没有生成缺少的文件，这时我们再手动创建以下：</p><p>手动创建其他缺少的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch NEWS AUTHORS ChangeLog</span><br></pre></td></tr></table></figure><p>第二类错误：在 <a href="http://configure.in">configure.in</a> 文件中添加 AM_PROG_AS ：</p><p><img src="image-20240717162519222.png" alt="image-20240717162519222"></p><p>添加完重新运行 <code>acloca</code>l 更新 <code>aclocal.m4</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aclocal</span><br></pre></td></tr></table></figure><p>运行 <code>autoconf</code> 更新 <code>configure</code> 脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoconf</span><br></pre></td></tr></table></figure><p>运行 <code>automake</code> 生成 <code>Makefile.in</code> 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">automake --add-missing</span><br></pre></td></tr></table></figure><p>此时所有文件如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">acconfig.h      configure     frame.h        ltmain.sh     stream.h</span><br><span class="line">aclocal.m4      configure.in  global.h       mad.h.sed     synth.c</span><br><span class="line">AUTHORS         COPYING       huffman.c      Makefile.am   synth.h</span><br><span class="line">autom4te.cache  COPYRIGHT     huffman.h      Makefile.in   timer.c</span><br><span class="line">bit.c           CREDITS       imdct_l_arm.S  missing       timer.h</span><br><span class="line">bit.h           D.dat         imdct_s.dat    NEWS          TODO</span><br><span class="line">ChangeLog       decoder.c     INSTALL        qc_table.dat  VERSION</span><br><span class="line">CHANGES         decoder.h     install-sh     README        version.c</span><br><span class="line">compile         depcomp       layer12.c      rq_table.dat  version.h</span><br><span class="line">config.guess    fixed.c       layer12.h      sf_table.dat</span><br><span class="line">config.h.in     fixed.h       layer3.c       stamp-h.in</span><br><span class="line">config.sub      frame.c       layer3.h       stream.c</span><br></pre></td></tr></table></figure><p>执行 configure 脚本文件生成 Makefile 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --host=arm-linux CC=arm-buildroot-linux-gnueabihf-gcc --prefix=/home/router2/third_lib/tmp/arm-libmad-0.14.2b --disable-debugging --enable-static --enable-shared</span><br></pre></td></tr></table></figure><p>make 命令编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure><p>提示错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc: error: unrecognized command line option ‘-fforce-mem’; did you mean ‘-fforce-addr’?</span><br></pre></td></tr></table></figure><p>修改 Makefile 文件，查找 <code>-fforce-mem</code> ，将其删除即可。</p><p>再次编译就能成功了，最后进行 make install 生成目标文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="交叉编译-libalsa">交叉编译 libalsa</h3><p>libalsa 是</p><p>下载地址：</p><blockquote><p><a href="https://github.com/alsa-project/alsa-lib/tags?after=v1.1.1">Tags · alsa-project/alsa-lib (github.com)</a></p></blockquote><p>解压得到以下文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acinclude.m4  ChangeLog     doc         INSTALL      MEMORY-LEAK  src   utils</span><br><span class="line">alsalisp      configure.ac  gitcompile  m4           modules      test</span><br><span class="line">aserver       COPYING       include     Makefile.am  NOTES        TODO</span><br></pre></td></tr></table></figure><p>可见有 <a href="http://configure.ac">configure.ac</a>（跟 <a href="http://configure.in">configure.in</a> 相同，只是 automake 版本不同的原因） 和 <a href="http://Makefile.am">Makefile.am</a> 文件，我们需要生成 configure 和 <a href="http://Makefile.in">Makefile.in</a> 文件才能生成 Makefile。</p><p>执行 <code>aclocal</code> ，生成 <code>aclocal.m4</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aclocal</span><br></pre></td></tr></table></figure><p>执行 <code>autoconf</code>， 生成 <code>configure</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoconf</span><br></pre></td></tr></table></figure><p>执行 <code>libtoolize</code>，生成<code>ltmain.sh</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libtoolize</span><br></pre></td></tr></table></figure><p>执行 <code>autoheader</code> ，生成 <code>config.h.in</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoheader</span><br></pre></td></tr></table></figure><p>执行 <code>automake</code>命令，生成<code>Makefile.in</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">automake --add-missing</span><br></pre></td></tr></table></figure><p>执行 configure 脚本文件生成 Makefile 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --host=arm-linux CC=arm-buildroot-linux-gnueabihf-gcc --prefix=/home/router2/third_lib/tmp/arm-libalsa-1.0.29 --with-configdir=/usr/share/arm-alsa --disable-python --enable-shared</span><br></pre></td></tr></table></figure><p>需要添加 <code>--with-configdir</code> 选项设置 alsa 编译出来的配置文件存放位置，保证 ubuntu 和开发板根文件系统的路径一致。否则移植到开发板时会出现以下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALSA lib conf.c:3512:(snd_config_hook_load) cannot stat file/directory /home/router2/third_lib/tmp/arm-libalsa-1.0.29/share/alsa/cards/aliases.conf</span><br><span class="line">ALSA lib pcm.c:2267:(snd_pcm_open_noupdate) Unknown PCM cards.pcm.default</span><br></pre></td></tr></table></figure><p>最后编译安装即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j8 </span><br><span class="line">make install </span><br></pre></td></tr></table></figure><p>出现该错误：</p><p><img src="image-20240719021112805.png" alt="image-20240719021112805"></p><p>解决方法是切换到切换到 root 用户重新 make install 即可解决。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="交叉编译-mplayer">交叉编译 Mplayer</h3><p>MPlayer是一款开源多媒体播放器，MPlayer基于命令行界面，在各操作系统也可选择安装不同的图形界面。mplaye r的另一个大的特色是广泛的输出设备支持。它可以在 X11、Xv、DGA、OpenGL、SVGAlib、fbdev、AAlib、DirectFB 下工作，我们使用开发板的话，选择使用 fbdev 输出即可。</p><p>下载地址：</p><blockquote><p><a href="http://www.mplayerhq.hu/MPlayer/releases/">Index of /MPlayer/releases (mplayerhq.hu)</a></p></blockquote><p>解压之后有现成的 configure 文件，不用再用 automake 和 autoconf 生成了。</p><p>配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/home/router2/third_lib/tmp/arm-libmplayer-1.1 --cc=arm-buildroot-linux-gnueabihf-gcc --host-cc=gcc --target=arm-linux --disable-mencoder --disable-live --disable-mp3lib --disable-win32dll --disable-dvb --disable-dvdread --disable-dvdnav --disable-dvdread-internal --disable-tv --disable-ivtv --enable-fbdev --disable-sdl --enable-mad --enable-alsa --enable-cross-compile --enable-armv5te --extra-cflags=&quot;-I /home/router2/third_lib/tmp/arm-libalsa-1.0.29/include -I /home/router2/third_lib/tmp/arm-libmad-0.14.2b/include&quot; --extra-ldflags=&quot;-L /home/router2/third_lib/tmp/arm-libalsa-1.0.29/lib -L /home/router2/third_lib/tmp/arm-libmad-0.14.2b/lib&quot; </span><br></pre></td></tr></table></figure><ul><li><code>--host-cc=gcc</code>：指定宿主系统的 C 编译器为 gcc，即目前使用的 Ubuntu 的编译器</li><li><code>--target=arm-linux</code>：指定目标平台为 ARM 架构的 Linux</li><li>这里是 -cc 之前是 CC，这个得看 configure 文件的定义</li><li><code>--extra-cflags</code>  依赖的头文件目录</li><li><code>--extra-ldflags</code>：依赖的库文件目录</li></ul><p>configure 参数的含义可查看 configure 文件，这里的参数添加参考：</p><blockquote><p><a href="https://blog.csdn.net/qq_40792874/article/details/120094678?spm=1001.2014.3001.5502">IMX6ULL-交叉编译Mplayer_imx6ul 交叉编译 mplayer-CSDN博客</a></p></blockquote><p>AI 生成：</p><blockquote><p>您提供的是一系列配置选项，用于编译 MPlayer 时禁用和启用特定的功能。下面是每个选项的简要说明和它们可能的用途：</p><ul><li><code>--disable-mencoder</code>：禁用 MEncoder 的编译，MEncoder 是一个视频编码器。</li><li><code>--disable-live</code>：禁用 LIVE555 Streaming Media 的支持。</li><li><code>--disable-mp3lib</code>：禁用内置的 mp3lib。</li><li><code>--disable-win32dll</code>：禁用 Win32 DLL 支持，这通常用于 Windows 系统。</li><li><code>--disable-dvb</code>：禁用 DVB 视频输出，DVB 是一种数字视频广播标准。</li><li><code>--disable-dvdread</code>：禁用 libdvdread 支持，这是一个用于读取 DVD 的库。</li><li><code>--disable-dvdnav</code>：禁用 libdvdnav 支持，这是一个用于处理 DVD 导航的库。</li><li><code>--disable-dvdread-internal</code>：禁用内部 libdvdread 支持。</li><li><code>--disable-tv</code>：禁用电视接口，包括 TV/DVB grabbers。</li><li><code>--disable-ivtv</code>：禁用 IVTV TV-Out 视频输出。</li><li><code>--enable-fbdev</code>：启用 FBDev 视频输出，这是一个 Linux 帧缓冲设备。</li><li><code>--disable-sdl</code>：禁用 SDL 视频输出，SDL 是一个跨平台的多媒体库。</li><li><code>--cc=arm-none-linux-gnueabi-gcc</code>：指定用于编译的 C 编译器为 ARM 架构的交叉编译器。</li><li><code>--host-cc=gcc</code>：指定宿主系统的 C 编译器为 gcc。</li><li><code>--target=arm-linux</code>：指定目标平台为 ARM 架构的 Linux。</li><li><code>--enable-mad</code>：启用 libmad 支持，这是一个用于解码 MPEG 音频的库。</li><li><code>--enable-alsa</code>：启用 ALSA 音频输出，ALSA 是 Linux 系统中的标准音频系统。</li><li><code>--enable-cross-compile</code>：启用交叉编译，允许在不同平台之间编译软件。</li><li><code>--enable-armv5te</code>：启用 ARMv5TE 支持，ARMv5TE 是 ARM 架构的一个版本，带有 DSP 扩展。</li></ul><p>这些选项表明您可能正在为 ARM 架构的 Linux 系统交叉编译 MPlayer，并根据您的特定需求启用或禁用了某些功能。例如，您可能不需要处理 DVD 或 DVB 内容，但需要支持 ALSA 音频和 MPEG 音频解码。使用这些选项，您可以定制 MPlayer 的构建以适应您的硬件和软件环境。</p></blockquote><p>运行 configure 脚本文件后提示错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error: yasm not found, use --yasm=&#x27;&#x27; if you really want to compile without</span><br><span class="line"></span><br><span class="line">Check &quot;config.log&quot; if you do not understand why it failed.</span><br></pre></td></tr></table></figure><p>查资料说是缺少 yasm 环境，安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install yasm  </span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/head_main/article/details/7787152">mplayer的编译安装_error: yasm not found, use --yasm=’’ if you really-CSDN博客</a></p></blockquote><p>再次运行成功，进行编译安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>出现错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">install -m 755 -s mplayer /home/router2/third_lib/tmp/arm-libmplayer-1.1/bin</span><br><span class="line">strip: Unable to recognise the format of the input file `/home/router2/third_lib/tmp/arm-libmplayer-1.1/bin/mplayer&#x27;</span><br><span class="line">install: strip process terminated abnormally</span><br><span class="line">Makefile:913: recipe for target &#x27;install-mplayer&#x27; failed</span><br><span class="line">make: *** [install-mplayer] Error 1</span><br></pre></td></tr></table></figure><p>需要修改 <code>config.mak</code> 文件，查找 <code>INSTALLSTRIP</code> 将后面的<code> -s</code> 删除，再次编译安装即可成功。</p><p>生成文件如下，<strong>bin 目录有可执行文件 mplayer</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router2@ubuntu:~/third_lib/tmp/arm-libmplayer-1.1$ ls</span><br><span class="line">bin  etc  lib  share</span><br><span class="line">router2@ubuntu:~/third_lib/tmp/arm-libmplayer-1.1$ ls bin/</span><br><span class="line">mplayer</span><br></pre></td></tr></table></figure><p>查看文件属性是否为 arm 架构的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router2@ubuntu:~/third_lib/tmp/arm-libmplayer-1.1$ file bin/mplayer </span><br><span class="line">bin/mplayer: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 4.9.0, with debug_info, not stripped</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/qq_40792874/article/details/120094678?spm=1001.2014.3001.5502">IMX6ULL-交叉编译Mplayer_imx6ul 交叉编译 mplayer-CSDN博客</a></p></blockquote><h2 id="测试">测试</h2><p>将 mad 和 alsa 的 <code>lib</code> 目录下的文件放入开发板的 <code>/usr/lib</code> 目录下</p><p>文件有如下：</p><p><img src="image-20240717172124384.png" alt="image-20240717172124384"></p><p>将 alsa 的生成的配置文件目录 <code>/usr/shar/arm-alsa</code> 放到开发板相同目录下。</p><p><img src="image-20240719161355385.png" alt="image-20240719161355385"></p><p>打开开发板根文件系统中的 <code>/etc/profile</code> 文件添加以下信息指定 alsa 的配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ALSA_CONFIG_PATH=/usr/share/arm-alsa/alsa.conf</span><br></pre></td></tr></table></figure><p>将可执行文件 mplayer 放进开发板的 <code>/bin</code> 目录。</p><p>使用 mplayer 测试能否正常播放：发现只有画面没有声音输出，后发现是没有移植好音频驱动的原因，后面再移植音频驱动。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;imx6ull-交叉编译mplayer&quot;&gt;IMX6ULL-交叉编译Mplayer&lt;/h1&gt;
&lt;h2 id=&quot;环境&quot;&gt;环境&lt;/h2&gt;
&lt;h3 id=&quot;硬件环境&quot;&gt;硬件环境&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;开发板型号&lt;/strong&gt;： &lt;a href=&quot;</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/Linux/"/>
    
    
    <category term="Linux" scheme="http://www.obito.top/tags/Linux/"/>
    
    <category term="嵌入式" scheme="http://www.obito.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>modprobe加载驱动问题</title>
    <link href="http://www.obito.top/2024/07/13/modprobe%E5%8A%A0%E8%BD%BD%E9%A9%B1%E5%8A%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://www.obito.top/2024/07/13/modprobe%E5%8A%A0%E8%BD%BD%E9%A9%B1%E5%8A%A8%E9%97%AE%E9%A2%98/</id>
    <published>2024-07-13T02:55:20.000Z</published>
    <updated>2024-07-13T03:18:43.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="modprobe-加载驱动问题">modprobe 加载驱动问题</h1><p>在 Linux 系统中，驱动加载方式分为两种：<strong>静态加载和动态加载</strong>。静态加载就是把驱动程序放进内核一起编译，系统启动后之间被调用。静态加载的缺点就是调试困难，一般都是驱动程序调试稳定后再将其放进内核一起编译。动态加载是利用 Linux 的 module 特性，可以再系统启动后使用 insmod 命令或 modprobe 命令把驱动程序（.ko 文件）手动添加进内核。</p><h2 id="insmod">insmod</h2><p>insmod 加载模块时，需要指定完整的路径和模块名字，一般是在模块当前路径直接加载。不会自动处理模块的依赖关系，如果当前加载的模块依赖其他模块，则会报错，需要手动加载这些依赖模块。</p><h2 id="modprobe">modprobe</h2><p>modprobe 加载模块时，不需要指定路径，它会到默认目录下例如： <code>/lib/modules/$(uname -r)/</code> 进行查找模块。可以自动加载所需要的依赖模块。</p><p>根文件系统是新的话，可能没有这个默认目录，我们使用 modprobe 加载时会提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/24_gt911 # modprobe gt911.ko</span><br><span class="line">modprobe: can&#x27;t change directory to &#x27;/lib/modules&#x27;: No such file or directory</span><br></pre></td></tr></table></figure><p>创建目录再次运行提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/24_gt911 # mkdir /lib/modules</span><br><span class="line">/24_gt911 # modprobe gt911.ko</span><br><span class="line">modprobe: can&#x27;t change directory to &#x27;4.9.88&#x27;: No such file or directory</span><br></pre></td></tr></table></figure><p>这个目录对应内核的版本，再次创建目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/24_gt911 # mkdir /lib/modules/4.9.88</span><br><span class="line">/24_gt911 # modprobe gt911.ko</span><br><span class="line">modprobe: can&#x27;t open &#x27;modules.dep&#x27;: No such file or directory</span><br></pre></td></tr></table></figure><p>提示找不到 modules.dep 文件，这时不用手动创建该文件，使用 depmod 命令即可自动生成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/24_gt911 # depmod</span><br><span class="line">/24_gt911 # ls /lib/modules/4.9.88/</span><br><span class="line">modules.alias    modules.dep      modules.symbols</span><br></pre></td></tr></table></figure><p>再次加载出现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/24_gt911 # modprobe gt911.ko</span><br><span class="line">modprobe: module gt911.ko not found in modules.dep</span><br></pre></td></tr></table></figure><p>提示 modules.dep 文件中没有找到需要加载的 ko 文件，查看下 modules.dep 的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/24_gt911 # more modules.dep</span><br><span class="line">/24_gt911 # </span><br></pre></td></tr></table></figure><p>modules.dep 内容为空，需要将要加载的 ko 文件复制到 <code>/lib/modules/$(uname -r)/</code> 下，再执行 depmod 命令，depmod 指令会自动分析 <code>/lib/modules/$(uname -r)</code> 目录下的可加载模块，并按照固定的格式填入modules.dep 中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/24_gt911 # cp gt911.ko /lib/modules/4.9.88/</span><br><span class="line">/24_gt911 # depmod</span><br><span class="line">/24_gt911 # more modules.dep</span><br><span class="line">gt911.ko </span><br></pre></td></tr></table></figure><p>modules.dep 中已经有我们需要加载的模块了，最后再次加载模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/24_gt911 # modprobe gt911.ko</span><br><span class="line">gt911 init</span><br><span class="line">gt911_probe</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/qq_39101111/article/details/78773362">modprobe加载驱动问题_modprobe: can’t open ‘modules.dep’: no such file o-CSDN博客</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;modprobe-加载驱动问题&quot;&gt;modprobe 加载驱动问题&lt;/h1&gt;
&lt;p&gt;在 Linux 系统中，驱动加载方式分为两种：&lt;strong&gt;静态加载和动态加载&lt;/strong&gt;。静态加载就是把驱动程序放进内核一起编译，系统启动后之间被调用。静态加载的缺点就是调</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux-触摸屏驱动</title>
    <link href="http://www.obito.top/2024/07/07/Linux-%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8/"/>
    <id>http://www.obito.top/2024/07/07/Linux-%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8/</id>
    <published>2024-07-07T07:37:07.000Z</published>
    <updated>2024-08-23T06:11:32.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-触摸屏驱动">Linux-触摸屏驱动</h1><h2 id="环境">环境</h2><h3 id="硬件环境">硬件环境</h3><ul><li><strong>开发板型号</strong>：<a href="https://blog.csdn.net/thisway_diy/article/details/109841372">100ask_imx6ull_pro 开发板</a></li><li><strong>处理器类型</strong>：NXP IMX6ULL</li><li><strong>处理器架构</strong>：恩单核 Cortex-A7</li><li><strong>处理器主频</strong>：800MHZ</li><li><strong>内存容量</strong>：512 MB DDR3</li><li><strong>存储介质</strong>：4GB eMMC</li><li><strong>本次测试的驱动</strong>：GT911 触摸屏芯片</li></ul><h3 id="软件环境">软件环境</h3><ul><li>宿主机<ul><li><strong>宿主机操作系统</strong>：Ubuntu 18.04</li><li><strong>交叉编译器</strong>：100ask 提供的工具链 arm-buildroot-linux-gnueabihf- <strong>支持的最低内核版本</strong>：4.9.0</li></ul></li><li>开发板<ul><li><strong>U-Boot</strong>：一开始用的 NXP 官方提供的版本但不能正常启动内核，后改为 100ask 提供的版本</li><li><strong>内核版本</strong>： <a href="https://github.com/nxp-imx/linux-imx/tree/imx_4.9.88_2.0.0_ga">NXP 提供的 4.9.88 版本</a></li><li><strong>根文件系统类型</strong>：<a href="https://busybox.net/downloads/">BusyBox 1.29.0</a></li></ul></li></ul><h2 id="序言">序言</h2><p>一开始是电阻触摸屏，但是只能单点触摸，后面推出了电容触摸屏，支持多点触摸，后续的电阻触摸屏也支持多点触摸了，但是电阻屏需要手指给予一定的压力才有反应，而电容屏只需要手指轻触即可。</p><p><strong>工作原理</strong></p><p>电容触摸：电容屏中有一个控制芯片，它会周期性产生驱动信号，接收电极接收到信号，并可测量电荷大小。当电容屏被按下时，由于人体电场，用户和触摸屏表面形成以一个<strong>耦合电容</strong>，对于高频电流来说，电容是直接导体，于是<strong>手指从接触点吸走一个很小的电流</strong>，从而影响了接收电极接收到的电荷大小。主控芯片根据电荷大小即可计算出触点位置。</p><p>电阻触摸：主要是通过<strong>压力感应原理</strong>来实现对屏幕内容的操作和控制的。这种触摸屏屏体部分是一块与显示器表面非常配合的<strong>多层复合薄膜</strong>，轻触表层压下时，接触到底层，控制器同时从四个角读出相称的电流及计算手指位置的距离。</p><p>另外注意区分一下 LCD 和触摸屏，<strong>LCD 是输出设备，触摸屏是输入设备</strong>，一般是将触摸屏制作成跟 LCD 一样的尺寸然后覆盖在 LCD 上。</p><p>Linux 内核一般都有许多触摸屏芯片的驱动，一般只需要根据驱动程序修改设备树，并在内核中使能其驱动就可以使用。这里为了学习触摸屏芯片驱动编写过程，将其他触摸屏芯片的驱动都失能。</p><p>移植第三方库 tslib 库对触摸屏参数进行校正，最后将测试完毕的驱动放进内核并编译，就不用每次都手动加载了。</p><h2 id="触摸屏驱动解析">触摸屏驱动解析</h2><h3 id="多点触摸协议">多点触摸协议</h3><p>老版本的 Linux 内核不支持多点触摸（Multi-touch，简称 MT），MT 协议分为两种类型：Type A 和 Type B。</p><ul><li>Type A：适用于触摸点不能被区分或者追踪，此类型的设备上报原始数据。</li><li>Type B：适用于有硬件追踪并能区分触摸点的触摸设备，此类型设备通过 slot 更新某一个触摸点的信息，一般的多点电容触摸屏 IC 都有此能力。</li></ul><p>触摸点的信息通过一系列的 <strong>ABS_MT 事件</strong>(有的资料也叫消息)上报给 linux 内核，只有 ABS_MT 事件是用于多点触摸的，ABS_MT 事件定义在文件 <code>include/uapi/linux/input-event-codes.h</code> 中，相关事件如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_SLOT0x2f<span class="comment">/* MT slot being modified */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOUCH_MAJOR0x30<span class="comment">/* Major axis of touching ellipse */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOUCH_MINOR0x31<span class="comment">/* Minor axis (omit if circular) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_WIDTH_MAJOR0x32<span class="comment">/* Major axis of approaching ellipse */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_WIDTH_MINOR0x33<span class="comment">/* Minor axis (omit if circular) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_ORIENTATION0x34<span class="comment">/* Ellipse orientation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_POSITION_X0x35<span class="comment">/* Center X touch position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_POSITION_Y0x36<span class="comment">/* Center Y touch position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOOL_TYPE0x37<span class="comment">/* Type of touching device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_BLOB_ID0x38<span class="comment">/* Group a set of packets as a blob */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TRACKING_ID0x39<span class="comment">/* Unique ID of initiated contact */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_PRESSURE0x3a<span class="comment">/* Pressure on contact area */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_DISTANCE0x3b<span class="comment">/* Contact hover distance */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOOL_X0x3c<span class="comment">/* Center X tool position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOOL_Y0x3d<span class="comment">/* Center Y tool position */</span></span></span><br></pre></td></tr></table></figure><p>ABS_MT 事件中常用以下几个：</p><ul><li><p>ABS_MT_SLOT：上报触摸点 ID</p></li><li><p>ABS_MT_POSITION_X：触摸点的 x 坐标信息</p></li><li><p>ABS_MT_POSITION_Y：触摸点的 y 坐标信息</p></li><li><p>BS_MT_TRACKING_ID：区分触摸点</p></li></ul><p>Type A 类型的设备使用 <code>input_mt_sync()</code>函数来<strong>隔离不同的触摸点数据信息</strong>，该函数会触摸 <code>SYN_MT_REPORT</code> 事件，通知接收者获取当前触摸数据，并且准备接收下一个触摸点数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_mt_sync</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br></pre></td></tr></table></figure><p>Type B 类型的设备使用 <code>input_mt_slot</code> 函数上报触摸点信息时<strong>可以区分哪一个触摸点</strong>，会触发 <code>ABS_MT_SLOT</code> 事件，告诉接收者当前正在更新的时哪个触摸点的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_mt_slot</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">int</span> slot)</span></span><br></pre></td></tr></table></figure><p>第一个参数为 input_dev 设备，第二参数 slot <strong>用于指定当前上报的是哪个触摸点信息</strong>。</p><h4 id="触摸点信息上报时序">触摸点信息上报时序</h4><p>触摸点信息上报时序分为两种类型：Type A 和 Type B。</p><ul><li>Type A 设备：<strong>内核驱动需要一次性将触摸屏上的所有触摸点信息全部上报</strong>，每个触摸点的信息在本次上报事件流中的顺序不重要，因为事件的过滤和触摸点跟踪是在内核空间处理的。</li><li>Type B 设备：需要<strong>给每个识别出来的触摸点分配一个 slot</strong>，后面使用这个 slot 来上报触摸点信息。</li></ul><h5 id="type-a-触摸点信息上报时序">Type A 触摸点信息上报时序</h5><p>Type A 类型的设备，发送触摸点信息时序如下（以 2 个触摸点为例）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ABS_MT_POSITION_X x[<span class="number">0</span>]</span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">0</span>]</span><br><span class="line">SYN_MT_REPORT</span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">1</span>]</span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">1</span>]</span><br><span class="line">SYN_MT_REPORT</span><br><span class="line">SYN_REPORT</span><br></pre></td></tr></table></figure><ul><li>ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y 事件是通过 <code>input_report_abs</code> 函数实现来上报触摸点的 x 坐标和 y 坐标数据。</li><li>SYN_MT_REPORT 事件是通过 <code>input_mt_sync</code> 函数实现的。</li><li>SYN_REPORT 事件是通过 <code>input_sync</code> 函数实现的。每上报完一轮触摸点信息就调用一次 <code>input_sync</code> 函数，也就是发送一个 SYN_REPORT 事件</li></ul><h5 id="type-b-触摸点信息上报时序">Type B 触摸点信息上报时序</h5><p>Type B 类型的设备，发送触摸点信息时序如下（以 2 个触摸点为例）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ABS_MT_SLOT <span class="number">0</span></span><br><span class="line">ABS_MT_TRACKING_ID <span class="number">45</span></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">0</span>]</span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">0</span>]</span><br><span class="line">ABS_MT_SLOT <span class="number">1</span></span><br><span class="line">ABS_MT_TRACKING_ID <span class="number">46</span></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">1</span>]</span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">1</span>]</span><br><span class="line">SYN_REPORT</span><br></pre></td></tr></table></figure><ul><li>ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y 事件是通过 <code>input_report_abs</code> 函数实现来上报触摸点的 x 坐标和 y 坐标数据。</li><li>每次上报一个触摸点坐标之前要先使用 <code>input_mt_slot</code> 函数上报当前触摸点 SLOT，触摸点的 SLOT 其实就是触摸点 ID，需要由触摸 IC 提供。</li><li>每个 SLOT 必须关联一个 ABS_MT_TRACKING_ID，通过修改 SLOT 关联的 ABS_MT_TRACKING_ID 来完成对触摸点的添加、替换或删除。具体用到的函数就是 <code>input_mt_report_slot_state</code>，如果是添加一个新的触摸点，那么此函数的第三个参数 <strong>active 要设置为 true</strong>，linux 内核会自动分配一个 ABS_MT_TRACKING_ID 值，不需要用户去指定具体的 ABS_MT_TRACKING_ID 值。</li><li>SYN_REPORT 事件是通过 <code>input_sync</code> 函数实现的。当所有的触摸点坐标都<strong>上传完毕就调用一次</strong> <code>input_sync</code> 函数，也就是发送一个 <strong>SYN_REPORT 事件</strong></li></ul><p>当一个触摸点移除以后，同样需要通过 SLOT 关联的 ABS_MT_TRACKING_ID 事件发送一个 -1 给内核，调用</p><p><code>input_mt_report_slot_state</code> 函数完成，只需将第三个参数 <strong>active 设置为 false</strong> 即可。</p><p>时序如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ABS_MT_TRACKING_ID <span class="number">-1</span></span><br><span class="line">SYN_REPORT</span><br></pre></td></tr></table></figure><h4 id="多点触摸所使用到的-api-函数">多点触摸所使用到的 API 函数</h4><p><code>input_mt_init_slots</code> 函数用于初始化 MT 的输入 slots，编写 MT 驱动的时候必须先调用此函数初始化 slots。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/input-mt.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">input_mt_init_slots</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> num_slots, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br></pre></td></tr></table></figure><ul><li>dev ：MT 设备对应的 input_dev</li><li>num_slots：SLOT 数量，即触摸点的数量</li><li>返回值：0 成功，负值失败</li><li>flags：可设置的 flags 如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_POINTER0x0001<span class="comment">/* pointer device, e.g. trackpad */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_DIRECT0x0002<span class="comment">/* direct device, e.g. touchscreen */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_DROP_UNUSED0x0004<span class="comment">/* drop contacts not seen in frame */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_TRACK0x0008<span class="comment">/* use in-kernel tracking */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_SEMI_MT0x0010<span class="comment">/* semi-mt device, finger count handled manually */</span></span></span><br></pre></td></tr></table></figure><p><code>input_mt_slot</code> 函数用于 Type B 类型，用于产生 ABS_MT_SLOT 事件，告诉内核上报的是哪个触摸点的坐标数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/input/mt.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">input_mt_slot</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">int</span> slot)</span></span><br><span class="line">&#123;</span><br><span class="line">input_event(dev, EV_ABS, ABS_MT_SLOT, slot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>dev ：MT 设备对应的 input_dev</li><li>slot：当前发送的哪个 slot 的坐标信息</li></ul><p><code>input_mt_report_slot_state</code> 函数此函数用于 Type B 类型，用于产生 ABS_MT_TRACKING_ID 和ABS_MT_TOOL_TYPE 事件，ABS_MT_TRACKING_ID 和 ABS_MT_TOOL_TYPE 事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/input-mt.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_mt_report_slot_state</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> tool_type, <span class="type">bool</span> active)</span>;</span><br></pre></td></tr></table></figure><ul><li>dev ：MT 设备对应的 input_dev</li><li>tool_type：触摸类型，MT_TOOL_FINGER(手指) 、MT_TOOL_PEN(笔)或 MT_TOOL_PALM(手掌)</li><li>active：true 为连续触摸，input 子系统内核会自动分配一个 ABS_MT_TRACKING_ID 给 slot。false，触摸点抬起，表示某个触摸点无效了，input 子系统内核会分配一个 -1 给 slot，表示触摸点溢出。</li></ul><p><code>input_report_abs</code> 函数。Type A 和 Type B 类型都使用此函数上报触摸点坐标信息，通过ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y 事件实现 X 和 Y 轴坐标信息上报。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/input.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">input_report_abs</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br></pre></td></tr></table></figure><ul><li>dev ：MT 设备对应的 input_dev。</li><li>code：要上报什么数据，可设置为 ABS_MT_POSITION_X（ x 坐标） 和 ABS_MT_POSITION_Y（ y 坐标）。</li><li>value：坐标的值。</li></ul><p>如果追踪到的触摸点数量多于当前上报的数量，驱动程序使用 BTN_TOOL_TAP 事件来通知用户空间当前追踪到的触摸点总数量，然后调用 input_mt_report_pointer_emulation 函数将 use_count 参数设置为 false。否则的话将 use_count 参数设置为 true，表示当前的触摸点数量(此函数会获取到具体的触摸点数量，不需要用户给出)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/input-mt.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_mt_report_pointer_emulation</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">bool</span> use_count)</span></span><br></pre></td></tr></table></figure><ul><li>dev ：MT 设备对应的 input_dev。</li><li>use_count：true，有效的触摸点数量；flase，追踪到的触摸点数量多于当前上报的数量</li></ul><h2 id="触摸屏驱动编写">触摸屏驱动编写</h2><h3 id="多点电容触摸驱动框架">多点电容触摸驱动框架</h3><p>根据芯片接口和多点电容触摸协议可知会用到以下驱动框架：</p><ul><li>触摸芯片的接口，一般为 I2C 接口，I2C 驱动框架</li><li>linux 一般通过中断上报触摸点信息，中断框架</li><li>多点电容触摸属于 input 子系统，input 子系统框架</li></ul><p>大致流程就是使用 I2C 驱动框架注册 i2c_driver，与设备树中节点进行匹配，匹配成功则对芯片进行初始化、初始化中断、注册 input 设备，当手触摸屏幕时则产生中断，进入中断线程函数读取触摸点数据并通过 input 子系统上报。</p><h3 id="触摸屏芯片-gt911">触摸屏芯片 GT911</h3><p>100ask 开发板用到的触摸屏芯片是 GT911，支持同时识别 5 个触摸点位的实时准确位置，移动轨迹及触摸面积。</p><ul><li>I2C 从设备地址为 0x5D 或 0x14</li><li>寄存器 16 位，寄存器位宽 8 位</li><li>退出中断时需要对 0x814E 寄存器清零，否则会一直触发中断</li><li>当有触摸时，GT911 每个扫描周期均会通过 INT 脚发出脉冲信号，通知主设备读取坐标信息</li><li>中断触发方式：设置寄存器 0x804D，0 为上升沿触发，1 为下降沿触发。</li></ul><p>GT911 接口如下：</p><p><img src="image-20240707222537840.png" alt="image-20240707222537840"></p><p>gt911 芯片上电时序图：0xBA/0xBB 是加上写数据位或读数据位凑成的 8 位地址。</p><p><img src="image-20240708205427060.png" alt="image-20240708205427060"></p><p>特别重要的寄存器：</p><p><img src="image-20240709201125981.png" alt="image-20240709201125981"></p><p>Bit7：buffer status，1 表示坐标已经准备好，主控可以读取，0 表示未就绪，数据无效，当主控读取完坐标后，必须将此标志位或整个寄存器写为 0，否则会一直触发中断。</p><p>Bit3~0：低 4 位，number of touch points，表示有几个触摸点数据。</p><blockquote><p><a href="https://blog.csdn.net/weixin_51226647/article/details/132299679">解决问题：GT911触控芯片，中断引脚初始化后，自动重复的进入中断_gt911一直中断-CSDN博客</a></p></blockquote><h3 id="修改设备树">修改设备树</h3><p>由原理图可知，GT911 芯片用到了 4 个 IO 口：SDA、SCL、复位 IO、中断 IO。</p><p>iomuxc_snvs 节点中添加复位 IO</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* tsc reset pin*/</span><br><span class="line">pinctrl_tsc_reset: tscresetgrp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">              MX6ULL_PAD_SNVS_TAMPER2__GPIO5_IO020x000110A0</span><br><span class="line">                      &gt;;</span><br></pre></td></tr></table></figure><p>iomuxc 节点中添加中断 IO</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* gt911 INT io*/</span><br><span class="line">pinctrl_tsc_int: tscintgrp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_GPIO1_IO05__GPIO1_IO05 0x000010B0</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>iomuxc 节点中添加 I2C2 的 SDA 和 SCL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_i2c2: i2c2grp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_UART5_TX_DATA__I2C2_SCL 0x4001b8b0</span><br><span class="line">MX6UL_PAD_UART5_RX_DATA__I2C2_SDA 0x4001b8b0</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 i2c2 节点下添加 GT911 子节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c2 &#123;</span><br><span class="line">clock_frequency = &lt;100000&gt;;</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_i2c2&gt;;</span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line"></span><br><span class="line">codec: wm8960@1a &#123;</span><br><span class="line">compatible = &quot;wlf,wm8960&quot;;</span><br><span class="line">reg = &lt;0x1a&gt;;</span><br><span class="line">clocks = &lt;&amp;clks IMX6UL_CLK_SAI2&gt;;</span><br><span class="line">clock-names = &quot;mclk&quot;;</span><br><span class="line">wlf,shared-lrclk;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* gt911 */</span><br><span class="line">gt911@5d &#123;</span><br><span class="line">compatible = &quot;goodix,gt911&quot;;</span><br><span class="line">reg = &lt;0x5d&gt;;</span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line">interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">interrupts = &lt;5 IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_tsc_reset </span><br><span class="line"> &amp;pinctrl_tsc_int&gt;;</span><br><span class="line"></span><br><span class="line">reset-gpios = &lt;&amp;gpio5 2 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">irq-gpios = &lt;&amp;gpio1 5 IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="编写多点电容触摸驱动">编写多点电容触摸驱动</h3><p>头文件和 <code>gt911_info</code> 结构体存放 gt911 芯片的配置信息，<code>gt911_dev</code> 结构体用于存放一些重要变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input/mt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gt911_info</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> pid;</span><br><span class="line">    <span class="type">uint16_t</span> max_x, max_y;</span><br><span class="line">    <span class="type">uint16_t</span> version;</span><br><span class="line">    <span class="type">uint8_t</span> vendor_id;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gt911_dev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span>             <span class="comment">/* 设备节点 */</span>   </span><br><span class="line">    <span class="type">int</span> int_pin;                        <span class="comment">/* 中断IO*/</span></span><br><span class="line">    <span class="type">int</span> reset_pin;                      <span class="comment">/* 复位IO*/</span></span><br><span class="line">    <span class="type">int</span> irq_num;                        <span class="comment">/* 中断号 */</span></span><br><span class="line">    <span class="type">void</span> *private_data;                 <span class="comment">/* 私有数据 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gt911_info</span> <span class="title">info</span>;</span>             <span class="comment">/* gt911的信息 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input_dev</span>;</span>        <span class="comment">/* input结构体 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span>;</span>          <span class="comment">/* I2C客户端 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GT911_CTRL_REG         0X8040  <span class="comment">/* GT911控制寄存器         */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GT911_PID_REG     0X8140  <span class="comment">/* GT911产品ID寄存器       */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GT911_CONFIG_DATA_REG   0x8147  <span class="comment">/* GT911配置文件版本号  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GT911_COOR_REG     0X814E  <span class="comment">/* GT911当前检测到的触摸情况 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GT911_TP1_REG     0X814F  <span class="comment">/* 第一个触摸点数据地址 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SUPPORT_POINTS      5       <span class="comment">/* 最多5点电容触摸 */</span></span></span><br></pre></td></tr></table></figure><p>i2c 驱动框架，注册 <code>i2c_driver</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统驱动匹配表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">gt911_id_table</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;goodix,gt911&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备树匹配表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">gt911_of_match_table</span>[] =</span> &#123;</span><br><span class="line">    &#123;.compatible = <span class="string">&quot;goodix,gt911&quot;</span>&#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">gt911_i2c_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;gt911&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .of_match_table = gt911_of_match_table,</span><br><span class="line">    &#125;,</span><br><span class="line">    .id_table = gt911_id_table,</span><br><span class="line">    .probe = gt911_probe,</span><br><span class="line">    .remove = gt911_remove,        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动入口函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gt911_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    printk(<span class="string">&quot;gt911 init\n&quot;</span>);</span><br><span class="line">    ret = i2c_add_driver(&amp;gt911_i2c_driver);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动出口函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gt911_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    i2c_del_driver(&amp;gt911_i2c_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(gt911_init);</span><br><span class="line">module_exit(gt911_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><p>probe 和 remove 函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配成功</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gt911_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gt911_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存，自动释放 注意sizeof里面是(*ts)：表示计算的是结构体的大小，而不是指针大小</span></span><br><span class="line">    dev = devm_kzalloc(&amp;client-&gt;dev, <span class="keyword">sizeof</span>(*dev), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span>(!dev)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    </span><br><span class="line">    dev-&gt;client = client;</span><br><span class="line">    i2c_set_clientdata(client, dev); <span class="comment">// 将dev结构体实例跟i2c设备client绑定起来，便于后续使用dev</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取中断IO和复位IO编号</span></span><br><span class="line">    ret = gt911_get_gpio(dev);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复位gt911</span></span><br><span class="line">    ret = gt911_reset(dev);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed reset\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 测试i2c通信</span></span><br><span class="line">    ret = gt911_i2c_test(dev-&gt;client);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;I2C communication failure\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取gt911配置信息</span></span><br><span class="line">    ret = gt911_read_config(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请input设备</span></span><br><span class="line">    gt911_request_input_dev(dev);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to request input dev\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化中断</span></span><br><span class="line">    ret = gt911_request_irq(dev);   <span class="comment">// 这里使用中断线程化</span></span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to request IRQ\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printk(<span class="string">&quot;gt911_probe end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gt911_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gt911_dev</span> *<span class="title">dev</span> =</span> i2c_get_clientdata(client);</span><br><span class="line">    input_unregister_device(dev-&gt;input_dev);</span><br><span class="line">    printk(<span class="string">&quot;gt911_remove\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gt911_get_gpio</code> 函数获取设备树中的 io 信息，查找 i2c2 总线下的 gt911@5d 子节点的 irq-gpios 和 reset-gpios 属性，为其分配 gpio 编号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取gt911的IO信息</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gt911_get_gpio</span><span class="params">(<span class="keyword">struct</span> gt911_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    dev-&gt;int_pin = of_get_named_gpio(dev-&gt;client-&gt;dev.of_node, <span class="string">&quot;irq-gpios&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(dev-&gt;int_pin &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to get irq-gpios gpio\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dev-&gt;int_pin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev-&gt;reset_pin = of_get_named_gpio(dev-&gt;client-&gt;dev.of_node, <span class="string">&quot;reset-gpios&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(dev-&gt;reset_pin &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to get reset-gpios gpio\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dev-&gt;reset_pin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gt911_reset</code> 函数设置复位 IO 和中断 IO 为 GPIO，并且根据数据手册给出的芯片上电时序，对 gt911 芯片复位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复位gt911</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gt911_reset</span><span class="params">(<span class="keyword">struct</span> gt911_dev *dev)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span>(gpio_is_valid(dev-&gt;reset_pin))</span><br><span class="line">    &#123;</span><br><span class="line">        ret = devm_gpio_request_one(&amp;dev-&gt;client-&gt;dev, dev-&gt;reset_pin, GPIOF_OUT_INIT_HIGH, <span class="string">&quot;gp911-reset&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(gpio_is_valid(dev-&gt;int_pin))</span><br><span class="line">    &#123;</span><br><span class="line">        ret = devm_gpio_request_one(&amp;dev-&gt;client-&gt;dev, dev-&gt;int_pin, GPIOF_OUT_INIT_HIGH, <span class="string">&quot;gp911-int&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gt911上电时序</span></span><br><span class="line">    gpio_set_value(dev-&gt;reset_pin, <span class="number">0</span>);  </span><br><span class="line">    msleep(<span class="number">20</span>);         <span class="comment">/* 20ms T2: &gt; 10ms */</span></span><br><span class="line"></span><br><span class="line">    gpio_set_value(dev-&gt;int_pin, <span class="number">0</span>);</span><br><span class="line">    usleep_range(<span class="number">100</span>, <span class="number">2000</span>);        <span class="comment">/* 100us~2ms T3: &gt; 100us */</span></span><br><span class="line"></span><br><span class="line">    gpio_set_value(dev-&gt;reset_pin, <span class="number">1</span>);</span><br><span class="line">    usleep_range(<span class="number">6000</span>, <span class="number">10000</span>);      <span class="comment">/* 6ms~10ms T4: &gt; 5ms */</span></span><br><span class="line"></span><br><span class="line">    gpio_direction_input(dev-&gt;int_pin);     <span class="comment">// INT引脚设置为输入</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gt911_read_reg</code> 和 <code>gt911_write_reg</code> 函数是读取和写入 gt911 芯片数据的函数，跟之前芯片不同的是，这个芯片的寄存器地址是 16 位，修改一下即可使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : 读取 gt911 设备多个寄存器数据</span></span><br><span class="line"><span class="comment">* @param – dev : gt911 设备</span></span><br><span class="line"><span class="comment">* @param – reg : 要读取的寄存器首地址 16位</span></span><br><span class="line"><span class="comment">* @param – val : 读取到的数据</span></span><br><span class="line"><span class="comment">* @param – len : 要读取的数据长度</span></span><br><span class="line"><span class="comment">* @return : 操作结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gt911_read_reg</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">uint16_t</span> reg, <span class="type">uint8_t</span> *buf, <span class="type">uint16_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line">    <span class="type">uint8_t</span> reg_16bit[<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* GT911寄存器地址位 16位 */</span></span><br><span class="line">    reg_16bit[<span class="number">0</span>] = reg &gt;&gt; <span class="number">8</span>;  <span class="comment">// 高8字节</span></span><br><span class="line">    reg_16bit[<span class="number">1</span>] = reg &amp; <span class="number">0xFF</span>; <span class="comment">// 低8字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* msg[0]，第一条写消息，发送要读取的寄存器首地址*/</span></span><br><span class="line">msg[<span class="number">0</span>].addr = client-&gt;addr;<span class="comment">// 设备地址</span></span><br><span class="line">msg[<span class="number">0</span>].flags = <span class="number">0</span>;<span class="comment">// 写数据</span></span><br><span class="line">msg[<span class="number">0</span>].buf = reg_16bit;<span class="comment">// 寄存器地址</span></span><br><span class="line">msg[<span class="number">0</span>].len = <span class="number">2</span>;<span class="comment">// msg长度：寄存器地址长度 2个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* msg[1]，第二条读消息，读取寄存器数据*/</span></span><br><span class="line">msg[<span class="number">1</span>].addr = client-&gt;addr;<span class="comment">// 设备地址</span></span><br><span class="line">msg[<span class="number">1</span>].flags = I2C_M_RD;<span class="comment">// 读数据</span></span><br><span class="line">msg[<span class="number">1</span>].buf= buf;<span class="comment">// 读取的数据</span></span><br><span class="line">msg[<span class="number">1</span>].len = len;<span class="comment">// msg长度：读取数据的长度</span></span><br><span class="line"></span><br><span class="line">ret =  i2c_transfer(client-&gt;adapter, msg, <span class="number">2</span>);<span class="comment">// 2个msg</span></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">2</span>)</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = -EREMOTEIO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : 向 gt911 设备多个寄存器写入数据</span></span><br><span class="line"><span class="comment">* @param – dev : 要写入的设备结构体</span></span><br><span class="line"><span class="comment">* @param – reg : 要写入的寄存器首地址 16位</span></span><br><span class="line"><span class="comment">* @param – val : 要写入的数据缓冲区</span></span><br><span class="line"><span class="comment">* @param – len : 要写入的数据长度</span></span><br><span class="line"><span class="comment">* @return : 操作结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gt911_write_reg</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">uint16_t</span> reg, <span class="type">uint8_t</span> *buf, <span class="type">uint16_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> tmp[<span class="number">256</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>;</span><span class="comment">// 存放待写入的寄存器地址和数据等信息</span></span><br><span class="line"></span><br><span class="line">    tmp[<span class="number">0</span>] = reg &gt;&gt; <span class="number">8</span>;               <span class="comment">// 寄存器首地址高8位</span></span><br><span class="line">    tmp[<span class="number">1</span>] = reg &amp; <span class="number">0xFF</span>;             <span class="comment">// 寄存器首地址低8位</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;tmp[<span class="number">2</span>], buf, len);       <span class="comment">// 写入的数据</span></span><br><span class="line"></span><br><span class="line">msg.addr = client-&gt;addr;<span class="comment">// 设备地址</span></span><br><span class="line">msg.flags = <span class="number">0</span>;<span class="comment">// 写数据</span></span><br><span class="line">msg.buf = tmp;<span class="comment">// 发送的数据缓冲区</span></span><br><span class="line">msg.len = len + <span class="number">2</span>;<span class="comment">// msg长度：写入的数据长度 + 寄存器地址长度2个字节 （单位：字节)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>);<span class="comment">// 1个msg</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gt911_i2c_test</code> 函数是测试能否与 gt911 芯片正常的通信，也可以不要其实。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试i2c通信</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gt911_i2c_test</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取GT911_CONFIG_DATA_REG测试i2c是否正常</span></span><br><span class="line">    <span class="keyword">while</span>(count++ &gt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = gt911_read_reg(client, GT911_CONFIG_DATA_REG, &amp;buf, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!ret)    <span class="comment">// 成功返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        printk(<span class="string">&quot;gt911 i2c test attempt %d: %d\n&quot;</span>, count, ret);</span><br><span class="line">        msleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gt911_read_config</code> 函数是用来读取 gt911 芯片相对应寄存器地址，来获取 Product ID、Firmware version、vendor_id 以及触摸的最大 x 坐标和 y 坐标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取gt911信息</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gt911_read_config</span><span class="params">(<span class="keyword">struct</span> gt911_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">uint8_t</span> buf[<span class="number">11</span>];</span><br><span class="line">    <span class="type">uint8_t</span> pid[<span class="number">4</span>];</span><br><span class="line">    <span class="type">long</span> id;</span><br><span class="line"></span><br><span class="line">    ret = gt911_read_reg(dev-&gt;client, GT911_PID_REG, buf, <span class="number">11</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Product ID</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pid, buf, <span class="number">4</span>);</span><br><span class="line">    ret = kstrtol(pid, <span class="number">10</span>, &amp;id);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    dev-&gt;info.pid = (<span class="type">uint16_t</span>)id;</span><br><span class="line">    printk(<span class="string">&quot;Product ID:%d\n&quot;</span>, dev-&gt;info.pid);</span><br><span class="line">    <span class="comment">//printk(&quot;Product ID: %c%c%c%c\n&quot;, dev-&gt;info.pid[0], dev-&gt;info.pid[1], dev-&gt;info.pid[2], dev-&gt;info.pid[3]);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Firmware version</span></span><br><span class="line">    dev-&gt;info.version = ((<span class="type">uint16_t</span>)buf[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">4</span>];</span><br><span class="line">    printk(<span class="string">&quot;Firmware version: %x\n&quot;</span>, dev-&gt;info.version);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取x_max y_max</span></span><br><span class="line">    dev-&gt;info.max_x = ((<span class="type">uint16_t</span>)buf[<span class="number">7</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">6</span>];</span><br><span class="line">    dev-&gt;info.max_y = ((<span class="type">uint16_t</span>)buf[<span class="number">9</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">8</span>];</span><br><span class="line">    printk(<span class="string">&quot;Max X: %d, Max Y: %d\n&quot;</span>, dev-&gt;info.max_x, dev-&gt;info.max_y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 vendor_id</span></span><br><span class="line">    dev-&gt;info.vendor_id = buf[<span class="number">10</span>];</span><br><span class="line">    printk(<span class="string">&quot;Vendor_id: %d\n&quot;</span>, dev-&gt;info.vendor_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gt911_request_input_dev</code> 函数用来申请注册 input 设备，对 input 设备进行初始化，设置需要上报哪些事件，初始化多点触摸功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gt911申请input_dev</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gt911_request_input_dev</span><span class="params">(<span class="keyword">struct</span> gt911_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    dev-&gt;input_dev = devm_input_allocate_device(&amp;dev-&gt;client-&gt;dev);</span><br><span class="line">    <span class="keyword">if</span>(!dev-&gt;input_dev)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to allocate input device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// input_dev赋值</span></span><br><span class="line">    dev-&gt;input_dev-&gt;name = <span class="string">&quot;GT911 TouchScreen&quot;</span>; <span class="comment">// 名字</span></span><br><span class="line">    dev-&gt;input_dev-&gt;phys = <span class="string">&quot;input/ts&quot;</span>;</span><br><span class="line">    dev-&gt;input_dev-&gt;id.bustype = BUS_I2C;   <span class="comment">// 总线类型</span></span><br><span class="line">    dev-&gt;input_dev-&gt;id.vendor = dev-&gt;info.vendor_id;</span><br><span class="line">    dev-&gt;input_dev-&gt;id.product = dev-&gt;info.pid;</span><br><span class="line">    dev-&gt;input_dev-&gt;id.version = dev-&gt;info.version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置input设备需要上报哪些事件</span></span><br><span class="line">    __set_bit(EV_KEY, dev-&gt;input_dev-&gt;evbit);   <span class="comment">// 按键事件</span></span><br><span class="line">    __set_bit(EV_ABS, dev-&gt;input_dev-&gt;evbit);   <span class="comment">// 重复事件</span></span><br><span class="line">    __set_bit(BTN_TOUCH, dev-&gt;input_dev-&gt;keybit);   <span class="comment">// 触摸按键类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化多点触摸功能</span></span><br><span class="line">    input_set_abs_params(dev-&gt;input_dev, ABS_MT_POSITION_X, <span class="number">0</span>, dev-&gt;info.max_x, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    input_set_abs_params(dev-&gt;input_dev, ABS_MT_POSITION_Y, <span class="number">0</span>, dev-&gt;info.max_y, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    input_set_abs_params(dev-&gt;input_dev, ABS_MT_TOUCH_MAJOR, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = input_mt_init_slots(dev-&gt;input_dev, MAX_SUPPORT_POINTS, INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to init mt slots\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    ret = input_register_device(dev-&gt;input_dev);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to register input device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中断部分：使用中断线程化，在中断线程函数中获取触摸点信息并上报信息，<strong>退出中断时要对 0x814E 寄存器清零，否则会一直触摸中断。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断线程函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gt911_irq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">uint8_t</span> data;</span><br><span class="line">    <span class="type">int</span> touch_num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gt911_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> gt911_dev *)dev_id;</span><br><span class="line">    </span><br><span class="line">    ret = gt911_read_reg(dev-&gt;client, GT911_COOR_REG, &amp;data, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="number">0x00</span>)</span><br><span class="line">        <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">    touch_num = data &amp; <span class="number">0x0F</span>;</span><br><span class="line"></span><br><span class="line">    gt911_process_event(dev, touch_num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理寄存器值 否则会一直触发中断</span></span><br><span class="line">    data = <span class="number">0x00</span>;</span><br><span class="line">    gt911_write_reg(dev-&gt;client, GT911_COOR_REG, &amp;data, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gt911_request_irq</span><span class="params">(<span class="keyword">struct</span> gt911_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 中断线程化</span></span><br><span class="line">    <span class="keyword">return</span> devm_request_threaded_irq(&amp;dev-&gt;client-&gt;dev, dev-&gt;client-&gt;irq,</span><br><span class="line">            <span class="literal">NULL</span>, gt911_irq_handler, IRQ_TYPE_EDGE_FALLING | IRQF_ONESHOT,</span><br><span class="line">            dev-&gt;client-&gt;name, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理和上报触摸数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上报触摸数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gt911_ts_report_touch</span><span class="params">(<span class="keyword">struct</span> gt911_dev *dev, <span class="type">uint8_t</span> *data, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> input_x, input_y, input_w;</span><br><span class="line">    <span class="comment">//id = data[0];</span></span><br><span class="line">    input_x = ((<span class="type">uint16_t</span>)data[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">1</span>];</span><br><span class="line">    input_y = ((<span class="type">uint16_t</span>)data[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">3</span>];</span><br><span class="line">    input_w = ((<span class="type">uint16_t</span>)data[<span class="number">6</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    input_mt_slot(dev-&gt;input_dev, i);</span><br><span class="line">    input_mt_report_slot_state(dev-&gt;input_dev, MT_TOOL_FINGER, <span class="literal">true</span>);</span><br><span class="line">    input_report_abs(dev-&gt;input_dev, ABS_MT_POSITION_X, input_x);</span><br><span class="line">    input_report_abs(dev-&gt;input_dev, ABS_MT_POSITION_Y, input_y);</span><br><span class="line">    input_report_abs(dev-&gt;input_dev, ABS_MT_TOUCH_MAJOR, input_w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理触摸数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gt911_process_event</span><span class="params">(<span class="keyword">struct</span> gt911_dev *dev, <span class="type">int</span> touch_num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, ret;</span><br><span class="line">    <span class="type">uint8_t</span> touch_data[<span class="number">8</span> * MAX_SUPPORT_POINTS - <span class="number">3</span>];</span><br><span class="line">    <span class="type">uint16_t</span> cur_touch = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint16_t</span> pre_touch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否有数据</span></span><br><span class="line">    ret = gt911_read_reg(dev-&gt;client, GT911_TP1_REG, touch_data, <span class="number">8</span> * MAX_SUPPORT_POINTS - <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX_SUPPORT_POINTS; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(touch_num &amp;&amp; (i == touch_data[<span class="number">8</span> * i]))  </span><br><span class="line">        &#123;</span><br><span class="line">            gt911_ts_report_touch(dev, &amp;touch_data[<span class="number">8</span> * i], i);</span><br><span class="line">            cur_touch |= (<span class="number">0x01</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pre_touch &amp; (<span class="number">0x01</span> &lt;&lt; i))    <span class="comment">// 上一次触摸完这次释放了</span></span><br><span class="line">        &#123;</span><br><span class="line">            input_mt_slot(dev-&gt;input_dev, i);</span><br><span class="line">            input_mt_report_slot_state(dev-&gt;input_dev, MT_TOOL_FINGER, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pre_touch = cur_touch;    <span class="comment">// 更新上一次的触摸状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步数据 上报完成</span></span><br><span class="line">    input_mt_report_pointer_emulation(dev-&gt;input_dev, <span class="literal">true</span>);</span><br><span class="line">    input_sync(dev-&gt;input_dev);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将驱动添加到内核">将驱动添加到内核</h3><p>修改 <code>drivers/input/touchscreen</code> 目录下的 Makefile 文件，在最下面添加一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-y += gt911.o</span><br></pre></td></tr></table></figure><p>接着编译内核，重启开发板，使用 hexdump 命令测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump /dev/input/event1</span><br></pre></td></tr></table></figure><p>路径看你的触摸屏对应哪个 event，使用以下命令看你的触摸屏对应哪个 event：查看设备节点对应哪些硬件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/bus/input/devices</span><br></pre></td></tr></table></figure><h2 id="tslib-移植">tslib 移植</h2><p>tslib 是一个开源的第三方库，用于触摸屏性能测试。</p><blockquote><p><a href="https://github.com/libts/tslib">libts/tslib: Touchscreen access library (github.com)</a></p></blockquote><p>编译 tslib 前需要安装一些插件，防止编译过程出错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install autoconf</span><br><span class="line">sudo apt-get install automake</span><br><span class="line">sudo apt-get install libtool</span><br></pre></td></tr></table></figure><p>编译 tslib：在 tslib 源码目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./autogen.sh</span><br><span class="line">./configure --host=arm-buildroot-linux-gnueabihf --prefix=/home/router2/tslib-1.21/tmp</span><br><span class="line">make -j8</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li>host 填写自己交叉编译器的名字</li><li>prefix 为编译生成文件存放目录，得使用绝对路径</li></ul><p>将生成的文件复制到开发板的 /opt 目录下，放到 /opt 目录下只是为了区分，也可以直接放到根目录下的 etc、bin、include、lib、share 目录下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -rf</span><br></pre></td></tr></table></figure><p>配置 tslib，打开 <code>/etc/ts.conf</code> 文件，确保改行未被注释：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module_raw input</span><br></pre></td></tr></table></figure><p>接着在开发板上 <code>/etc/profile</code> 文件中加入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export TSLIB_ROOT=/opt/tslib-1.21</span><br><span class="line">export TSLIB_FBDEVICE=/dev/fb0</span><br><span class="line">export TSLIB_TSDEVICE=/dev/input/event1</span><br><span class="line">export TSLIB_CONFFILE=/opt/tslib-1.21/etc/ts.conf</span><br><span class="line">export TSLIB_CALIBFILE=/etc/pointercal</span><br><span class="line">export TSLIB_PLUGINDIR=/opt/tslib-1.21/lib/ts</span><br><span class="line">export TSLIB_CONSOLEDEVICE=none</span><br><span class="line">export LD_LIBRARY_PATH=/lib:/usr/lib:/usr/local/lib:$TSLIB_ROOT/lib/</span><br></pre></td></tr></table></figure><ul><li>TSLIB_TSDEVICE：指定触摸设备的设备节点</li><li>TSLIB_FBDEVICE：指定 framebuffer 设备，即屏幕设备节点</li><li>TSLIB_CALIBFILE：指定校准结果保存路径，会自动生成，不用手动创建。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux-触摸屏驱动&quot;&gt;Linux-触摸屏驱动&lt;/h1&gt;
&lt;h2 id=&quot;环境&quot;&gt;环境&lt;/h2&gt;
&lt;h3 id=&quot;硬件环境&quot;&gt;硬件环境&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;开发板型号&lt;/strong&gt;：&lt;a href=&quot;https://blog.csdn</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/Linux/"/>
    
    
    <category term="Linux 嵌入式" scheme="http://www.obito.top/tags/Linux-%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统移植</title>
    <link href="http://www.obito.top/2024/06/30/Linux%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/"/>
    <id>http://www.obito.top/2024/06/30/Linux%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/</id>
    <published>2024-06-30T06:18:41.000Z</published>
    <updated>2024-07-19T09:31:36.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-系统移植">Linux 系统移植</h1><h2 id="序言">序言</h2><p>Linux 学了有些时间了，手上的开发板很多功能都提前做好了，对初学者挺友好的，但是为了学到更到东西，就来试试移植下新的 Linux 系统到开发板上。</p><h2 id="环境">环境</h2><h3 id="硬件环境">硬件环境</h3><ul><li><strong>开发板型号</strong>： <a href="https://blog.csdn.net/thisway_diy/article/details/109841372">100ask_imx6ull_pro 开发板</a></li><li><strong>处理器类型</strong>：NXP IMX6ULL</li><li>**处理器架构：**恩单核 Cortex-A7</li><li>**处理器主频：**800MHZ</li><li><strong>内存容量</strong>：512 MB DDR3</li><li><strong>存储介质</strong>：4GB eMMC</li></ul><h3 id="软件环境">软件环境</h3><ul><li>宿主机<ul><li><strong>宿主机操作系统</strong>：Ubuntu 18.04</li><li><strong>交叉编译器</strong>：100ask 提供的工具链 arm-buildroot-linux-gnueabihf- <strong>支持的最低内核版本</strong>：4.9.0</li></ul></li><li>开发板<ul><li><strong>U-Boot</strong>：一开始用的 NXP 官方提供的版本但不能正常启动内核，后改为 100ask 提供的版本</li><li><strong>内核版本</strong>： <a href="https://github.com/nxp-imx/linux-imx/tree/imx_4.9.88_2.0.0_ga">NXP 提供的 4.9.88 版本</a></li><li><strong>根文件系统类型</strong>：<a href="https://busybox.net/downloads/">BusyBox 1.29.0</a></li></ul></li></ul><h2 id="linux-系统移植过程概述">Linux 系统移植过程概述</h2><p>Linux 系统移植需要以下三个部分：</p><ul><li>bootloader：用于启动 Linux 内核。常用 bootloader：U-Boot</li><li>Linux 内核：一般使用芯片原厂提供的源码</li><li>根文件系统：存放一些常用的命令和文件</li></ul><p><strong>U-Boot、Linux kernel 和 根文件系统三者一起构成了一个完整的 Linux 系统。</strong></p><p><strong>步骤</strong></p><ul><li>移植 U-Boot</li><li>移植 Linux 内核：编译内核可以选择是否生成设备树</li><li>根文件系统</li></ul><blockquote><p>移植 Linux 之前我们需要先移植一个 bootloader 代码，这个 bootloader 代码用于启动 Linux 内核，bootloader 有很多，常用的就是 U-Boot。移植好 U-Boot 以后再移植 Linux 内核，移植完 Linux 内核以后 Linux 还不能正常启动，还需要再移植一个根文件系统(rootfs)，根文件系统里面包含了一些最常用的命令和文件。所以 U-Boot、Linux kernel 和 rootfs 这三者一起构成了一个完整的 Linux 系统，一个可以正常使用、功能完善的 Linux 系统。在本篇我们就来讲解 U-Boot、Linux Kernel 和 rootfs 的移植，与其说是“移植”，倒不如说是“适配”，因为大部分的移植工作都由 NXP 完成了，我们这里所谓的“移植”主要是使其能够在I.MX6U-ALPHA 开发板上跑起来。</p></blockquote><blockquote><p><a href="https://blog.csdn.net/m0_56694518/article/details/131463913">系统移植（环境搭建、uboot、Linux内核、根文件系统）-CSDN博客</a></p></blockquote><h2 id="u-boot">U-Boot</h2><p>U-Boot 的全称是 Universal Boot Loader，U-Boot 是一个遵循 GPL 协议的开源软件，U-Boot 是一个裸机代码，可以看作是一个裸机综合例程</p><p>Linux 系统要启动就必须需要一个 bootloader 程序，也就说<strong>芯片上电以后先运行一段 bootloader 程序</strong>。这段bootloader 程序会先<strong>初始化 DDR 等外设</strong>，然后将 Linux 内核从 flash(NAND，NOR FLASH，SD，MMC 等)<strong>拷贝到 DDR 中</strong>，最后<strong>启动 Linux 内核</strong>。</p><p>U-Boot 我们一般不是使用 U-Boot 官方的源码，而是采用开发板对应芯片厂商的定制版本，一般分为三种：</p><table><thead><tr><th>厂商</th><th>描述</th></tr></thead><tbody><tr><td>U-Boot 官方的 U-Boot 代码</td><td>由 U-Boot 官方维护开发的 U-Boot 版本，版本更新快，基本包含所有常用的芯片。</td></tr><tr><td>半导体厂商的 U-Boot 代码</td><td>半导体厂商维护的一个 U-Boot，专门针对自家的芯片，在对自家芯片支持上要比 U-Boot 官方的好。</td></tr><tr><td>开发板厂商的 U-Boot 代码</td><td>开发板厂商在半导体厂商提供的 U-Boot 基础上加入了对自家开发板的支持。</td></tr></tbody></table><blockquote><p>U-boot 官方 U-Boot 源码下载页面：<a href="http://ftp.denx.de/pub/uboot/">http://ftp.denx.de/pub/uboot/</a><br>NXP 官方 U-Boot 源码 Git 地址：<a href="https://source.codeaurora.org/external/imx/ubootimx">https://source.codeaurora.org/external/imx/ubootimx</a></p></blockquote><h3 id="u-boot-移植">U-Boot 移植</h3><p>uboot 移植的一般流程：</p><ul><li>在 uboot 中找到参考的开发平台，一般是原厂的开发板。</li><li>参考原厂开发板移植 uboot 到我们所使用的开发板上。</li></ul><p><strong>一般 uboot 中需要解决串口、NAND、EMMC 或 SD 卡、网络和 LCD 驱动，因为 uboot 的主要目的就是启动 Linux 内核，所以不需要考虑太多的外设驱动。</strong></p><p><em><strong>PS：这里使用 NXP 官方提供的 uboot 按照正点原子教程移植到 100ask 开发板初步测试成功，但是后续启动 Linux 内核时会出现 <code>data abort</code> 的问题，目前暂未解决，换成 100ask 提供的 uboot 则能正常启动 Linux 内核，这里依旧是使用 NXP 官方提供的 uboot 源码进行修改测试。</strong></em></p><h4 id="编译-nxp-官方开发板的-u-boot">编译 NXP 官方开发板的 U-Boot</h4><p>找到 NXP 官方 I.MX6ULL EVK 开发板对应的默认配置文件以后就可以编译一下，这里我们选择 EMMC 版本的 <code>mx6ull_14x14_evk_emmc_defconfig</code> ，CROSS_COMPILE 选择自己的交叉编译器。</p><p>使用如下命令编译 uboot：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-buildroot-linux-gnueabihf- mx6ull_14x14_evk_emmc_defconfig</span><br><span class="line">make V=1 ARCH=arm CROSS_COMPILE=arm-buildroot-linux-gnueabihf- -j16</span><br></pre></td></tr></table></figure><p>编译成功结果如下：</p><p><img src="image-20240702145611903.png" alt="image-20240702145611903"></p><h4 id="烧录到-sd-卡测试">烧录到 SD 卡测试</h4><p>将 SD 卡插入查看 /dev/ 目录下新增哪个目录，就是 SD 卡的目录。</p><p>**我们编译出来的 .bin 文件不能直接烧写到 SD 卡中，需要在 .bin 文件前面加上 IVT、Boot Data 和 DCD 这三个数据块。**这三个数据块是有指定格式的我们必须按照格式填写，然后将其放到 .bin 文件前面，最终合成的才是可以直接烧写到 SD 卡中的文件。</p><h5 id="方法一：使用-imxdownload-程序">方法一：使用 imxdownload 程序</h5><p>使用 imxdownload 程序将 .bin文件转换为 .imx 烧录进 SD 卡。</p><p><img src="image-20240702153906291.png" alt="image-20240702153906291"></p><h5 id="方法二：使用-dd-命令">方法二：使用 dd 命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd iflag=dsync oflag=dsync if=u-boot-dtb.imx of=/dev/mmcblk0 seek=2</span><br></pre></td></tr></table></figure><p>烧录完成后，将开发板启动方式转换为 SD 卡启动，然后复位开发板，即可看见串口打印 uboot 信息如下：</p><p><img src="image-20240702155829913.png" alt="image-20240702155829913"></p><p>imxdownload 头文件和源文件如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IMXDOWNLOAD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IMXDOWNLOAD_H</span></span><br><span class="line"><span class="comment">/* IMX6U IVT DCD表信息  暂时定义为1K Bytes，此表是读取的u-boot.imx前1K Bytes</span></span><br><span class="line"><span class="comment"> * imx6_ivedcd_table[9]是指明代码长度的，本应该根据实际的代码长度来修改</span></span><br><span class="line"><span class="comment"> * 这里为了方便，就直接定义为2M Bytes，即</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> imx6_512mb_ivtdcd_table[<span class="number">256</span>] = &#123;</span><br><span class="line"><span class="number">0X402000D1</span>,<span class="number">0X87800000</span>,<span class="number">0X00000000</span>,<span class="number">0X877FF42C</span>,<span class="number">0X877FF420</span>,<span class="number">0X877FF400</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X877FF000</span>,<span class="number">0X00200000</span>,<span class="number">0X00000000</span>,<span class="number">0X40E801D2</span>,<span class="number">0X04E401CC</span>,<span class="number">0X68400C02</span>,<span class="number">0XFFFFFFFF</span>,<span class="number">0X6C400C02</span>,</span><br><span class="line"><span class="number">0XFFFFFFFF</span>,<span class="number">0X70400C02</span>,<span class="number">0XFFFFFFFF</span>,<span class="number">0X74400C02</span>,<span class="number">0XFFFFFFFF</span>,<span class="number">0X78400C02</span>,<span class="number">0XFFFFFFFF</span>,<span class="number">0X7C400C02</span>,</span><br><span class="line"><span class="number">0XFFFFFFFF</span>,<span class="number">0X80400C02</span>,<span class="number">0XFFFFFFFF</span>,<span class="number">0XB4040E02</span>,<span class="number">0X00000C00</span>,<span class="number">0XAC040E02</span>,<span class="number">0X00000000</span>,<span class="number">0X7C020E02</span>,</span><br><span class="line"><span class="number">0X30000000</span>,<span class="number">0X50020E02</span>,<span class="number">0X30000000</span>,<span class="number">0X4C020E02</span>,<span class="number">0X30000000</span>,<span class="number">0X90040E02</span>,<span class="number">0X30000000</span>,<span class="number">0X88020E02</span>,</span><br><span class="line"><span class="number">0X30000C00</span>,<span class="number">0X70020E02</span>,<span class="number">0X00000000</span>,<span class="number">0X60020E02</span>,<span class="number">0X30000000</span>,<span class="number">0X64020E02</span>,<span class="number">0X30000000</span>,<span class="number">0XA0040E02</span>,</span><br><span class="line"><span class="number">0X30000000</span>,<span class="number">0X94040E02</span>,<span class="number">0X00000200</span>,<span class="number">0X80020E02</span>,<span class="number">0X30000000</span>,<span class="number">0X84020E02</span>,<span class="number">0X30000000</span>,<span class="number">0XB0040E02</span>,</span><br><span class="line"><span class="number">0X00000200</span>,<span class="number">0X98040E02</span>,<span class="number">0X30000000</span>,<span class="number">0XA4040E02</span>,<span class="number">0X30000000</span>,<span class="number">0X44020E02</span>,<span class="number">0X30000000</span>,<span class="number">0X48020E02</span>,</span><br><span class="line"><span class="number">0X30000000</span>,<span class="number">0X1C001B02</span>,<span class="number">0X00800000</span>,<span class="number">0X00081B02</span>,<span class="number">0X030039A1</span>,<span class="number">0X0C081B02</span>,<span class="number">0X0B000300</span>,<span class="number">0X3C081B02</span>,</span><br><span class="line"><span class="number">0X44014801</span>,<span class="number">0X48081B02</span>,<span class="number">0X302C4040</span>,<span class="number">0X50081B02</span>,<span class="number">0X343E4040</span>,<span class="number">0X1C081B02</span>,<span class="number">0X33333333</span>,<span class="number">0X20081B02</span>,</span><br><span class="line"><span class="number">0X33333333</span>,<span class="number">0X2C081B02</span>,<span class="number">0X333333F3</span>,<span class="number">0X30081B02</span>,<span class="number">0X333333F3</span>,<span class="number">0XC0081B02</span>,<span class="number">0X09409400</span>,<span class="number">0XB8081B02</span>,</span><br><span class="line"><span class="number">0X00080000</span>,<span class="number">0X04001B02</span>,<span class="number">0X2D000200</span>,<span class="number">0X08001B02</span>,<span class="number">0X3030331B</span>,<span class="number">0X0C001B02</span>,<span class="number">0XF3526B67</span>,<span class="number">0X10001B02</span>,</span><br><span class="line"><span class="number">0X630B6DB6</span>,<span class="number">0X14001B02</span>,<span class="number">0XDB00FF01</span>,<span class="number">0X18001B02</span>,<span class="number">0X40172000</span>,<span class="number">0X1C001B02</span>,<span class="number">0X00800000</span>,<span class="number">0X2C001B02</span>,</span><br><span class="line"><span class="number">0XD2260000</span>,<span class="number">0X30001B02</span>,<span class="number">0X23106B00</span>,<span class="number">0X40001B02</span>,<span class="number">0X4F000000</span>,<span class="number">0X00001B02</span>,<span class="number">0X00001884</span>,<span class="number">0X90081B02</span>,</span><br><span class="line"><span class="number">0X00004000</span>,<span class="number">0X1C001B02</span>,<span class="number">0X32800002</span>,<span class="number">0X1C001B02</span>,<span class="number">0X33800000</span>,<span class="number">0X1C001B02</span>,<span class="number">0X31800400</span>,<span class="number">0X1C001B02</span>,</span><br><span class="line"><span class="number">0X30802015</span>,<span class="number">0X1C001B02</span>,<span class="number">0X40800004</span>,<span class="number">0X20001B02</span>,<span class="number">0X00080000</span>,<span class="number">0X18081B02</span>,<span class="number">0X27020000</span>,<span class="number">0X04001B02</span>,</span><br><span class="line"><span class="number">0X2D550200</span>,<span class="number">0X04041B02</span>,<span class="number">0X06100100</span>,<span class="number">0X1C001B02</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> imx6_256mb_ivtdcd_table[<span class="number">256</span>] = &#123;</span><br><span class="line"><span class="number">0X402000D1</span>,<span class="number">0X87800000</span>,<span class="number">0X00000000</span>,<span class="number">0X877FF42C</span>,<span class="number">0X877FF420</span>,<span class="number">0X877FF400</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X877FF000</span>,<span class="number">0X00076000</span>,<span class="number">0X00000000</span>,<span class="number">0X40E801D2</span>,<span class="number">0X04E401CC</span>,<span class="number">0X68400C02</span>,<span class="number">0XFFFFFFFF</span>,<span class="number">0X6C400C02</span>,</span><br><span class="line"><span class="number">0XFFFFFFFF</span>,<span class="number">0X70400C02</span>,<span class="number">0XFFFFFFFF</span>,<span class="number">0X74400C02</span>,<span class="number">0XFFFFFFFF</span>,<span class="number">0X78400C02</span>,<span class="number">0XFFFFFFFF</span>,<span class="number">0X7C400C02</span>,</span><br><span class="line"><span class="number">0XFFFFFFFF</span>,<span class="number">0X80400C02</span>,<span class="number">0XFFFFFFFF</span>,<span class="number">0XB4040E02</span>,<span class="number">0X00000C00</span>,<span class="number">0XAC040E02</span>,<span class="number">0X00000000</span>,<span class="number">0X7C020E02</span>,</span><br><span class="line"><span class="number">0X30000000</span>,<span class="number">0X50020E02</span>,<span class="number">0X30000000</span>,<span class="number">0X4C020E02</span>,<span class="number">0X30000000</span>,<span class="number">0X90040E02</span>,<span class="number">0X30000000</span>,<span class="number">0X88020E02</span>,</span><br><span class="line"><span class="number">0X30000C00</span>,<span class="number">0X70020E02</span>,<span class="number">0X00000000</span>,<span class="number">0X60020E02</span>,<span class="number">0X30000000</span>,<span class="number">0X64020E02</span>,<span class="number">0X30000000</span>,<span class="number">0XA0040E02</span>,</span><br><span class="line"><span class="number">0X30000000</span>,<span class="number">0X94040E02</span>,<span class="number">0X00000200</span>,<span class="number">0X80020E02</span>,<span class="number">0X30000000</span>,<span class="number">0X84020E02</span>,<span class="number">0X30000000</span>,<span class="number">0XB0040E02</span>,</span><br><span class="line"><span class="number">0X00000200</span>,<span class="number">0X98040E02</span>,<span class="number">0X30000000</span>,<span class="number">0XA4040E02</span>,<span class="number">0X30000000</span>,<span class="number">0X44020E02</span>,<span class="number">0X30000000</span>,<span class="number">0X48020E02</span>,</span><br><span class="line"><span class="number">0X30000000</span>,<span class="number">0X1C001B02</span>,<span class="number">0X00800000</span>,<span class="number">0X00081B02</span>,<span class="number">0X030039A1</span>,<span class="number">0X0C081B02</span>,<span class="number">0X04000000</span>,<span class="number">0X3C081B02</span>,</span><br><span class="line"><span class="number">0X3C013C01</span>,<span class="number">0X48081B02</span>,<span class="number">0X38324040</span>,<span class="number">0X50081B02</span>,<span class="number">0X28304040</span>,<span class="number">0X1C081B02</span>,<span class="number">0X33333333</span>,<span class="number">0X20081B02</span>,</span><br><span class="line"><span class="number">0X33333333</span>,<span class="number">0X2C081B02</span>,<span class="number">0X333333F3</span>,<span class="number">0X30081B02</span>,<span class="number">0X333333F3</span>,<span class="number">0XC0081B02</span>,<span class="number">0X09409400</span>,<span class="number">0XB8081B02</span>,</span><br><span class="line"><span class="number">0X00080000</span>,<span class="number">0X04001B02</span>,<span class="number">0X2D000200</span>,<span class="number">0X08001B02</span>,<span class="number">0X3030331B</span>,<span class="number">0X0C001B02</span>,<span class="number">0XF352433F</span>,<span class="number">0X10001B02</span>,</span><br><span class="line"><span class="number">0X630B6DB6</span>,<span class="number">0X14001B02</span>,<span class="number">0XDB00FF01</span>,<span class="number">0X18001B02</span>,<span class="number">0X40172000</span>,<span class="number">0X1C001B02</span>,<span class="number">0X00800000</span>,<span class="number">0X2C001B02</span>,</span><br><span class="line"><span class="number">0XD2260000</span>,<span class="number">0X30001B02</span>,<span class="number">0X23104300</span>,<span class="number">0X40001B02</span>,<span class="number">0X47000000</span>,<span class="number">0X00001B02</span>,<span class="number">0X00001883</span>,<span class="number">0X90081B02</span>,</span><br><span class="line"><span class="number">0X00004000</span>,<span class="number">0X1C001B02</span>,<span class="number">0X32800002</span>,<span class="number">0X1C001B02</span>,<span class="number">0X33800000</span>,<span class="number">0X1C001B02</span>,<span class="number">0X31800400</span>,<span class="number">0X1C001B02</span>,</span><br><span class="line"><span class="number">0X30802015</span>,<span class="number">0X1C001B02</span>,<span class="number">0X40800004</span>,<span class="number">0X20001B02</span>,<span class="number">0X00080000</span>,<span class="number">0X18081B02</span>,<span class="number">0X27020000</span>,<span class="number">0X04001B02</span>,</span><br><span class="line"><span class="number">0X2D550200</span>,<span class="number">0X04041B02</span>,<span class="number">0X06100100</span>,<span class="number">0X1C001B02</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line"><span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,<span class="number">0X00000000</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imxdownload.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHELLCMD_LEN(200)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIN_OFFSET(3072)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 此宏指明是否打印u-boot.imx的IVT DCD表信息，不同的开发板其IVT和DCD</span></span><br><span class="line"><span class="comment"> * 表的数据是不同的，因此需要获取所使用的开发板的IVT和DCD表信息，最</span></span><br><span class="line"><span class="comment"> * 简单的方法就是读取开发板配套资料里面的u-boot.imx的前1KB数据，理论上</span></span><br><span class="line"><span class="comment"> * 应该读取3KB的数据，但是表信息远远没有3K这么多，因此读1KB即可 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_TAB0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 介绍： 此软件是针对NXP的IMX6U系列芯片的，软件用来烧写bin文件到SD卡里面，</span></span><br><span class="line"><span class="comment"> *        本软件会自动添加IVT、DCD等信息到原始的bin文件里面，主要用于裸机和uboot的烧写。</span></span><br><span class="line"><span class="comment"> * 使用方法： 1、编译好原始的二进制bin文件，如，u-boot.bin等，并将编译好的.bin文件和本</span></span><br><span class="line"><span class="comment"> *             软件放置到同一个目录下！！！！</span></span><br><span class="line"><span class="comment"> *        2、执行命令sudo ./imxdownload &lt;soucre_bin&gt; &lt;sd_device&gt;</span></span><br><span class="line"><span class="comment"> *             如烧写u-boot.bin到/dev/sdd中即可使用如下所示命令:</span></span><br><span class="line"><span class="comment"> *             sudo ./imxdownload u-boot.bin /dev/sdd</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出一些信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">message_print</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I.MX6ULL bin download software\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Edit by:zuozhongkai\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Date:2019/6/10\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Version:V1.1\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;log:V1.0 initial version,just support 512MB DDR3\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    V1.1 and support 256MB DDR3\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *buf;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *cmdbuf;</span><br><span class="line"><span class="type">int</span> nbytes, filelen;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ddrsize = <span class="number">0</span>; <span class="comment">/* 0为512MB，1为256MB，2为128MB...... */</span></span><br><span class="line"></span><br><span class="line">message_print();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((argc != <span class="number">3</span>) &amp;&amp; (argc != <span class="number">4</span>))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error Usage! Reference Below:\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sudo ./%s &lt;-512m or -256m&gt; &lt;source_bin&gt; &lt;sd_device&gt;\r\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查找参数，获取DDR容量 */</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *param = argv[i];</span><br><span class="line"><span class="keyword">if</span>(param[<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(param, <span class="string">&quot;-256m&quot;</span>) == <span class="number">0</span>) <span class="comment">/* 256MB */</span></span><br><span class="line">ddrsize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(param, <span class="string">&quot;-512m&quot;</span>) == <span class="number">0</span>)<span class="comment">/* 512MB */</span></span><br><span class="line">ddrsize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(argc == <span class="number">3</span>)<span class="comment">/* 三个参数，也就是不输入DDR容量的话默认为512MB */</span></span><br><span class="line">ddrsize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打开bin文件 */</span></span><br><span class="line">fp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>); <span class="comment">/* 以二进制只读方式打开bin文件 */</span></span><br><span class="line"><span class="keyword">if</span>(fp == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t Open file %s\r\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取bin文件长度 */</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END);</span><br><span class="line">filelen = ftell(fp);</span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_SET);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;file %s size = %dBytes\r\n&quot;</span>, argv[<span class="number">1</span>], filelen);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取bin文件到缓冲区buf中 */</span></span><br><span class="line">buf = <span class="built_in">malloc</span>(filelen + BIN_OFFSET);</span><br><span class="line"><span class="keyword">if</span>(buf == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Mem Malloc Failed!\r\n&quot;</span>);</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, filelen + BIN_OFFSET); <span class="comment">/* 清零 */</span></span><br><span class="line"><span class="comment">/* 读取bin源码文件 */</span></span><br><span class="line">fread(buf + BIN_OFFSET, <span class="number">1</span>, filelen, fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭文件 */</span></span><br><span class="line">fclose(fp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PRINT_TAB</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;IVT DCD Table:\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1024</span>/<span class="number">32</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0X%08X,&quot;</span>,*(<span class="type">int</span> *)(buf + BIN_OFFSET + (((i * <span class="number">8</span>) + j) * <span class="number">4</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(buf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加IVT DCD等表信息到bin文件里面 */</span></span><br><span class="line"><span class="keyword">if</span>(ddrsize == <span class="number">0</span>) &#123;<span class="comment">/* 512MB */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Board DDR SIZE: 512MB\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(buf, imx6_512mb_ivtdcd_table, <span class="keyword">sizeof</span>(imx6_512mb_ivtdcd_table));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ddrsize == <span class="number">1</span>) &#123;<span class="comment">/* 256MB */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Board DDR SIZE: 256MB\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(buf, imx6_256mb_ivtdcd_table, <span class="keyword">sizeof</span>(imx6_256mb_ivtdcd_table));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 现在我们已经在buf中构建好了可以用于下载的bin文件，将buf中的数据保存到</span></span><br><span class="line"><span class="comment"> * 到一个文件中，文件命名为load.imx</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Delete Old load.imx\r\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;rm -rf load.imx&quot;</span>);<span class="comment">/* 先删除旧的load.imx文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create New load.imx\r\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;touch load.imx&quot;</span>);<span class="comment">/* 创建新的load.imx文件*/</span></span><br><span class="line">fp = fopen(<span class="string">&quot;load.imx&quot;</span>, <span class="string">&quot;wb&quot;</span>);<span class="comment">/* 打开laod.imx*/</span></span><br><span class="line"><span class="keyword">if</span>(fp == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Cant&#x27;t Open load.imx!!!\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(buf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">nbytes = fwrite(buf, <span class="number">1</span>, filelen + BIN_OFFSET, fp);</span><br><span class="line"><span class="keyword">if</span>(nbytes != (filelen + BIN_OFFSET))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;File Write Error!\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(buf);</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(buf);</span><br><span class="line">fclose(fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构建烧写的shell命令 */</span></span><br><span class="line">cmdbuf = <span class="built_in">malloc</span>(SHELLCMD_LEN);</span><br><span class="line"><span class="comment">//sprintf(cmdbuf, &quot;sudo dd iflag=dsync oflag=dsync if=load.imx of=%s bs=512 seek=2&quot;,argv[2]);</span></span><br><span class="line">    <span class="built_in">sprintf</span>(cmdbuf, <span class="string">&quot;dd iflag=dsync oflag=dsync if=load.imx of=%s bs=512 seek=2&quot;</span>,argv[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Download load.imx to %s  ......\r\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行上面的shell命令 */</span></span><br><span class="line">system(cmdbuf);</span><br><span class="line"><span class="built_in">free</span>(cmdbuf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/OnlyLove_/article/details/121843883">i.MX6ULL裸机开发 三：imxdownload 源码分析-CSDN博客</a></p></blockquote><h4 id="检查驱动">检查驱动</h4><p>检查 uboot 的驱动，一般是检查 SD 卡、EMMC、LCD、网络这几方面的驱动。根据下面检查后可知，NXP 官方I.MX6ULL EVK 开发板的 uboot 在 100ask 开发板的运行情况：</p><ul><li>uboot 启动正常，DRAM 识别正确，SD 卡和 EMMC 驱动正常。</li><li>uboot 默认 LCD 驱动是 4.3 寸 480*272 分辨率的，若使用其他屏幕需要修改参数。</li><li>网络不能工作，需要修改驱动。</li></ul><h5 id="sd-卡和-emmc-驱动检查">SD 卡和 EMMC 驱动检查</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mmc list// 列出当前的 MMC 设备</span><br><span class="line">mmc dev 0 // 转换到 MMC 设备 0</span><br><span class="line">mmc info// 打印 MMC 设备信息</span><br></pre></td></tr></table></figure><p><img src="/image-20240702154709026.png" alt="image-20240702154709026"></p><p>从打印信息看出，mmc 设备 0 是 SD 卡，容量为 942.5 MB，与我使用的 SD 卡相符，说明 SD 卡驱动正常。</p><p>检查 mmc 设备 1，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mmc list// 列出当前的 MMC 设备</span><br><span class="line">mmc dev 1 // 转换到 MMC 设备 1</span><br><span class="line">mmc info// 打印 MMC 设备信息</span><br></pre></td></tr></table></figure><p><img src="image-20240702155007588.png" alt="image-20240702155007588"></p><p>从打印信息看出，mmc 设备 1 是 EMMC 卡，容量为 3.6 GB，说明 EMMC 卡驱动正常。</p><h5 id="lcd-驱动检查">LCD 驱动检查</h5><p>由上面 uboot 启动信息可知，默认设置的 LCD 屏幕参数为 NXP 官方 I.MX6ULL 开发板的屏幕：4.3 寸 480x272 分辨率的，因此需要修改驱动。</p><p><img src="image-20240702155427332.png" alt="image-20240702155427332"></p><h5 id="网络驱动">网络驱动</h5><p>由上面 uboot 启动信息可知，网络驱动有问题，这是因为 100ask 开发板的网络芯片复位引脚和 NXP 官方开发板不一样，因此需要修改驱动。</p><h4 id="在-u-boot-中添加自己的开发板">在 U-Boot 中添加自己的开发板</h4><p>NXP 官方 uboot 中默认都是 NXP 自己的开发板，虽说我们可以直接在官方的开发板上直接修改，使 uboot 可以完整的运行在我们的板子上。但是为了学习更多东西，接下来学习如何在 uboot 中添加我们的开发板或开发平台。</p><h5 id="添加开发板默认配置文件">添加开发板默认配置文件</h5><p>在 uboot 源码下的 configs 目录下创建默认配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd configs</span><br><span class="line">cp mx6ull_14x14_evk_emmc_defconfig mx6ull_obito_emmc_defconfig</span><br></pre></td></tr></table></figure><p>对 CONFIG_SYS_EXTRA_OPTIONS 和 CONFIG_TARGET_ 修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SYS_EXTRA_OPTIONS=<span class="string">&quot;IMX_CONFIG=board/freescale/mx6ull_obito_emmc/imximage.cfg,MX6ULL_EVK_EMMC_REWORK&quot;</span> </span><br><span class="line">CONFIG_ARM=y</span><br><span class="line">CONFIG_ARCH_MX6=y</span><br><span class="line">CONFIG_TARGET_MX6ULL_OBITO_EMMC=y</span><br><span class="line">CONFIG_CMD_GPIO=y</span><br></pre></td></tr></table></figure><h5 id="添加开发板对应的头文件">添加开发板对应的头文件</h5><p>在 uboot 源码下的 include/configs 目录下添加自己开发板对应的头文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp include/configs/mx6ullevk.h include/configs/mx6ull_obito_emmc.h</span><br></pre></td></tr></table></figure><p>打开头文件修改宏定义：跟文件名相同，该文件主要是用来配置或裁剪 uboot。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改前</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MX6ULLEVK_CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MX6ULLEVK_CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MX6ULL_OBITO_EMMC_CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MX6ULL_OBITO_EMMC_CONFIG_H</span></span><br></pre></td></tr></table></figure><h5 id="添加开发板对应的板级文件夹">添加开发板对应的板级文件夹</h5><p><strong>uboot 中每个板子都有一个对应的文件夹来存放板级文件</strong>，比如开发板上外设驱动文件等等。NXP 的 <a href="http://I.MX">I.MX</a> 系列芯片的所有板级文件夹都存放在 board/freescale 目录下，在这个目录下有个名为 mx6ullevk 的文件夹，这个文件夹就是 NXP 官方 I.MX6ULL EVK 开发板的板级文件夹。复制 mx6ullevk，将其重命名为自己开发板的名字 mx6ull_obito_emmc，命令如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd board/freescale/</span><br><span class="line">cp mx6ullevk/ -r mx6ull_obito_emmc</span><br></pre></td></tr></table></figure><p>文件夹下有以下文件：</p><p><img src="image-20240702204622788.png" alt="image-20240702204622788"></p><p>输入命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -nr <span class="string">&quot;mx6ullevk&quot;</span></span><br></pre></td></tr></table></figure><p><img src="image-20240702204827826.png" alt="image-20240702204827826"></p><p>除了 ixmimage_lpddr2.cfg 文件我们将其他文件中的 mx6ullevk 字符串转换成自己给板子起的名字：我的是 <code>mx6ull_obito_emmc</code>，然后打开 Kconfig 文件进行修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改前</span></span><br><span class="line"><span class="keyword">if</span> TARGET_MX6ULL_14X14_EVK || TARGET_MX6ULL_9X9_EVK</span><br><span class="line"></span><br><span class="line">config SYS_BOARD</span><br><span class="line"><span class="keyword">default</span> <span class="string">&quot;mx6ullevk&quot;</span></span><br><span class="line"></span><br><span class="line">config SYS_VENDOR</span><br><span class="line"><span class="keyword">default</span> <span class="string">&quot;freescale&quot;</span></span><br><span class="line"></span><br><span class="line">config SYS_CONFIG_NAME</span><br><span class="line"><span class="keyword">default</span> <span class="string">&quot;mx6ullevk&quot;</span></span><br><span class="line"></span><br><span class="line">endif</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line"><span class="keyword">if</span> TARGET_MX6ULL_OBITO_EMMC</span><br><span class="line"></span><br><span class="line">config SYS_BOARD</span><br><span class="line"><span class="keyword">default</span> <span class="string">&quot;mx6ull_obito_emmc&quot;</span></span><br><span class="line"></span><br><span class="line">config SYS_VENDOR</span><br><span class="line"><span class="keyword">default</span> <span class="string">&quot;freescale&quot;</span></span><br><span class="line"></span><br><span class="line">config SYS_SOC</span><br><span class="line"><span class="keyword">default</span> <span class="string">&quot;mx6&quot;</span></span><br><span class="line"></span><br><span class="line">config SYS_CONFIG_NAME</span><br><span class="line"><span class="keyword">default</span> <span class="string">&quot;mx6ull_obito_emmc&quot;</span></span><br><span class="line"></span><br><span class="line">endif    </span><br></pre></td></tr></table></figure><h5 id="修改-u-boot-图形界面配置文件">修改 U-Boot 图形界面配置文件</h5><p>修改文件 arch/arm/cpu/armv7/mx6/Kconfig，在 207 行添加如下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config TARGET_MX6ULL_OBITO_EMMC</span><br><span class="line">    <span class="type">bool</span> <span class="string">&quot;Support mx6ull_obito_emmc&quot;</span></span><br><span class="line">    select MX6ULL</span><br><span class="line">    select DM</span><br><span class="line">    select DM_THERMAL</span><br></pre></td></tr></table></figure><p>在最后一行的 #endif 的前一行添加如下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">&quot;board/freescale/mx6ull_obito_emmc/Kconfig&quot;</span></span><br></pre></td></tr></table></figure><p><img src="image-20240702210111971.png" alt="image-20240702210111971"></p><h5 id="编译新的-u-boot-测试">编译新的 U-Boot 测试</h5><p>uboot 源码根目录下新建默认配置文件： <code>mx6ull_obito_emmc_defconfig</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-buildroot-linux-gnueabihf- distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-buildroot-linux-gnueabihf- mx6ull_obito_emmc_defconfig</span><br><span class="line">make V=1 ARCH=arm CROSS_COMPILE=arm-buildroot-linux-gnueabihf- -j16</span><br></pre></td></tr></table></figure><p>修改权限并执行脚本文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 mx6ull_obito_emmc.sh //给予可执行权限，一次即可</span><br><span class="line">./mx6ull_obito_emmc.sh //运行脚本编译uboot</span><br></pre></td></tr></table></figure><p>新建默认配置文件是为了方便后续修改编译 uboot，编译成功后显示：</p><p><img src="image-20240702210559495.png" alt="image-20240702210559495"></p><h5 id="修改-lcd-驱动">修改 LCD 驱动</h5><p>修改 LCD 驱动一般注意几点：</p><ul><li>LCD 所使用的 GPIO，查看 uboot 中 LCD 的 IO 配置是否正确。</li><li>LCD 背光引脚 GPIO 的配置。</li><li>LCD 配置参数是否正确。</li></ul><p>100ask 开发板 LCD 原理图和 NXP 官方I.MX6ULL 开发板一致，也就是 LCD 的 IO 和背光 IO 都一样的，所以 IO 部分就不用修改了。只需要修改 LCD 配置参数即可。</p><p>打开之前新建的板级文件夹 board/freescale/mx6ull_obito_emmc，找到 <code>display_info_t</code> 结构体，修改 LCD 参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改前</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">display_info_t</span> <span class="title">const</span> <span class="title">displays</span>[] =</span> &#123;&#123;</span><br><span class="line">        .bus = MX6UL_LCDIF1_BASE_ADDR,</span><br><span class="line">        .addr = <span class="number">0</span>,</span><br><span class="line">        .pixfmt = <span class="number">24</span>,</span><br><span class="line">        .detect = <span class="literal">NULL</span>,</span><br><span class="line">        .enable = do_enable_parallel_lcd,</span><br><span class="line">        .mode   = &#123;</span><br><span class="line">                .name                   = <span class="string">&quot;TFT43AB&quot;</span>,</span><br><span class="line">                .xres           = <span class="number">480</span>,</span><br><span class="line">                .yres           = <span class="number">272</span>,</span><br><span class="line">                .pixclock       = <span class="number">108695</span>,</span><br><span class="line">                .left_margin    = <span class="number">8</span>,</span><br><span class="line">                .right_margin   = <span class="number">4</span>,</span><br><span class="line">                .upper_margin   = <span class="number">2</span>,</span><br><span class="line">                .lower_margin   = <span class="number">4</span>,</span><br><span class="line">                .hsync_len      = <span class="number">41</span>,             </span><br><span class="line">                .vsync_len      = <span class="number">10</span>,</span><br><span class="line">                .sync           = <span class="number">0</span>,</span><br><span class="line">                .vmode          = FB_VMODE_NONINTERLACED</span><br><span class="line">&#125; &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">display_info_t</span> <span class="title">const</span> <span class="title">displays</span>[] =</span> &#123;&#123;</span><br><span class="line">        .bus = MX6UL_LCDIF1_BASE_ADDR,</span><br><span class="line">        .addr = <span class="number">0</span>,</span><br><span class="line">        .pixfmt = <span class="number">24</span>,</span><br><span class="line">        .detect = <span class="literal">NULL</span>,</span><br><span class="line">        .enable = do_enable_parallel_lcd,</span><br><span class="line">        .mode   = &#123;</span><br><span class="line">              .name = <span class="string">&quot;TFT7016&quot;</span>,</span><br><span class="line">                .xres = <span class="number">1024</span>,</span><br><span class="line">                .yres = <span class="number">600</span>,</span><br><span class="line">                .pixclock = <span class="number">19531</span>,</span><br><span class="line">                .left_margin = <span class="number">140</span>, <span class="comment">//HBPD</span></span><br><span class="line">                .right_margin = <span class="number">160</span>, <span class="comment">//HFPD</span></span><br><span class="line">                .upper_margin = <span class="number">20</span>, <span class="comment">//VBPD</span></span><br><span class="line">                .lower_margin = <span class="number">12</span>, <span class="comment">//VFBD</span></span><br><span class="line">                .hsync_len = <span class="number">20</span>, <span class="comment">//HSPW</span></span><br><span class="line">                .vsync_len = <span class="number">3</span>, <span class="comment">//VSPW</span></span><br><span class="line">                .sync = <span class="number">0</span>,</span><br><span class="line">                .vmode = FB_VMODE_NONINTERLACED</span><br><span class="line">&#125; &#125; &#125;;</span><br></pre></td></tr></table></figure><p>打开开发板对应的头文件：include/configs/mx6ull_obito_emmc.h</p><p>将 panel=TFT43AB 全部修改为 panel=TFT7016，panel 的值要与 <code>display_info_t</code> 结构体的 .name 一致。</p><h5 id="修改有线网络驱动">修改有线网络驱动</h5><p>我们要修改ENET1 网络驱动的话重点就三点：<br>①、ENET1 复位引脚初始化。<br>②、LAN8720A 的器件ID。<br>③、LAN8720 驱动</p><p>IMX6ULL有两个网络外设，分别为ENET1和ENET2，100ask开发板使用LAN8720A作为PHY芯片，接在了ENET2上，LAN8720A芯片有一个地址引脚，RXER/PHYAD0，在开发板上接到了高电平，所以 LAN8720A 的网络PHY地址为1，RESET引脚接在了SNVS_TAMPER6上，由于PHY网络芯片有规定，所有PHY芯片前16个寄存器都是一样的功能，并且使用这16个寄存器就可以让网络正常工作，所以需要修改三个地方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMD_NET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_CMD_PING</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_CMD_DHCP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_CMD_MII</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_FEC_MXC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_MII</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_FEC_ENET_DEV1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (CONFIG_FEC_ENET_DEV == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX_FEC_BASEENET_BASE_ADDR</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_FEC_MXC_PHYADDR          0x2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_FEC_XCV_TYPE             RMII</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> (CONFIG_FEC_ENET_DEV == 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX_FEC_BASEENET2_BASE_ADDR</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_FEC_MXC_PHYADDR0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_FEC_XCV_TYPERMII</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_ETHPRIME<span class="string">&quot;FEC&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_PHYLIB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_PHY_MICREL</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>setenv ipaddr 192.168.1.7 <br>setenv ethaddr 00:04:9f:04:d2:35<br>setenv gatewayip 192.168.1.1 <br>setenv netmask 255.255.255.0 <br>setenv serverip 192.168.1.5 <br>saveenv</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setenv ipaddr 192.168.1.7 //开发板IP地址</span><br><span class="line">setenv ethaddr 00:04:9f:04:d2:35 //开发板网卡MAC地址</span><br><span class="line">setenv gatewayip 192.168.1.1 //开发板默认网关</span><br><span class="line">setenv netmask 255.255.255.0 //开发板子网掩码</span><br><span class="line">setenv serverip 192.168.1.5 //服务器地址，也就是Ubuntu 地址</span><br><span class="line">saveenv //保存环境变量</span><br></pre></td></tr></table></figure><p>注意！只能在uboot 中ping 其他的机器，其他机器不能ping uboot，因为uboot 没有对ping<br>命令做处理，如果用其他的机器ping uboot 的话会失败！</p><h5 id="再次编译烧录-u-boot">再次编译烧录 U-Boot</h5><p>uboot 启动以后会先从 EMMC 中读取环境变量，如果 EMMC 中没有环境变量的话才会使用 <code>mx6ull_obito_emmc.h</code> 的默认环境变量。</p><p>在 uboot 命令模式下输入如下命令修改环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv panel TFT7016</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>保存重启 uboot，LCD 驱动就能工作正常了。</p><h3 id="u-boot-一些重要的环境变量">U-Boot 一些重要的环境变量</h3><h4 id="bootcmd-环境变量">bootcmd 环境变量</h4><p>bootcmd 保存 U-Boot 启动时执行的的命令序列，一般用来启动内核和加载文件系统，比如读取 EMMC 或者 NAND Flash 中的 Linux 内核镜像文件和设备树文件到 DRAM 中，然后启动 Linux 内核。若 EMMC 或者 NAND 中没有保存 bootcmd 的值，则 uboot 就会从 <code>include/env_default.h</code> 文件中读取 bootcmd 的默认值。</p><p>例如 uboot 使用 run 命令来运行 findfdt 变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define CONFIG_BOOTCOMMAND \</span></span><br><span class="line"><span class="language-bash">           <span class="string">&quot;run findfdt;&quot;</span> \</span></span><br><span class="line"><span class="language-bash">           <span class="string">&quot;mmc dev <span class="variable">$&#123;mmcdev&#125;</span>;&quot;</span> \</span></span><br><span class="line"><span class="language-bash">           <span class="string">&quot;mmc dev <span class="variable">$&#123;mmcdev&#125;</span>; if mmc rescan; then &quot;</span> \</span></span><br><span class="line"><span class="language-bash">                   <span class="string">&quot;if run loadbootscript; then &quot;</span> \</span></span><br><span class="line"><span class="language-bash">                           <span class="string">&quot;run bootscript; &quot;</span> \</span></span><br><span class="line"><span class="language-bash">                   <span class="string">&quot;else &quot;</span> \</span></span><br><span class="line"><span class="language-bash">                           <span class="string">&quot;if run loadimage; then &quot;</span> \</span></span><br><span class="line"><span class="language-bash">                                   <span class="string">&quot;run mmcboot; &quot;</span> \</span></span><br><span class="line"><span class="language-bash">                           <span class="string">&quot;else run netboot; &quot;</span> \</span></span><br><span class="line"><span class="language-bash">                           <span class="string">&quot;fi; &quot;</span> \</span></span><br><span class="line"><span class="language-bash">                   <span class="string">&quot;fi; &quot;</span> \</span></span><br><span class="line"><span class="language-bash">           <span class="string">&quot;else run netboot; fi&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">endif</span></span><br></pre></td></tr></table></figure><p>findfdt 是 NXP 自行添加的环境变量，用来<strong>查找开发板对应的设备树文件</strong>，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;findfdt=&quot;\</span><br><span class="line">        &quot;if test $fdt_file = undefined; then &quot; \</span><br><span class="line">                &quot;if test $board_name = EVK &amp;&amp; test $board_rev = 9X9; then &quot; \</span><br><span class="line">                        &quot;setenv fdt_file imx6ull-9x9-evk.dtb; fi; &quot; \</span><br><span class="line">                &quot;if test $board_name = EVK &amp;&amp; test $board_rev = 14X14; then &quot; \</span><br><span class="line">                        &quot;setenv fdt_file imx6ull-14x14-evk.dtb; fi; &quot; \</span><br><span class="line">                &quot;if test $fdt_file = undefined; then &quot; \</span><br><span class="line">                        &quot;echo WARNING: Could not determine dtb to use; fi; &quot; \</span><br><span class="line">        &quot;fi;\0&quot; \</span><br></pre></td></tr></table></figure><ul><li>mmc dev ${mmcdev} 用于切换 mmc 设备，mmcdev 为 1，<code>mmc dev 1</code> 切换到 EMMC 上。</li><li>mmc rescan 扫描看有没有 SD 卡或者 EMMC 存在</li><li>mmc 设备存在的话则运行 loadbootscript 环境变量：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadbootscript=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;loadaddr&#125; $&#123;script&#125;;</span><br></pre></td></tr></table></figure><p>mmcdev = 1，mmcpart = 1，loadaddr = 0x80800000，script = boot.scr，展开就是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadbootscript=fatload mmc 1:1 0x80800000 boot.scr;</span><br></pre></td></tr></table></figure><p>loadbootscript 就是从 mmc1 的分区 1 中读取文件 boot.src 到 DRAM 的 0X80800000 处，加载成功则运行 bootscript 环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bootscript=echo Running bootscript from mmc ...;</span><br><span class="line">source</span><br></pre></td></tr></table></figure><p>如果 loadbootscript 没有找到 boot.src 则运行环境变量 loadimage：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadimage=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;loadaddr&#125; $&#123;image&#125;</span><br></pre></td></tr></table></figure><p>mmcdev=1，mmcpart=1，loadaddr=0x80800000，image = zImage，展开就是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadimage=fatload mmc 1:1 0x80800000 zImage</span><br></pre></td></tr></table></figure><p>loadimage 就是从 mmc1 的分区中读取 zImage 到内存的 0X80800000 处，加载 linux 镜像文件 zImage 成功就运行环境变量 mmcboot：mmcargs 是用来设置 bootargs 环境变量的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot;mmcboot=echo Booting from mmc ...; &quot; \</span><br><span class="line">               &quot;run mmcargs; &quot; \</span><br><span class="line">               &quot;if test $&#123;boot_fdt&#125; = yes || test $&#123;boot_fdt&#125; = try; then &quot; \</span><br><span class="line">                       &quot;if run loadfdt; then &quot; \</span><br><span class="line">                               &quot;bootz $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;; &quot; \</span><br><span class="line">                       &quot;else &quot; \</span><br><span class="line">                               &quot;if test $&#123;boot_fdt&#125; = try; then &quot; \</span><br><span class="line">                                       &quot;bootz; &quot; \</span><br><span class="line">                               &quot;else &quot; \</span><br><span class="line">                                       &quot;echo WARN: Cannot load the DT; &quot; \</span><br><span class="line">                               &quot;fi; &quot; \</span><br><span class="line">                       &quot;fi; &quot; \</span><br><span class="line">               &quot;else &quot; \</span><br><span class="line">                       &quot;bootz; &quot; \</span><br><span class="line">               &quot;fi;\0&quot; \</span><br></pre></td></tr></table></figure><p>环境变量 loadfdt：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadfdt=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;fdt_addr&#125; $&#123;fdt_file&#125;</span><br></pre></td></tr></table></figure><p>展开就是：从mmc1 的分区 1 中读取 imx6ull-14x14-evk.dtb 文件并放到内存的 0x83000000 处d</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadfdt=fatload mmc 1:1 0x83000000 imx6ull-14x14-evk.dtb</span><br></pre></td></tr></table></figure><p>读取设备树文件成功则调用命令 bootz 启动 linux：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootz $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;</span><br></pre></td></tr></table></figure><p>展开就是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootz 0x80800000 - 0x83000000 (注意‘-’前后要有空格)</span><br></pre></td></tr></table></figure><p>**至此 Linux 内核启动完毕，分析可知步骤如下：**4 行精华</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mmc dev 1 // 切换到EMMC</span><br><span class="line">fatload mmc 1:1 0x80800000 zImage // 读取 zImage到 0x80800000 处</span><br><span class="line">fatload mmc 1:1 0x83000000 imx6ull-14x14-evk.dtb // 读取设备树到 0x83000000 处</span><br><span class="line">bootz 0x80800000 - 0x83000000 // 启动Linux</span><br></pre></td></tr></table></figure><p>NXP 官方将 CONFIG_BOOTCOMMAND 写复杂是为了兼容多个板子，当我们明确找到自己所使用的板子就可以简化为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define CONFIG_BOOTCOMMAND \</span></span><br><span class="line"><span class="language-bash">    <span class="string">&quot;mmc dev 1;&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    <span class="string">&quot;fatload mmc 1:1 0x80800000 zImage;&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    <span class="string">&quot;fatload mmc 1:1 0x83000000 imx6ull-14x14-evk.dtb;&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    <span class="string">&quot;bootz 0x80800000 - 0x83000000;&quot;</span></span></span><br></pre></td></tr></table></figure><p>或者可以直接在 uboot 启动时设置 bootcmd 的值，这个值是直接保存到 EMMC 中的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv bootcmd &#x27;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-14x14-evk.dtb; bootz 80800000 - 83000000;&#x27;</span><br></pre></td></tr></table></figure><h4 id="bootargs-环境变量">bootargs 环境变量</h4><p>bootargs 保存 uboot 传递给 linux 内核的参数，这些参数可以控制内核的启动行为，例如内存设置、控制台配置、文件系统类型等。</p><p>bootargs 环境变量是由 mmcargs 设置的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmcargs=setenv bootargs console=$&#123;console&#125;,$&#123;baudrate&#125; root=$&#123;mmcroot&#125;</span><br></pre></td></tr></table></figure><p>console=ttymxc0，baudrate=115200，mmcroot=/dev/mmcblk1p2 rootwait rw，展开就是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmcargs=setenv bootargs console=ttymxc0, 115200 root=/dev/mmcblk1p2 rootwait rw</span><br></pre></td></tr></table></figure><ul><li>console=ttymxc0, 115200：设置 ttymxc0（串口 1）作为 linux 终端，波特率为 115200。</li><li>root=/dev/mmcblk1p2 rootwait rw：表示根文件系统存放在 mmcblk1 设备的分区 2 中，rootwait rw 表示等待 mmc 设备初始化完成以后再挂载，rw 表示根文件系统可以读写。</li></ul><p>bootargs 就是设置了很多的参数的值，给 linux 内核用，常用参数有：</p><ul><li>console：linux 终端，也叫控制台，一般 uboot 默认都有设置串口作为 linux 终端，这样就可以通过串口在 PC 机使用终端软件进行交互了。设置 console 为 ttymxc0，这是因为 linux 启动后 开发板串口 1 在 linux 下的设备文件就是 /dev/ttymxc0。</li><li>root 用来设置根文件系统的位置。</li><li>rootfstype 用于指定根文件系统类型，若根文件子系统为 ext 格式，则不用设置。</li></ul><h3 id="u-boot-启动-linux-测试">U-Boot 启动 Linux 测试</h3><h4 id="网络启动">网络启动</h4><p>网络启动系统主要是为了方便测试，不用频繁地烧写 EMMC，加快开发速度。一般使用 tftp 服务加载 zImage 和 dtb 文件，设置 bootcmd 和 bootargs 环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span><br><span class="line"></span><br><span class="line">setenv bootcmd &#x27;tftp 80800000 zImage; tftp 83000000 100ask_imx6ull-14x14.dtb; bootz</span><br><span class="line">80800000 - 83000000&#x27;</span><br><span class="line"></span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><h4 id="emmc-启动">EMMC 启动</h4><p>EMMC 启动的话，需要向 EMMC 分区提前存放已知好的 zImage 和 dtb 文件，然后设置 bootcmd 和 bootargs 环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span><br><span class="line"></span><br><span class="line">setenv bootcmd &#x27;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000</span><br><span class="line">100ask_imx6ull-14x14.dtb; bootz 80800000 - 83000000;&#x27;</span><br><span class="line"></span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><h2 id="linux-内核移植">Linux 内核移植</h2><p><em><strong>一开始用的 4.1.15 版本，后面发现 100ask 交叉编译器支持不了该版本，导致根文件系统挂载时，内核崩溃，后改用 4.9.88 版本，这些 Linux 源码都是 NXP 改版适配后的源码。</strong></em></p><blockquote><p><a href="https://github.com/nxp-imx/linux-imx/tree/imx_4.9.88_2.0.0_ga">nxp-imx/linux-imx at imx_4.9.88_2.0.0_ga (github.com)</a></p></blockquote><p>该版本下没有带 mfg 的 imx_v7_mfg_defconfig 文件，只有 imx_v7_defconfig 文件。</p><h3 id="编译-nxp-官方开发板的-linux-内核">编译 NXP 官方开发板的 Linux 内核</h3><h4 id="编译测试">编译测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-buildroot-linux-gnueabihf- imx_v7_defconfig // 配置linux内核</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-buildroot-linux-gnueabihf- -j16</span><br></pre></td></tr></table></figure><p>编译完成后会在 <code>arch/arm/boot</code> 目录下生成 zImage 镜像文件，如果使用设备树的话还会在 <code>arh/arm/boot/dts</code> 目录下生成开发板对应的设备树文件。</p><ul><li>Linux 内核镜像文件：zImage</li><li>设备树文件：imx6ull-14x14-evk.dtb</li></ul><p>将两个文件复制到 Ubuntu 的 tftp 目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp arch/arm/boot/zImage ~/tftpboot/</span><br><span class="line">cp arch/arm/boot/dts/imx6ull-14x14-evk.dtb  ~/tftpboot/</span><br></pre></td></tr></table></figure><p>uboot 命令行模式下使用 tftp 加载 zImage 和 imx6ull-14x14-evk.dtb</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tftp 80800000 zImage</span><br><span class="line">tftp 83000000 imx6ull-14x14-evk.dtb</span><br><span class="line">bootz 80800000 - 83000000</span><br></pre></td></tr></table></figure><p>因为还没有根文件系统，所以会显示以下信息并卡住——Linux 内核崩溃，重启进入 uboot 即可。</p><p><img src="image-20240704163256225.png" alt="image-20240704163256225"></p><blockquote><p>也就是提示内核崩溃，因为 VFS(虚拟文件系统)不能挂载根文件系统，因为根文件系统目录不存在。即使根文件系统目录存在，如果根文件系统目录里面是空的依旧会提示内核崩溃。这个就是根文件系统缺失导致的内核崩溃，但是内核是启动了的，只是根文件系统不存在而已。</p></blockquote><h3 id="添加自己的开发板">添加自己的开发板</h3><h4 id="添加开发板默认配置文件">添加开发板默认配置文件</h4><p>复制 imx_v7_defconfig 文件重新命名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd arch/arm/configs</span><br><span class="line">cp imx_v7_defconfig imx_obito_emmc_defconfig</span><br></pre></td></tr></table></figure><h4 id="添加开发板对应的设备树文件">添加开发板对应的设备树文件</h4><p>复制 imx6ull-14x14-evk.dts 文件重新命名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd arch/arm/boot/dts</span><br><span class="line">cp imx6ull-14x14-evk.dts imx6ull-obito-emmc.dts</span><br></pre></td></tr></table></figure><p>.dts 是设备树源码，编译后变为 .dtb 文件，因此需要在 <code>arch/arm/boot/dts/Makefile</code> 找到 <code>dtb- $(CONFIG_SOC_IMX6ULL)</code> 配置项，在此配置项中加入 <code>imx6ull-obito-emmc.dtb</code></p><h4 id="编译测试">编译测试</h4><p>放了方便调试，新建一个编译脚本文件 <code>imx6ull_obito_emmc.sh</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-buildroot-linux-gnueabihf- distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-buildroot-linux-gnueabihf- imx_obito_emmc_defconfig</span><br><span class="line">make V=1 ARCH=arm CROSS_COMPILE=arm-buildroot-linux-gnueabihf- -j16</span><br></pre></td></tr></table></figure><p>添加权限后执行脚本文件编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 imx6ull_obito_emmc.sh</span><br><span class="line">./imx6ull_obito_emmc.sh</span><br></pre></td></tr></table></figure><p>将编译生成 zImage 和设备树复制到 tftp 目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp arch/arm/boot/zImage ~/tftpboot/</span><br><span class="line">cp arch/arm/boot/dts/imx6ull-obito-emmc.dtb ~/tftpboot/</span><br></pre></td></tr></table></figure><p>使用 tftp 加载 zImage 和 设备树</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tftp 80800000 zImage</span><br><span class="line">tftp 83000000 imx6ull-obito-emmc.dtb</span><br><span class="line">bootz 80800000 - 83000000</span><br></pre></td></tr></table></figure><p>启动成功说明已经成功在 NXP 提供的 Linux 内核源码添加了自己的开发板。同样因为还没有根文件系统，重启进入 uboot 即可。</p><h3 id="修改驱动">修改驱动</h3><h4 id="cpu-主频">CPU 主频</h4><p>CPU 主频这里不作修改，可以使用 make menuconfig 进入 Linux 内核图形化界面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPU Power Management</span><br><span class="line">    -&gt; CPU Frequency scaling</span><br><span class="line">    -&gt; Default CPUFreq governor</span><br></pre></td></tr></table></figure><p>CPU 支持 198MHz、396MHz、528MHz 和 792MHz 四个模式：</p><ul><li>Performance：最高性能，直接用最高频率，不考虑耗电。</li><li>Interactive：一开始直接用最高频率，然后根据 CPU 负载慢慢降低。</li><li>Powersave：省电模式，通常以最低频率运行，系统性能会受影响，一般不会用这个！</li><li>Userspace：可以在用户空间手动调节频率。</li><li>Ondemand：定时检查负载，然后根据负载来调节频率。负载低的时候降低 CPU 频率，这样省电，负载高的时候提高 CPU 频率，增加性能。</li></ul><h4 id="修改-emmc-驱动">修改 EMMC 驱动</h4><p>由开发板核心板原理图可知用到的 EMMC 采用 8 根数据线，而 Linux 内核驱动里面 EMMC 默认是 4 线模式，这样 EMMC 读写速度会慢很多，而我们只需要修改设备树 <code> imx6ull-obito-emmc.dts</code> 即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 修改前</span><br><span class="line">&amp;usdhc2 &#123;</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_usdhc2&gt;;</span><br><span class="line">non-removable;</span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 修改后</span><br><span class="line">&amp;usdhc2 &#123;</span><br><span class="line">pinctrl-names = &quot;default&quot;, &quot;state_100mhz&quot;, &quot;state_200mhz&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_usdhc2_8bit&gt;;</span><br><span class="line">pinctrl-1 = &lt;&amp;pinctrl_usdhc2_8bit_100mhz&gt;;</span><br><span class="line">pinctrl-2 = &lt;&amp;pinctrl_usdhc2_8bit_200mhz&gt;;</span><br><span class="line">bus-width = &lt;8&gt;;</span><br><span class="line">non-removable;</span><br><span class="line">no-1-8-v;</span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>bus-width = &lt;8&gt;：表示 8 根线</li><li>no-1-8-v：关闭EMMC 1.8 V 供电选项，防止内核运行时用 1.8 V 去驱动 EMMC</li></ul><h4 id="修改网络驱动">修改网络驱动</h4><blockquote><p><strong>为什么 uboot 有网络驱动了，还要修改内核的网络驱动呢？</strong></p><p>uboot 的网络驱动主要用于实现网络启动(BOOTP 或 DHCP 协议)或通过 TFTP 等协议进行文件的传输，驱动相对简单，目的在于方便调试之类的。</p><p>内核的网络驱动复杂，支持各种网络协议（TCP/IP、Ethernet、Wi-Fi 等），需要处理完整的网络堆栈和多种网络硬件。</p></blockquote><h5 id="添加复位引脚">添加复位引脚</h5><p>由于 PHY 芯片不同，由前面移植 uboot 时可知修改网络驱动主要是在设备树添加 PHY 芯片的复位引脚，</p><p>添在 iomuxc_sncs 节点下添加<strong>网络复位引脚</strong>信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加网络复位引脚</span></span><br><span class="line">pinctrl_enet_reset: enetresetgrp &#123;</span><br><span class="line">            fsl,pins = &lt;</span><br><span class="line">                MX6ULL_PAD_SNVS_TAMPER9__GPIO5_IO09     <span class="number">0x1b0b0</span> <span class="comment">/* enet1 reset */</span></span><br><span class="line">                MX6ULL_PAD_SNVS_TAMPER6__GPIO5_IO06     <span class="number">0x1b0b0</span> <span class="comment">/* enet2 reset */</span></span><br><span class="line">            &gt;;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>正点原子教程中还修改了网络时钟引脚配置信息，将 <code>MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2</code> 和 <code>MX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 </code>的值从默认值 0x4001b031 修改为 0x4001b009，但是我看 100ask 提供的设备树是没有修改默认值的，而是将 pinctrl_enet1节点的内容放到 pinctrl_enet2 中。</p><h5 id="修改-fec1-和-fec2-节点">修改 fec1 和 fec2 节点</h5><p>修改 fec1 节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改前</span></span><br><span class="line">&amp;fec1 &#123;</span><br><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_enet1&gt;;</span><br><span class="line">phy-mode = <span class="string">&quot;rmii&quot;</span>;</span><br><span class="line">phy-handle = &lt;&amp;ethphy0&gt;;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;fec2 &#123;</span><br><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_enet2&gt;;</span><br><span class="line">phy-mode = <span class="string">&quot;rmii&quot;</span>;</span><br><span class="line">phy-handle = &lt;&amp;ethphy1&gt;;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">mdio &#123;</span><br><span class="line"><span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">ethphy0: ethernet-phy@<span class="number">2</span> &#123;</span><br><span class="line">compatible = <span class="string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ethphy1: ethernet-phy@<span class="number">1</span> &#123;</span><br><span class="line">compatible = <span class="string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&amp;fec1 &#123;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_enet1&gt;;</span><br><span class="line">    phy-mode = <span class="string">&quot;rmii&quot;</span>;</span><br><span class="line">    phy-handle = &lt;&amp;ethphy0&gt;;</span><br><span class="line">    phy-reset-gpios = &lt;&amp;gpio5 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    phy-reset-duration = &lt;<span class="number">26</span>&gt;;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line">&amp;fec2 &#123;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_enet2&gt;;</span><br><span class="line">    phy-mode = <span class="string">&quot;rmii&quot;</span>;</span><br><span class="line">    phy-handle = &lt;&amp;ethphy1&gt;;</span><br><span class="line">    phy-reset-gpios = &lt;&amp;gpio5 <span class="number">6</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    phy-reset-duration = &lt;<span class="number">26</span>&gt;;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">    mdio &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">        ethphy0: ethernet-phy@<span class="number">0</span> &#123;</span><br><span class="line">            compatible = <span class="string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;</span><br><span class="line">            smsc,disable-energy-detect;</span><br><span class="line">            reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">        ethphy1: ethernet-phy@<span class="number">1</span> &#123;</span><br><span class="line">            compatible = <span class="string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;</span><br><span class="line">            smsc,disable-energy-detect;</span><br><span class="line">            reg = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>phy-reset-duration = &lt;26&gt;：复位低电平信号持续时间为 26 ms</li><li>smsc,disable-energy-detect：表示 PHY 芯片是 SMSC 公司的，Linux 内核通过此信息找到对应 PHY 芯片驱动来驱动 LAN8720A</li><li>ethernet-phy@：后面数字表示 PHY 的地址</li><li>reg：PHY 的地址</li></ul><h5 id="配置-linux-内核-使能-lan8720-驱动">配置 Linux 内核，使能 LAN8720 驱动</h5><p>Linux 内核已经有多个 PHY 芯片的驱动了，但默认是不编译的，我们用到的是 LAN8720A（SMSC 公司的），因此我们输入 make menuconfig 进入 Linux 图形界面配置使能 LAN8720 驱动，按以下路径进入找到并选择使能 SMSC PHY 芯片驱动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">-&gt; Network device support</span><br><span class="line">-&gt; PHY Device support and infrastructure</span><br><span class="line">-&gt; Drivers for SMSC PHYs</span><br></pre></td></tr></table></figure><h2 id="根文件系统构建">根文件系统构建</h2><h3 id="根文件系统概述">根文件系统概述</h3><p>根文件系统是 Linux 内核启动以后挂载(mount)的第一个文件系统，然后从根文件系统中读取初始化脚本，比如 rcS，inittab 等。</p><p>Linux操作系统的根目录（通常表示为&quot;/&quot;）是文件系统的最顶层目录，它包含了所有其他目录和文件。以下是一些常见的根目录下子目录及其一般用途的解释：</p><table><thead><tr><th style="text-align:center">目录</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><strong>/bin</strong></td><td style="text-align:center">存放系统命令的二进制文件，比如<code>ls</code>、<code>cp</code>等</td></tr><tr><td style="text-align:center"><strong>/boot</strong></td><td style="text-align:center">包含启动 Linux 系统所需的文件，如内核和引导加载程序。</td></tr><tr><td style="text-align:center"><strong>/dev</strong></td><td style="text-align:center">包含设备文件，这些文件代表计算机上的硬件设备。</td></tr><tr><td style="text-align:center"><strong>/etc</strong></td><td style="text-align:center">存放系统配置文件，比如网络配置、服务配置等。</td></tr><tr><td style="text-align:center"><strong>/home</strong></td><td style="text-align:center">用户的个人目录，每个用户都有一个以用户名命名的子目录。</td></tr><tr><td style="text-align:center"><strong>/lib</strong></td><td style="text-align:center">存放系统库文件，这些是程序运行时需要的共享代码。</td></tr><tr><td style="text-align:center"><strong>/media</strong></td><td style="text-align:center">用于自动挂载可移动设备，如 USB 驱动器。</td></tr><tr><td style="text-align:center"><strong>/mnt</strong></td><td style="text-align:center">用于临时挂载文件系统。</td></tr><tr><td style="text-align:center"><strong>/opt</strong></td><td style="text-align:center">用于存放第三方软件包。</td></tr><tr><td style="text-align:center"><strong>/proc</strong></td><td style="text-align:center">虚拟文件系统，包含系统和进程信息，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件。</td></tr><tr><td style="text-align:center"><strong>/root</strong></td><td style="text-align:center">系统管理员（root 用户）的家目录。</td></tr><tr><td style="text-align:center"><strong>/sbin</strong></td><td style="text-align:center">存放系统管理命令的二进制文件，通常只有 root 用户才能访问。</td></tr><tr><td style="text-align:center"><strong>/srv</strong></td><td style="text-align:center">存放系统服务的数据。</td></tr><tr><td style="text-align:center"><strong>/tmp</strong></td><td style="text-align:center">存放临时文件。</td></tr><tr><td style="text-align:center"><strong>/usr</strong></td><td style="text-align:center">Unix Shared Resources(共享资源) 的缩写，用户相关的应用程序和文件，通常分为 /bin, /lib, /sbin 等子目录。</td></tr><tr><td style="text-align:center"><strong>/var</strong></td><td style="text-align:center">存放经常变化的文件，如日志文件。</td></tr><tr><td style="text-align:center"><strong>/sys</strong></td><td style="text-align:center">包含系统设备和驱动程序的接口信息，类似于 /proc。</td></tr></tbody></table><p>构建根文件系统有许多工具：BusyBox、Buildroot、</p><h3 id="busybox-构建根文件系统">BusyBox 构建根文件系统</h3><p>BusyBox 是一个集成了大量 Linux 命令和工具的软件，使用时只需要下载其源码，然后配置选择自己需要的功能，编译即可。</p><blockquote><p><a href="https://busybox.net/downloads/">BusyBox Downloads</a></p></blockquote><p>一般在开发前期都是<strong>通过 nfs 挂载根文件系统</strong>的，等最后完善测试稳定才烧录到 EMMC 或 NAND 中的，因此我们在自己 Ubuntu 的 nfs 服务器目录下添加一个子目录(例如 busybox1.29.0_rootfs )来存放自己根文件系统。</p><h4 id="初步编译-busybox">初步编译 BusyBox</h4><h5 id="修改顶层-makefile">修改顶层 Makefile</h5><p>在 BusyBox 顶层目录修改 Makefile 文件，添加 ARCH 和 CROSS_COMPILE，搜索 164 行和 190 行修改成自己的编译器存放目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CROSS_COMPILE ?= /home/router2/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/arm-buildroot-linux-gnueabihf-</span><br><span class="line"></span><br><span class="line">ARCH ?= arm</span><br></pre></td></tr></table></figure><h5 id="busybox-中文字符支持">BusyBox 中文字符支持</h5><p>新版本的 busybox 默认不支持中文字符显示，中文字符都会显示为 ‘?’，所以我们需要修改 busybox 源码，打开文件 <code>libbb/printable_string.c</code> ，找到函数 <code>printable_string</code>，</p><p>将字符大于 0x7f 的语句进行修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* FAST_FUNC <span class="title function_">printable_string</span><span class="params">(<span class="type">uni_stat_t</span> *stats, <span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">char</span> *dst;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *s;</span><br><span class="line"></span><br><span class="line">        s = str;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">char</span> c = *s;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">                        <span class="comment">/* 99+% of inputs do not need conversion */</span></span><br><span class="line">                        <span class="keyword">if</span> (stats) &#123;</span><br><span class="line">                                stats-&gt;byte_count = (s - str);</span><br><span class="line">                                stats-&gt;unicode_count = (s - str);</span><br><span class="line">                                stats-&gt;unicode_width = (s - str);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c &lt; <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 注释下面两行代码</span></span><br><span class="line">                <span class="comment">/* if (c &gt;= 0x7f)</span></span><br><span class="line"><span class="comment">                        break; </span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                s++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_UNICODE_SUPPORT</span></span><br><span class="line">        dst = unicode_conv_to_printable(stats, str);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="type">char</span> *d = dst = xstrdup(str);</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="type">unsigned</span> <span class="type">char</span> c = *d;</span><br><span class="line">                        <span class="keyword">if</span> (c == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">// 将 c&gt;=0x7f删除</span></span><br><span class="line">                        <span class="comment">// if (c &lt; &#x27; &#x27; || c &gt;= 0x7f)</span></span><br><span class="line">                        <span class="keyword">if</span> (c &lt; <span class="string">&#x27;&#x27;) </span></span><br><span class="line"><span class="string">                                *d = &#x27;</span>?<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">                        d++;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                if (stats) &#123;</span></span><br><span class="line"><span class="string">                        stats-&gt;byte_count = (d - dst);</span></span><br><span class="line"><span class="string">                        stats-&gt;unicode_count = (d - dst);</span></span><br><span class="line"><span class="string">                        stats-&gt;unicode_width = (d - dst);</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">#endif</span></span><br></pre></td></tr></table></figure><p>接着打开文件 <code>libbb/unicode.c</code>，搜索函数 <code>FAST_FUNC unicode_conv_to_printable2</code>，将字符大于 0x7f 显示 ‘?‘ 删除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unicode_status != UNICODE_ON) &#123;</span><br><span class="line">               <span class="type">char</span> *d;</span><br><span class="line">               <span class="keyword">if</span> (flags &amp; UNI_FLAG_PAD) &#123;</span><br><span class="line">                       d = dst = xmalloc(width + <span class="number">1</span>);</span><br><span class="line">                       <span class="keyword">while</span> ((<span class="type">int</span>)--width &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="type">unsigned</span> <span class="type">char</span> c = *src;</span><br><span class="line">                               <span class="keyword">if</span> (c == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">                                       <span class="keyword">do</span></span><br><span class="line">                                               *d++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                                       <span class="keyword">while</span> ((<span class="type">int</span>)--width &gt;= <span class="number">0</span>);</span><br><span class="line">                                       <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                                <span class="comment">// 修改</span></span><br><span class="line">                       <span class="comment">//      *d++ = (c &gt;= &#x27; &#x27; &amp;&amp; c &lt; 0x7f) ? c : &#x27;?&#x27;;</span></span><br><span class="line">                               *d++ = (c &gt;= <span class="string">&#x27; &#x27;</span>) ? c : <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">                               src++;</span><br><span class="line">                       &#125;</span><br><span class="line">                       *d = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       d = dst = xstrndup(src, width);</span><br><span class="line">                       <span class="keyword">while</span> (*d) &#123;</span><br><span class="line">                               <span class="type">unsigned</span> <span class="type">char</span> c = *d;</span><br><span class="line">                               <span class="comment">// 修改</span></span><br><span class="line">                               <span class="comment">//if (c &lt; &#x27; &#x27; || c &gt;= 0x7f)</span></span><br><span class="line">                               <span class="keyword">if</span> (c &lt; <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                                       *d = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">                               d++;</span><br><span class="line">                       &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (stats) &#123;</span><br><span class="line">                       stats-&gt;byte_count = (d - dst);</span><br><span class="line">                       stats-&gt;unicode_count = (d - dst);</span><br><span class="line">                       stats-&gt;unicode_width = (d - dst);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> dst;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="配置-busybox">配置 busybox</h5><p>busybox 有三种配置选项：</p><ul><li>defconfig：缺省配置，也就是默认配置选项。</li><li>allyesconfig，全选配置，也就是选中 busybox 的所有功能。</li><li>allnoconfig，最小配置。</li></ul><p>这里使用默认配置即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make defconfig</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p><strong>取消勾选 <code>Build static binary (no shared libs)</code></strong> 选择静态编译还是动态编译，静态编译不需要库文件，但是文件很大，动态编译则要求根文件系统中有动态库，文件小很多，这里使用动态编译的方式。</p><blockquote><p>正点原子教程：这里我们不能采用静态编译！因为采用静态编译的话 DNS 会出问题！无法进行域名解析</p></blockquote><p><img src="image-20240705145539453.png" alt="image-20240705145539453"></p><p><strong>选择 <code>vi-style line editing commands</code></strong></p><p><img src="image-20240705145719329.png" alt="image-20240705145719329"></p><p><strong>取消勾选 <code>Simplified modutils</code></strong></p><p><img src="image-20240705145759319.png" alt="image-20240705145759319"></p><p>确保 <code>mdev</code> 配置项全部选中，默认都是选中的</p><p><img src="image-20240705145844766.png" alt="image-20240705145844766"></p><p>使能 unicode 编码以支持中文，确保两个选中</p><p><img src="image-20240705150020698.png" alt="image-20240705150020698"></p><h5 id="编译-busybox">编译 busybox</h5><p>编译 busybox，CONFIG_PREFIX 指定编译结果存放目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br><span class="line">make install CONFIG_PREFIX=/home/router2/100ask_imx6ull-sdk/nfs_ubuntu/busybox1.29.0_rootfs</span><br></pre></td></tr></table></figure><p>编译完成目录下内容如下：</p><p><img src="image-20240705150624131.png" alt="image-20240705150624131"></p><p>有 bin、sbin 和 usr 三个目录以及 linuxrc 文件。<strong>Linux 内核 init 进程</strong>最后会查找用户空间的 init 程序，找到以后就会运行这个<strong>用户空间的 init 程序</strong>，从而<strong>切换到用户态</strong>。如果 uboot 中 <strong>bootargs 环境变量设置 init=/linuxrc</strong>，那么 linuxrc 就是可以<strong>作为用户空间的 init 程序</strong>，所以用户态空间的 init 程序是 busybox 来生成的。</p><h4 id="构建整个根文件系统">构建整个根文件系统</h4><p>因为前面是使用动态编译，所以此时的根文件系统还不能使用，需要添加一些动态库文件等来完善。</p><h5 id="添加-lib-目录并添加库文件">添加 lib/ 目录并添加库文件</h5><p>添加 lib 目录，将交叉编译器目录下的 lib 库文件复制到该目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建 lib 文件夹</span><br><span class="line">mkdir lib</span><br><span class="line"></span><br><span class="line">// 进入目录</span><br><span class="line">cd /home/router2/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/arm-buildroot-linux-gnueabihf/sysroot/lib</span><br><span class="line"></span><br><span class="line">// 拷贝</span><br><span class="line">cp *so* *.a /home/router2/100ask_imx6ull-sdk/nfs_ubuntu/busybox1.29.0_rootfs/lib -d </span><br></pre></td></tr></table></figure><p>cp -d 表示拷贝符号连接，相当于 Windows 系统的快捷方式。<code>ld-linux-armhf.so.3</code> 库文件也是符号链接，会连接到其他库文件上，但是 ld-linux-armhf.so.3 不能作为符号链接，否则根文件系统中执行程序无法执行。</p><p>我们可以通过先删除该文件，然后重新复制该文件到目录下（<strong>不使用 -d 参数</strong>），转换前后如下图：一开始作为符号链接时文件很小，去除掉就很大了，是一个实实在在的库文件。</p><p><img src="/image-20240705152722827.png" alt="image-20240705152722827"></p><h5 id="添加-usr-lib-目录并添加库文件">添加 usr/lib 目录并添加库文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 进入目录</span><br><span class="line">cd /home/router2/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/arm-buildroot-linux-gnueabihf/sysroot/usr/lib</span><br><span class="line"></span><br><span class="line">// 复制文件</span><br><span class="line">cp *so* *.a /home/router2/100ask_imx6ull-sdk/nfs_ubuntu/busybox1.29.0_rootfs/usr/lib -d</span><br></pre></td></tr></table></figure><p>使用 du 命令查看目录大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">du lib/ usr/lib/ -sh、</span><br><span class="line"></span><br><span class="line">12Mlib/</span><br><span class="line">270Musr/lib/</span><br></pre></td></tr></table></figure><p>发现 usr/lib 目录很大，进入目录查看有哪些库文件发现有很多第三方库(qt 库、视频解码库等)，可以选择性删掉一些以减少文件大小，删除这些库方便后续自己交叉编译库学习，这里手动删除了一些库减少到了 70M。</p><h5 id="创建其他文件夹">创建其他文件夹</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir dev proc mmt sys tmp root</span><br></pre></td></tr></table></figure><h5 id="测试根文件系统">测试根文件系统</h5><p>uboot 命令行模式下设置 bootargs 环境变量，设置 root 值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root=/dev/nfs nfsroot=[&lt;server-ip&gt;:]&lt;root-dir&gt;[,&lt;nfs-options&gt;] ip=&lt;client-ip&gt;:&lt;server-ip&gt;:&lt;gw-ip&gt;:&lt;netmask&gt;:&lt;hostname&gt;:&lt;device&gt;:&lt;autoconf&gt;:&lt;dns0-ip&gt;:&lt;dns1-ip&gt;</span><br></pre></td></tr></table></figure><ul><li>/dev/nfs：表示 nfs 挂载</li><li>server-ip：服务器 IP 地址</li><li>root-dir：根文件在服务器的存放目录</li><li>nfs-options：nfs 的其他可选项</li><li>client-ip：客户端 IP 地址，即开发板的 IP 地址</li><li>gw-ip：网关地址</li><li>netmask：子网掩码</li><li>hostname：主机名，空着即可</li><li>device：设备名，网卡名：eth0、eth1 等</li><li>autoconf：自动配置，设置 off 即可</li><li>dns0-ip：DNS0 服务器 IP 地址，不使用</li><li>dns1-ip：DNS1服务器 IP 地址，不使用</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setenv bootcmd &#x27;tftp 80800000 zImage; tftp 83000000 imx6ull-obito-emmc.dtb; bootz 80800000 - 83000000&#x27;</span><br><span class="line"></span><br><span class="line">setenv bootcmd &#x27;tftp 80800000 zImage; tftp 83000000 100ask_imx6ull-14x14.dtb; bootz 80800000 - 83000000&#x27;</span><br><span class="line"></span><br><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.1.5:/home/router2/100ask_imx6ull-sdk/nfs_ubuntu/busybox1.29.0_rootfs,proto=tcp rw ip=192.168.1.7:192.168.1.5:192.168.1.1:255.255.255.0::eth0:off&#x27;</span><br><span class="line"></span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>proto=tcp”表示使用 TCP 协议，“rw”表示 nfs 挂载的根文件系统为可读可写.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tftp 80800000 zImage</span><br><span class="line">tftp 83000000 imx6ull-obito-emmc.dtb</span><br><span class="line">bootz 80800000 - 83000000</span><br></pre></td></tr></table></figure><p><img src="image-20240705165000323.png" alt="image-20240705165000323"></p><p>挂载成功，但提示 <code>can't run '/etc/init.d/rcS': No such file or directory</code>，这是一个脚本文件，用来规定启动哪些文件的脚本文件，接下来就是完善根文件系统了。</p><h4 id="完善根文件系统">完善根文件系统</h4><p>在内核挂载根文件系统后，运行的第一个程序是根目录下的 linuxrc，实际是一个指向 <code>/bin/busybox</code> 的链接, 也就是说系统起来后运行的第一个程序是 busybox 本身。先执行 <code>/etc/inittab</code>， 然后调用 <code>/etc/init.d/rcS</code>， 最后是执行 <code>/etc/profile</code>。</p><p>根文件系统还缺少一些脚本文件，接下来添加几个脚本文件进行完善。</p><blockquote><p><a href="https://blog.csdn.net/SuGuolin/article/details/85335965">/etc/inittab,/etc/init.d/rcS和/etc/profile分析_linux profile 和inttab谁先调用-CSDN博客</a></p></blockquote><h5 id="创建-etc-init-d-rcs-文件">创建 /etc/init.d/rcS 文件</h5><p>rcS 是一个 shell 脚本文件，rcS 是用来规定 Linux 内核启动哪些文件的脚本文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/init.d/rcS</span><br></pre></td></tr></table></figure><p>rcS 文件添加以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin:$PATH</span><br><span class="line">LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/lib:/usr/lib</span><br><span class="line">export PATH LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line">mount -a</span><br><span class="line">mkdir /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"></span><br><span class="line">echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure><ul><li>#!/bin/sh：表示这是一个 shell 脚本</li><li>PATH：PATH 环境变量保存<strong>可执行文件</strong>可能存在的目录，冒号: 可以添加多个目录</li><li>LD_LIBRARY_PATH：LD_LIBRARY_PATH 环境变量保存<strong>库文件</strong>所在的目录</li><li>export：导出指定的环境变量，相当于声明一些全局变量</li><li>mount 命令挂载所有的文件系统，这些文件系统由文件 <code>/etc/fstab</code> 来指定</li><li>创建 <code>/dev/pts</code> 目录，将 devpts 挂载到 <code>/dev/pts</code> 目录下</li><li>最后两行使用 mdev 来管理热插拔设备，让 linux 内核可以在 /dev 目录下自动创建设备节点</li></ul><p>最后给 rcS 文件加权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 rcS</span><br></pre></td></tr></table></figure><h5 id="创建-etc-fstab-文件">创建 /etc/fstab 文件</h5><p>fstab 在 Linux 开机以后自动配置哪些需要自动挂载的分区，格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;</span><br></pre></td></tr></table></figure><ul><li>file system：要挂载的特殊设备</li><li>mount point：挂载点</li><li>type：文件系统的类型，例如 ext2、ext3、proc、romfs、tmpfs 等</li><li>options：挂载选项，一般使用 defaults，包含了 了 rw、suid、 dev、 exec、 auto、 nouser 和 async</li><li>dump：1 表示允许备份，0 表示不备份，一般不备份</li><li>pass：磁盘检查设置，0 表示不检查，根目录 ‘/’ 设置为 1，其他分区不能为 1，从 2 开始，一般不在 fstab 中挂载根目录</li></ul><p>在 fstab 文件添加以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;file system&gt; &lt;mount point&gt; &lt;<span class="built_in">type</span>&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;</span></span><br><span class="line">proc /proc proc defaults 0 0</span><br><span class="line">tmpfs /tmp tmpfs defaults 0 0</span><br><span class="line">sysfs /sys sysfs defaults 0 0</span><br></pre></td></tr></table></figure><h5 id="创建-etc-inittab-文件">创建 /etc/inittab 文件</h5><p>init 程序会读取<code>/etc/inittab</code> 这个文件，inittab 由若干条指令组成。每条指令的结构都是一样的，由以“:”分隔的 4 个段组成，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</span><br></pre></td></tr></table></figure><ul><li>id：每个指令的标识符，不能重复</li><li>runlevels：对 busybox 没用</li><li>action：动作，用于 process 可能用到的动作</li><li>process：具体的动作，比如程序、脚本或命令等</li></ul><p>busybox 支持的动作如下：</p><table><thead><tr><th style="text-align:center">动作</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">sysinit</td><td style="text-align:center">在系统初始化的时候 process 才会执行一次。</td></tr><tr><td style="text-align:center">respawn</td><td style="text-align:center">当 process 终止以后马上启动一个新的。</td></tr><tr><td style="text-align:center">askfirst</td><td style="text-align:center">和 respawn 类似，在运行 process 之前在控制台上显示“Please press Enter to activate this console.”。只要用户按下“Enter”键以后才会执行 process。</td></tr><tr><td style="text-align:center">wait</td><td style="text-align:center">告诉 init，要等待相应的进程执行完以后才能继续执行。</td></tr><tr><td style="text-align:center">once</td><td style="text-align:center">仅执行一次，而且不会等待 process 执行完成。</td></tr><tr><td style="text-align:center">restart</td><td style="text-align:center">当 init 重启的时候才会执行 procee。</td></tr><tr><td style="text-align:center">ctrlaltdel</td><td style="text-align:center">当按下 ctrl+alt+del 组合键才会执行 process。</td></tr><tr><td style="text-align:center">shutdown</td><td style="text-align:center">关机的时候执行process。</td></tr></tbody></table><p>在 inittab 文件添加以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">etc/inittab</span></span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">console::askfirst:-/bin/sh</span><br><span class="line">::restart:/sbin/init</span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line">::shutdown:/bin/umount -a -r</span><br><span class="line">::shutdown:/sbin/swapoff -a</span><br></pre></td></tr></table></figure><ul><li>系统启动以后运行 <code>/etc/init.d/rcS</code> 脚本文件</li><li>将 console 作为控制台终端，也就是 ttymxc0，串口</li><li>重启时运行 <code>/sbin/init</code> 脚本文件</li><li>按下组合键就运行 <code>/sbin/reboot</code></li><li>关机时执行 <code>/bin/umount -a -r</code> 命令，卸载各个文件系统</li><li>关机时执行 <code>/sbin/swapoff -a</code> 命令，关闭交换分区</li></ul><h4 id="测试根文件系统">测试根文件系统</h4><p>测试制作好的根文件系统，测试自己编写的程序是否能运行，是否支持程序开机自启动，中文支持是否正常，能不能链接等功能。</p><h5 id="编译测试-hello-c">编译测试 hello.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world!\r\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行文件能够正常循环打印，则证明测试成功。</p><h5 id="中文显示测试">中文显示测试</h5><p>新建中文名字的目录并在文件中写入中文，看显示是否正常。</p><p><img src="image-20240705182649176.png" alt="image-20240705182649176"></p><p>可以看到根文件系统可以正常支持中文显示。</p><h5 id="开机自启动测试">开机自启动测试</h5><p>这里以开机自动执行 hello 程序为例子在 /etc/init.d/rcS 文件添加内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加开启自动程序</span></span><br><span class="line">cd /drivers</span><br><span class="line">./hello &amp;</span><br><span class="line">cd /</span><br></pre></td></tr></table></figure><p>重启开发板，看是否自动运行。</p><p><img src="image-20240705183828147.png" alt="image-20240705183828147"></p><p>输入 ps 查看 hello 程序的进程 pid 号，输入命令关闭程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 pid</span><br></pre></td></tr></table></figure><h5 id="网络连接测试">网络连接测试</h5><p>测试开发板能不能上网，对百度官网进行 ping 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping baidu.com</span><br></pre></td></tr></table></figure><p>会发现提示 <code>ping: bad address 'baidu.com'</code>，这是域名解析错误的原因，因为我们还没有配置域名解析服务器，也就是 DNS 的 IP 地址。在根文件目录下新建 <code>/etc/resolv.conf</code> 文件，添加 DNS 服务器，一般填写自己的网关即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">namserver 192.168.1.1</span><br><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure><p>重新 ping 百度网站测试是否成功。</p><h2 id="烧写系统">烧写系统</h2><p>前面测试系统时都是通过网络连接进行测试，等系统测试稳定后，就将系统烧录到 EMMC 或 NAND 中，就不用每次都进行网络连接了。</p><p><img src="image-20240713152901946.png" alt="image-20240713152901946"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># /etc/inittab</span><br><span class="line">#</span><br><span class="line"># Copyright (C) 2001 Erik Andersen &lt;andersen@codepoet.org&gt;</span><br><span class="line">#</span><br><span class="line"># Note: BusyBox init doesn&#x27;t support runlevels.  The runlevels field is</span><br><span class="line"># completely ignored by BusyBox init. If you want runlevels, use</span><br><span class="line"># sysvinit.</span><br><span class="line">#</span><br><span class="line"># Format for each entry: &lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</span><br><span class="line">#</span><br><span class="line"># id        == tty to run on, or empty for /dev/console</span><br><span class="line"># runlevels == ignored</span><br><span class="line"># action    == one of sysinit, respawn, askfirst, wait, and once</span><br><span class="line"># process   == program to run</span><br><span class="line"></span><br><span class="line"># Startup the system</span><br><span class="line">::sysinit:/bin/mount -t proc proc /proc</span><br><span class="line">::sysinit:/bin/mount -o remount,rw /</span><br><span class="line">::sysinit:/bin/mkdir -p /dev/pts /dev/shm</span><br><span class="line">::sysinit:/bin/mount -a</span><br><span class="line">::sysinit:/sbin/swapon -a</span><br><span class="line">null::sysinit:/bin/ln -sf /proc/self/fd /dev/fd</span><br><span class="line">null::sysinit:/bin/ln -sf /proc/self/fd/0 /dev/stdin</span><br><span class="line">null::sysinit:/bin/ln -sf /proc/self/fd/1 /dev/stdout</span><br><span class="line">null::sysinit:/bin/ln -sf /proc/self/fd/2 /dev/stderr</span><br><span class="line">::sysinit:/bin/hostname -F /etc/hostname</span><br><span class="line"># now run any rc scripts</span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line"></span><br><span class="line"># Put a getty on the serial port</span><br><span class="line">ttymxc0::respawn:/sbin/getty -L  ttymxc0 0 vt100 # GENERIC_SERIAL</span><br><span class="line"></span><br><span class="line"># Stuff to do for the 3-finger salute</span><br><span class="line">#::ctrlaltdel:/sbin/reboot</span><br><span class="line"></span><br><span class="line"># Stuff to do before rebooting</span><br><span class="line">::shutdown:/etc/init.d/rcK</span><br><span class="line">::shutdown:/sbin/swapoff -a</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/bin:/sbin:/usr/bin:/usr/sbin</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=/opt/qt5.15.13/lib:/opt/opencv-4.5.4-arm/lib</span><br><span class="line"></span><br><span class="line">if [ &quot;$PS1&quot; ]; then</span><br><span class="line">        if [ &quot;`id -u`&quot; -eq 0 ]; then</span><br><span class="line">                export PS1=&#x27;# &#x27;</span><br><span class="line">        else</span><br><span class="line">                export PS1=&#x27;$ &#x27;</span><br><span class="line">        fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">export PAGER=&#x27;/bin/more&#x27;</span><br><span class="line">export EDITOR=&#x27;/bin/vi&#x27;</span><br><span class="line"></span><br><span class="line"># Source configuration files from /etc/profile.d</span><br><span class="line">for i in /etc/profile.d/*.sh ; do</span><br><span class="line">        if [ -r &quot;$i&quot; ]; then</span><br><span class="line">                . $i</span><br><span class="line">        fi</span><br><span class="line">done</span><br><span class="line">unset i</span><br><span class="line">#export QT_QPA_PLATFORM=linuxfb:fb=/dev/fb0</span><br><span class="line">#export QT_QPA_FONTDIR=/usr/lib/fonts</span><br><span class="line">EVENT=$(cat /proc/bus/input/devices | grep -E &#x27;TSC2007|ft5x0x_ts|goodix-ts&#x27; -A4</span><br><span class="line">export TSLIB_ROOT=/opt/tslib1.21</span><br><span class="line">export TSLIB_TSDEVICE=/dev/input/$EVENT</span><br><span class="line">export TSLIB_CONFFILE=/opt/tslib1.21/etc/ts.conf</span><br><span class="line">export TSLIB_CALIBFILE=/etc/pointercal</span><br><span class="line">export TSLIB_PLUGINDIR=/opt/tslib1.21/lib/ts</span><br><span class="line">export TSLIB_CONSOLEDEVICE=none</span><br><span class="line">export QT_ROOT=/opt/qt5.15.13</span><br><span class="line">export QT_QPA_FONTDIR=$QT_ROOT/lib/fonts</span><br><span class="line">export QT_QPA_PLATFORM_PLUGIN_PATH=$QT_ROOT/plugins</span><br><span class="line">export QT_QPA_PLATFORM=linuxfb:fb=/dev/fb0</span><br><span class="line"></span><br><span class="line">export QT_QPA_GENERIC_PLUGINS=tslib:/dev/input/event1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HOSTNAME=&#x27;/bin/hostname:&#x27;</span><br><span class="line">PS1=&#x27;\[\e[0;32m\][\u@\h:\w]\$ \[\e[m\]&#x27;</span><br><span class="line">shopt -s checkwinsize</span><br><span class="line">resize</span><br><span class="line">export PS1 HOSTNAME</span><br><span class="line">~</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Start all init scripts in /etc/init.d</span><br><span class="line"># executing them in numerical order.</span><br><span class="line">#</span><br><span class="line">psplash -n &amp;</span><br><span class="line">for i in /etc/init.d/S??* ;do</span><br><span class="line"></span><br><span class="line">     # Ignore dangling symlinks (if any).</span><br><span class="line">     [ ! -f &quot;$i&quot; ] &amp;&amp; continue</span><br><span class="line"></span><br><span class="line">     case &quot;$i&quot; in</span><br><span class="line">        *.sh)</span><br><span class="line">            # Source shell script for speed.</span><br><span class="line">            (</span><br><span class="line">                trap - INT QUIT TSTP</span><br><span class="line">                set start</span><br><span class="line">                . $i</span><br><span class="line">            )</span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            # No sh extension, so fork subprocess.</span><br><span class="line">            $i start</span><br><span class="line">            ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">/bin/hostname -F /etc/hostnames</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux-系统移植&quot;&gt;Linux 系统移植&lt;/h1&gt;
&lt;h2 id=&quot;序言&quot;&gt;序言&lt;/h2&gt;
&lt;p&gt;Linux 学了有些时间了，手上的开发板很多功能都提前做好了，对初学者挺友好的，但是为了学到更到东西，就来试试移植下新的 Linux 系统到开发板上。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/Linux/"/>
    
    
    <category term="Linux 嵌入式" scheme="http://www.obito.top/tags/Linux-%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux-LCD驱动</title>
    <link href="http://www.obito.top/2024/06/30/Linux-LCD%E9%A9%B1%E5%8A%A8/"/>
    <id>http://www.obito.top/2024/06/30/Linux-LCD%E9%A9%B1%E5%8A%A8/</id>
    <published>2024-06-30T03:03:49.000Z</published>
    <updated>2024-08-22T12:49:46.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-lcd驱动">Linux-LCD驱动</h1><h2 id="环境">环境</h2><h3 id="硬件环境">硬件环境</h3><ul><li><strong>开发板型号</strong>： <a href="https://blog.csdn.net/thisway_diy/article/details/109841372">100ask_imx6ull_pro 开发板</a></li><li><strong>处理器类型</strong>：NXP IMX6ULL</li><li><strong>处理器架构</strong>：恩单核 Cortex-A7</li><li><strong>处理器主频</strong>：800MHZ</li><li><strong>内存容量</strong>：512 MB DDR3</li><li><strong>存储介质</strong>：4GB eMMC</li><li><strong>本次测试的驱动</strong>：7 寸 LCD 屏幕</li></ul><h3 id="软件环境">软件环境</h3><ul><li>宿主机<ul><li><strong>宿主机操作系统</strong>：Ubuntu 18.04</li><li><strong>交叉编译器</strong>：100ask 提供的工具链 arm-buildroot-linux-gnueabihf- <strong>支持的最低内核版本</strong>：4.9.0</li></ul></li><li>开发板<ul><li><strong>U-Boot</strong>：一开始用的 NXP 官方提供的版本但不能正常启动内核，后改为 100ask 提供的版本</li><li><strong>内核版本</strong>： <a href="https://github.com/nxp-imx/linux-imx/tree/imx_4.9.88_2.0.0_ga">NXP 提供的 4.9.88 版本</a></li><li><strong>根文件系统类型</strong>：<a href="https://busybox.net/downloads/">BusyBox 1.29.0</a></li></ul></li></ul><h2 id="oled-和-lcd">OLED 和 LCD</h2><ul><li>OLED（Organic Light-Emitting Diode，有机发光二极管）屏幕中的<strong>每个像素点都能自发光</strong>，当电流通过时，有机材料层发光。<ul><li>OLED 屏幕响应时间更快</li><li>OLED 不需要背光层，可以关闭对应像素发光，降低功耗</li><li>OLED 频闪现象明显，可能会烧屏</li></ul></li><li>LCD（Liquid Crystal Display，液晶显示器）屏幕本身不发光，需要<strong>背光层来提供光源</strong>，通过控制液晶分子的转动方向来调节光线的透过，从而显示图像。<ul><li>LCD 需要背光层提供光源，功耗相对较高</li><li>LCD 无频闪，更耐用，寿命更长</li></ul></li></ul><blockquote><p><a href="https://www.topwaydisplay.com/cn/blog/lcd-oled-microled-comparison">https://www.topwaydisplay.com/cn/blog/lcd-oled-microled-comparison</a></p></blockquote><h2 id="lcd时序参数概念">LCD时序参数概念</h2><h3 id="lcd-信号线">LCD 信号线</h3><p>LCD 信号线有 24 根数据线均分为红色数据、绿色数据和蓝色数据，控制线有 CLK、VSYNC、HSYNC和 DE。</p><ul><li>CLK：同步时钟信号。</li><li>VSYNC：垂直同步信号，也叫帧同步信号，表示液晶屏一帧像素数据的传输结束，每传输完成一帧像素数据时，VSYNC 会发生电平跳变。</li><li>HSYNC：水平同步信号，也叫行同步信号，表示液晶屏一行像素数据的传输结束，每传输完成液晶屏的一行像素数据时，HSYNC 会发生电平跳变。</li><li>DE：数据使能信号，表示数据的有效性，当 DE 为高电平时，RGB 信号线表示的数据有效。</li></ul><h3 id="lcd-数据传输时序">LCD 数据传输时序</h3><p>LCD 传输一帧图形数据的时序大致如下：</p><p><img src="image81.jpeg" alt="image8"></p><p>LCD 显示的图像可看作一个矩形，液晶屏有一个显示指针，它指向将要显示的像素。显示指针的扫描方向方向<strong>从左到右、从上到下</strong>，一个像素点一个像素点地描绘图形。这些像素点的数据通过 RGB 数据线传输至液晶屏，它们在同步时钟 CLK 的驱动下一个一个地传输到液晶屏中，交给显示指针，<strong>传输完成一行</strong>时，水平同步信号 <strong>HSYNC 电平跳变一次</strong>，而<strong>传输完一帧</strong>时 <strong>VSYNC 电平跳变一次</strong>。</p><p><img src="image92.jpeg" alt="image9"></p><p>液晶显示指针<strong>在行与行之间，帧与帧之间切换时需要延时</strong>，而且 HSYNC 及 VSYNC 信号本身也有宽度。</p><ul><li>VBP：垂直后肩（vertical back porch），表示一帧图像开始时，这个 VSYNC 信号以后无效的行数。</li><li>VFP：垂直前肩（vertical front porch），表示一帧图像结束后，到下一个 VSYNC 信号无效的行数。</li><li>HBP：水平后肩（horizontal back porch），表示 HSYNC 信号开始到一行的有效数据开始之间的 CLK 个数。</li><li>HFP：水平前肩（horizontal front porch），表示一行的有效数据结束到下一个 HSYNC 信号开始之间的 CLK的个数。</li><li>VSW：表示 VSYNC 信号的宽度，单位为行。</li><li>HSW：表示 HSYNC 信号的宽度，单位为 CLK 的个数。</li></ul><blockquote><p><a href="https://doc.embedfire.com/mcu/i.mxrt/i.mxrt1052/zh/latest/doc/chapter24/chapter24.html">24. eLCDIF—液晶显示 — 野火 i.MX RT库开发实战指南——基于i.MXRT1052 文档 (embedfire.com)</a></p></blockquote><h2 id="linux-lcd驱动解析">Linux-LCD驱动解析</h2><h3 id="lcd-显示原理">LCD 显示原理</h3><p>Linux 内核驱动申请一片内存空间——Framebuffer，LCD 控制器将 Framebuffer 中的数据拷贝到 LCD 的 SRAM 上显示图像。</p><p><img src="image-20240630112737450.png" alt="image-20240630112737450"></p><h3 id="framebuffer-设备">Framebuffer 设备</h3><p>Framebuffer（fb 帧缓冲），是 Linux 内核虚拟出来的一个设备，属于<strong>字符设备</strong>类型。主要作用是<strong>为应用层提供一个统一标准接口的显示设备</strong>，通过 fb 应用程序可以直接对显存进行操作。用户不必关心物理显存的位置、换页机制等等具体细节， 这些都是由 FrameBuffer 设备驱动来完成的。</p><p>LCD 驱动编写完成后会生成一个名为 <code>/dev/fbX(X=0~n)</code> 的设备，NXP 官方的 Linux 内核默认已经开启 LCD 驱动了，NXP 官方的设备树已经添加了 LCD 设备节点，只是用到的 IO 口以及屏幕参数可能不同，<strong>所以我们要做的是在设备树修改成自己使用的 IO 口和屏幕参数。</strong></p><h3 id="lcd-设备树描述信息解析">LCD 设备树描述信息解析</h3><h4 id="lcd-屏幕-io-配置">LCD 屏幕 IO 配置</h4><p>100ASK_IMX6ULL_PRO 开发板的 LCD 背光引脚、数据线、控制线均和和 NXP 开发板的一样，只有复位引脚不同，所以 <strong>IO 配置部分只需要修改复位引脚即可。</strong></p><p>NXP 官方的设备树：imx6ul-14x14-evk.dts 文件下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_lcdif_dat: lcdifdatgrp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_LCD_DATA00__LCDIF_DATA00  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA01__LCDIF_DATA01  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA02__LCDIF_DATA02  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA03__LCDIF_DATA03  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA04__LCDIF_DATA04  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA05__LCDIF_DATA05  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA06__LCDIF_DATA06  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA07__LCDIF_DATA07  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA08__LCDIF_DATA08  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA09__LCDIF_DATA09  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA10__LCDIF_DATA10  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA11__LCDIF_DATA11  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA12__LCDIF_DATA12  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA13__LCDIF_DATA13  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA14__LCDIF_DATA14  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA15__LCDIF_DATA15  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA16__LCDIF_DATA16  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA17__LCDIF_DATA17  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA18__LCDIF_DATA18  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA19__LCDIF_DATA19  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA20__LCDIF_DATA20  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA21__LCDIF_DATA21  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA22__LCDIF_DATA22  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_DATA23__LCDIF_DATA23  <span class="number">0x79</span></span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pinctrl_lcdif_ctrl: lcdifctrlgrp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_LCD_CLK__LCDIF_CLK    <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_ENABLE__LCDIF_ENABLE  <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_HSYNC__LCDIF_HSYNC    <span class="number">0x79</span></span><br><span class="line">MX6UL_PAD_LCD_VSYNC__LCDIF_VSYNC    <span class="number">0x79</span></span><br><span class="line"><span class="comment">/* used for lcd reset */</span></span><br><span class="line">MX6UL_PAD_SNVS_TAMPER9__GPIO5_IO09  <span class="number">0x79</span></span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pinctrl_pwm1: pwm1grp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_GPIO1_IO08__PWM1_OUT   <span class="number">0x110b0</span></span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>子节点 pinctrl_lcdif_dat 定义了 LCD 屏幕的 24 根数据线配置项</li><li>子节点 pinctrl_lcdif_ctrl 定义了 LCD 屏幕的复位引脚和 4 根控制线：CLK、ENABLE、HSYNC、VSYNC</li><li>子节点 pinctrl_pwm1 定义了 LCD 屏幕背光 PWM 引脚配置项</li></ul><p><strong>NXP 官方设备树是将 GPIO5_9 作为 LCD 复位引脚，跟 100ask 开发板的复位引脚不同</strong>，在 iomuxc 节点下的 imx6ul-evk 子节点添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_lcdif_reset: lcdifresetgrp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">/* used for lcd reset */</span><br><span class="line">MX6UL_PAD_LCD_RESET__GPIO3_IO04  0x1b0b0</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Linux 系统如何知道引脚 PWM1_OUT 是用来控制 LCD 背光的呢？通过 backlight 节点来将 LCD 背光和引脚 PWM1_OUT 连接起来：</strong></p><blockquote><p>backlight 节点描述可以参考 Documentation/devicetree/indings/video/backlight/pwm-backlight.txt 这个文档</p></blockquote><p>NXP 官方的设备树：imx6ul-14x14-evk.dts 文件下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">backlight &#123;</span><br><span class="line">compatible = <span class="string">&quot;pwm-backlight&quot;</span>;</span><br><span class="line">pwms = &lt;&amp;pwm1 <span class="number">0</span> <span class="number">5000000</span>&gt;;</span><br><span class="line">brightness-levels = &lt;<span class="number">0</span> <span class="number">4</span> <span class="number">8</span> <span class="number">16</span> <span class="number">32</span> <span class="number">64</span> <span class="number">128</span> <span class="number">255</span>&gt;;</span><br><span class="line"><span class="keyword">default</span>-brightness-level = &lt;<span class="number">6</span>&gt;;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>compatible = “pwm-backlight”; 在 Linux 内核中 <code>drivers/video/backlight/pwm_bl.c</code> 文件中又具体的驱动程序</li><li>pwms 属性用于描述背光所使用的 PWM 和 PWM 频率，5000000 表示 5000000 ns，即 5 ms，1s / 5ms = 200 Hz，即 PWM 频率为 200Hz</li><li>brightness-levels 属性描述亮度级别，范围为0~255，0 表示 PWM 占空比为 0%，也就是亮度最低，255 表示 100% 占空比，也就是亮度最高</li><li>default-brightness-level 属性为默认亮度级别</li></ul><h4 id="lcd-屏幕参数节点信息">LCD 屏幕参数节点信息</h4><p>imx6ull.dtsi 文件：定义了 LCD 节点通用信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lcdif: lcdif@<span class="number">021</span>c8000 &#123;</span><br><span class="line">compatible = <span class="string">&quot;fsl,imx6ul-lcdif&quot;</span>, <span class="string">&quot;fsl,imx28-lcdif&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">0x021c8000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">interrupts = &lt;GIC_SPI <span class="number">5</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">clocks = &lt;&amp;clks IMX6UL_CLK_LCDIF_PIX&gt;,</span><br><span class="line"> &lt;&amp;clks IMX6UL_CLK_LCDIF_APB&gt;,</span><br><span class="line"> &lt;&amp;clks IMX6UL_CLK_DUMMY&gt;;</span><br><span class="line">clock-names = <span class="string">&quot;pix&quot;</span>, <span class="string">&quot;axi&quot;</span>, <span class="string">&quot;disp_axi&quot;</span>;</span><br><span class="line">status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些 LCD 节点通用信息，适用于 IMX6ULL 芯片的板子，不是完整的节点信息，需要我们在自己板子上的设备树进行<strong>补充 LCD 屏幕信息</strong>。</p><p>NXP 官方的设备树：imx6ul-14x14-evk.dts，LCD 节点如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&amp;lcdif &#123;</span><br><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_lcdif_dat</span><br><span class="line">     &amp;pinctrl_lcdif_ctrl&gt;;</span><br><span class="line">display = &lt;&amp;display0&gt;;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">display0: display@<span class="number">0</span> &#123;</span><br><span class="line">bits-per-pixel = &lt;<span class="number">16</span>&gt;;</span><br><span class="line">bus-width = &lt;<span class="number">24</span>&gt;;</span><br><span class="line"></span><br><span class="line">display-timings &#123;</span><br><span class="line">native-mode = &lt;&amp;timing0&gt;;</span><br><span class="line"></span><br><span class="line">timing0: timing0 &#123;</span><br><span class="line">clock-frequency = &lt;<span class="number">9200000</span>&gt;;</span><br><span class="line">hactive = &lt;<span class="number">480</span>&gt;;</span><br><span class="line">vactive = &lt;<span class="number">272</span>&gt;;</span><br><span class="line">hfront-porch = &lt;<span class="number">8</span>&gt;;</span><br><span class="line">hback-porch = &lt;<span class="number">4</span>&gt;;</span><br><span class="line">hsync-len = &lt;<span class="number">41</span>&gt;;</span><br><span class="line">vback-porch = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">vfront-porch = &lt;<span class="number">4</span>&gt;;</span><br><span class="line">vsync-len = &lt;<span class="number">10</span>&gt;;</span><br><span class="line">hsync-active = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">vsync-active = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">de-active = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">pixelclk-active = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在设备树下<strong>修改成自己的屏幕信息：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&amp;lcdif &#123;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_lcdif_dat<span class="comment">/* 使用到的IO */</span></span><br><span class="line">             &amp;pinctrl_lcdif_ctrl</span><br><span class="line">             &amp;pinctrl_lcdif_reset&gt;; </span><br><span class="line">    display = &lt;&amp;display0&gt;;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    reset-gpios = &lt;&amp;gpio3 <span class="number">4</span> GPIO_ACTIVE_LOW&gt;; <span class="comment">/* 屏幕复位IO */</span></span><br><span class="line"></span><br><span class="line">    display0: display &#123;<span class="comment">/* LCD 属性信息 */</span></span><br><span class="line">        bits-per-pixel = &lt;<span class="number">24</span>&gt;;<span class="comment">/* RGB888 一个像素占用几个bit */</span></span><br><span class="line">        bus-width = &lt;<span class="number">24</span>&gt;;<span class="comment">/* 总线宽度 */</span></span><br><span class="line"></span><br><span class="line">        display-timings &#123;</span><br><span class="line">            native-mode = &lt;&amp;timing0&gt;;<span class="comment">/* 时序信息 */</span></span><br><span class="line"></span><br><span class="line">             timing0: timing0_1024x768 &#123;</span><br><span class="line">             clock-frequency = &lt;<span class="number">50000000</span>&gt;;<span class="comment">/* LCD 像素时钟，单位Hz */</span></span><br><span class="line">             hactive = &lt;<span class="number">1024</span>&gt;;<span class="comment">/* LCD X 轴像素个数 */</span></span><br><span class="line">             vactive = &lt;<span class="number">600</span>&gt;;<span class="comment">/* LCD Y 轴像素个数 */</span></span><br><span class="line">             hfront-porch = &lt;<span class="number">160</span>&gt;;<span class="comment">/* LCD hfp 参数 */</span></span><br><span class="line">             hback-porch = &lt;<span class="number">140</span>&gt;;<span class="comment">/* LCD hbp 参数 */</span></span><br><span class="line">             hsync-len = &lt;<span class="number">20</span>&gt;;<span class="comment">/* LCD hspw 参数 */</span></span><br><span class="line">             vback-porch = &lt;<span class="number">20</span>&gt;;<span class="comment">/* LCD vbp 参数 */</span></span><br><span class="line">             vfront-porch = &lt;<span class="number">12</span>&gt;;<span class="comment">/* LCD vfp 参数 */</span></span><br><span class="line">             vsync-len = &lt;<span class="number">3</span>&gt;;<span class="comment">/* LCD vspw 参数 */</span></span><br><span class="line"></span><br><span class="line">             hsync-active = &lt;<span class="number">0</span>&gt;;<span class="comment">/* hsync 数据线极性 */</span></span><br><span class="line">             vsync-active = &lt;<span class="number">0</span>&gt;;<span class="comment">/* vsync 数据线极性 */</span></span><br><span class="line">             de-active = &lt;<span class="number">1</span>&gt;;<span class="comment">/* de 数据线极性 */</span></span><br><span class="line">             pixelclk-active = &lt;<span class="number">0</span>&gt;;<span class="comment">/* clk 数据线先极性 */</span></span><br><span class="line">             &#125;;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行测试">运行测试</h4><h5 id="添加企鹅-logo">添加企鹅 logo</h5><p><strong>Linux 内核启动时显示企鹅 logo，显示表示 LCD 驱动基本正常</strong>，这个 logo 需要在 Linux 内核配置启动，一般内核是默认启动的。</p><p>Linux 内核修改：<strong>使能 Linux logo 显示</strong>，按如下路径找到配置项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Device Drivers</span></span><br><span class="line">    -&gt; Graphics support</span><br><span class="line">    -&gt; Bootup logo (LOGO [=y])</span><br><span class="line">    -&gt; Standard black and white Linux logo</span><br><span class="line">    -&gt; Standard 16-color Linux logo</span><br><span class="line">    -&gt; Standard 224-color Linux logo</span><br></pre></td></tr></table></figure><p>如下：</p><p><img src="image-20240707143216743.png" alt="image-20240707143216743"></p><p>默认是选择的，三个选项分别对应着黑白、16 位、24 位色彩格式的 logo。</p><h5 id="编译设备树">编译设备树</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make dtbs</span><br></pre></td></tr></table></figure><p>设备修改完成后，进行编译烧录到开发板。</p><h5 id="lcd-背光调节">LCD 背光调节</h5><p>设备树节点设置了 8 个等级的背光调节，可以设置为 0~7，<code>/sys/class/backlight/backlight</code> 目录下存放背光调节的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /sys/class/backlight/backlight</span><br><span class="line">cat /sys/class/backlight/backlight</span><br></pre></td></tr></table></figure><p>brightness 表示当前亮度等级，max_brightness 表示最大亮度等级，使用 echo 命令可以修改屏幕亮度：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 7 &gt; brightness</span><br></pre></td></tr></table></figure><p>brigtness 为 0 的话会关闭 LCD 背光，即屏幕会熄灭。</p><h4 id="设备-lcd-作为终端控制台">设备 LCD 作为终端控制台</h4><h5 id="设置-uboot-启动参数">设置 uboot 启动参数</h5><p>重启开发板进去 uboot 界面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=tty1 console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.1.5:/home/router2/100ask_imx6ull-sdk/nfs_ubuntu/busybox1.29.0_rootfs,proto=tcp rw ip=192.168.1.7:192.168.1.5:192.168.1.1:255.255.255.0::eth0:off&#x27;</span><br></pre></td></tr></table></figure><ul><li>console=tty1：表示设置 LCD 屏幕为控制台</li><li>console=ttymxc0,115200：表示设置串口为控制台</li><li>后面是根文件系统的目录等信息</li></ul><h5 id="修改根文件系统">修改根文件系统</h5><p>打开根文件系统中的 <code>/etc/inittab</code> 文件，添加这一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tty1::askfirst:-/bin/sh</span><br></pre></td></tr></table></figure><p>修改完成后保存文件，重启开发板，就可以发现 LCD 屏幕上呈现系统启动信息了。</p><p>Linux 内核默认使能了 USB 键盘驱动，直接插上键盘就可以实现在 MobaXterm 软件通过串口操作开发板一样的效果了，但是 LCD 控制台还不支持中文操作，后续再进行优化。</p><p><img src="image-20240707153334139.png" alt="image-20240707153334139"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux-lcd驱动&quot;&gt;Linux-LCD驱动&lt;/h1&gt;
&lt;h2 id=&quot;环境&quot;&gt;环境&lt;/h2&gt;
&lt;h3 id=&quot;硬件环境&quot;&gt;硬件环境&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;开发板型号&lt;/strong&gt;： &lt;a href=&quot;https://blog.csd</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/Linux/"/>
    
    
    <category term="Linux 嵌入式" scheme="http://www.obito.top/tags/Linux-%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux-SPI-ICM20608</title>
    <link href="http://www.obito.top/2024/06/28/Linux-SPI-ICM20608/"/>
    <id>http://www.obito.top/2024/06/28/Linux-SPI-ICM20608/</id>
    <published>2024-06-28T10:28:32.000Z</published>
    <updated>2024-08-23T03:16:38.318Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux-spi-icm20608">Linux-SPI-ICM20608</h2><h2 id="环境">环境</h2><h3 id="硬件环境">硬件环境</h3><ul><li><strong>开发板型号</strong>： <a href="https://blog.csdn.net/thisway_diy/article/details/109841372">100ask_imx6ull_pro 开发板</a></li><li><strong>处理器类型</strong>：NXP IMX6ULL</li><li><strong>处理器架构</strong>：恩单核 Cortex-A7</li><li><strong>处理器主频</strong>：800MHZ</li><li><strong>内存容量</strong>：512 MB DDR3</li><li><strong>存储介质</strong>：4GB eMMC</li><li><strong>本次测试的驱动</strong>：ICM20608 六轴传感器</li></ul><h3 id="软件环境">软件环境</h3><ul><li>宿主机<ul><li><strong>宿主机操作系统</strong>：Ubuntu 18.04</li><li><strong>交叉编译器</strong>：100ask 提供的工具链 arm-buildroot-linux-gnueabihf- <strong>支持的最低内核版本</strong>：4.9.0</li></ul></li><li>开发板<ul><li><strong>U-Boot</strong>：一开始用的 NXP 官方提供的版本但不能正常启动内核，后改为 100ask 提供的版本</li><li><strong>内核版本</strong>： <a href="https://github.com/nxp-imx/linux-imx/tree/imx_4.9.88_2.0.0_ga">NXP 提供的 4.9.88 版本</a></li><li><strong>根文件系统类型</strong>：<a href="https://busybox.net/downloads/">BusyBox 1.29.0</a></li></ul></li></ul><h2 id="icm20608">ICM20608</h2><p>ICM20608 是由 InvenSense 公司生产的一款 6 轴惯性测量单元（IMU），它集成了 3 轴陀螺仪和 3 轴加速度计。这款传感器广泛应用于需要精确运动跟踪的场合，比如无人机、机器人、智能手机和可穿戴设备等。</p><ul><li>陀螺仪支持 X，Y 和 Z 三轴输出，内部集成 <strong>16 位 ADC</strong>，测量范围可设置：±250，±500，±1000 和 ±2000°/s</li><li>加速度计支持 X，Y 和 Z 轴输出，内部集成 <strong>16 位 ADC</strong>，测量范围可设置：±2g，±4g，±8g 和 ±16g，g 表示重力加速度 1g=9.8m/s²。</li><li>内部包含一个 512 字节的 FIFO</li><li>支持快速 I2C，速度可达 400 KHz</li><li><strong>支持 SPI，速度可达 8 MHz</strong></li><li>寄存器 8 位，寄存器位宽 8位</li></ul><p><img src="image-20240701203832248.png" alt="image-20240701203832248"></p><p>如果使用 I2C 接口，则 AD0 引脚决定 I2C 设备地址的最后以为，AD0 = 0 则设备地址为 0x68，AD0 = 1 则设备地址为 0x69，我们这里用的是 SPI 接口，就不用纠结这个了。</p><p>使用 SPI 接口读写寄存器需要 16 个时钟或者更多(如果读写操作包括多个字节的话)，第一个字节包含要读写的寄存器地址，<strong>寄存器地址最高位是读写标志位</strong>，如果是读的话寄存器地址最高位要为 1，如果是写的话寄存器地址最高位要为 0，剩下的 7 位才是实际的寄存器地址，寄存器地址后面跟着的就是读写的数据。</p><p>本次使用到的 ICM20608 的一些重要寄存器如下：</p><p><img src="image-20240701205419079.png" alt="image-20240701205419079"></p><p><img src="image-20240701205429856.png" alt="image-20240701205429856"></p><p>原理图如下：</p><p><img src="image-20240701205602840.png" alt="image-20240701205602840"></p><h2 id="驱动代码编写">驱动代码编写</h2><h3 id="设备描述信息">设备描述信息</h3><h4 id="添加-icm20608-所使用到的-io">添加 ICM20608 所使用到的 IO</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&amp;iomuxc &#123;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_hog_1&gt;;</span><br><span class="line">    imx6ul-evk &#123;</span><br><span class="line">pinctrl_ecspi3: ecspi3 &#123;              </span><br><span class="line">                    fsl,pins = &lt;</span><br><span class="line">                MX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI         <span class="number">0x000010B0</span></span><br><span class="line">                MX6UL_PAD_UART2_RTS_B__ECSPI3_MISO         <span class="number">0x000010B0</span></span><br><span class="line">                MX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK       <span class="number">0x000010B0</span></span><br><span class="line">                MX6UL_PAD_UART2_TX_DATA__GPIO1_IO20        <span class="number">0x000010B0</span></span><br><span class="line">            &gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="添加-ecspi3-节点追加-icm20608子节点">添加 ecspi3 节点追加 ICM20608子节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&amp;ecspi3 &#123; </span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_ecspi3&gt;;</span><br><span class="line">    cs-gpios = &lt;&amp;gpio1 <span class="number">20</span> GPIO_ACTIVE_LOW&gt;;     <span class="comment">// cs-gpios软件操作片选IO</span></span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cs-gpios 是根据驱动文件中的命名设置的</span></span><br><span class="line">    spidev: icm20608@<span class="number">0</span>&#123;         <span class="comment">// 0表示使用ecspi3的0通道，跟reg对应</span></span><br><span class="line">        compatible = <span class="string">&quot;invensense,icm20608&quot;</span>;</span><br><span class="line">        interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">        interrupts = &lt;<span class="number">1</span> <span class="number">1</span>&gt;;</span><br><span class="line">        spi-max-frequency = &lt;<span class="number">8000000</span>&gt;; <span class="comment">// 可支持的最高频率</span></span><br><span class="line">        reg = &lt;<span class="number">0</span>&gt;; </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="注意事项">注意事项</h4><p>在修改设备树时，记得检查一下是否其他设备也用到了相同引脚。遇到了一个问题，就是驱动程序和设备树的 compatible 都相同，但是始终发现匹配不成功，没有进入到 probe 函数，驱动程序匹配主要就看 compatible 这些匹配的信息，都无误，于是查看设备树，发现原来是引脚冲突了，ecspi3 子节点和 uart2、can2 冲突，忘记删减了。</p><p><img src="image-20240716132936690.png" alt="image-20240716132936690"></p><h3 id="driver-驱动代码">driver 驱动代码</h3><h4 id="寄存器定义和-icm20608-dev-结构体">寄存器定义和 icm20608_dev 结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spi/spi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span> <span class="comment">/*注册设备节点的文件结构体*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span> <span class="comment">// 对字符设备结构cdev 以及一系列的操作函数的定义。包含了cdev 结构及相关函数的定义。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span> <span class="comment">//包含了device、class 等结构的定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span> <span class="comment">//包含了copy_to_user、copy_from_user 等内核访问用户进程内存地址的函数定义。</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ICM20608寄存器定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_PWR_MGMT_1 0x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_PWR_MGMT_2 0x6C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_SMPLRT_DIV 0x19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_CONFIG 0x1A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_GYRO_CONFIG 0x1B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_ACCEL_CONFIG 0x1C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_ACCEL_CONFIG2 0x1D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_LP_MODE_CFG 0x1E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_FIFO_EN 0x23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_WHO_AM_I 0x75</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACCEL_XOUT_H 0x3B</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_NAME <span class="string">&quot;icm20608&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icm20608_data</span> &#123;</span></span><br><span class="line"><span class="type">int16_t</span> accel_x;</span><br><span class="line"><span class="type">int16_t</span> accel_y;</span><br><span class="line"><span class="type">int16_t</span> accel_z;</span><br><span class="line"><span class="type">int16_t</span> gyro_x;</span><br><span class="line"><span class="type">int16_t</span> gyro_y;</span><br><span class="line"><span class="type">int16_t</span> gyro_z;</span><br><span class="line"><span class="type">int16_t</span> temperature;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> &#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;<span class="comment">/* 设备号 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">/* cdev  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span><span class="comment">/* 类 */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* 设备 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span><span class="comment">/* 设备节点 */</span></span><br><span class="line"><span class="type">int</span> major;<span class="comment">/* 主设备号 */</span></span><br><span class="line"><span class="type">void</span> *private_data;<span class="comment">/* 私有数据 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icm20608_data</span> <span class="title">data</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> <span class="title">icm20608_dev_t</span>;</span></span><br></pre></td></tr></table></figure><h4 id="注册-注销-spi-driver-结构体">注册/注销 spi_driver 结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设备树compatible匹配表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table</span>[] =</span> &#123;</span><br><span class="line">&#123;.compatible = <span class="string">&quot;invensense,icm20608&quot;</span>&#125;, </span><br><span class="line">&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 无设备树的匹配ID表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device_id</span> <span class="title">id_table</span>[] =</span> &#123;</span><br><span class="line">&#123;<span class="string">&quot;invensense,icm20608&quot;</span>&#125;,</span><br><span class="line">&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义i2c总线设备结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> <span class="title">icm20608_spi_driver</span> =</span> &#123;</span><br><span class="line">.driver = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.name  = <span class="string">&quot;icm20608&quot;</span>,</span><br><span class="line">.of_match_table = of_match_table,</span><br><span class="line">&#125;,</span><br><span class="line">.probe= icm20608_spi_driver_probe,</span><br><span class="line">.remove = icm20608_spi_driver_remove,</span><br><span class="line">.id_table= id_table,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">icm20608_spi_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="comment">// 注册 spi 驱动</span></span><br><span class="line">ret = spi_register_driver(&amp;icm20608_spi_driver);</span><br><span class="line"></span><br><span class="line">printk(<span class="string">&quot;icm20608_spi_driver_init ok\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">icm20608_spi_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将前面注册的spi_driver也从Linux内核中注销掉</span></span><br><span class="line">spi_unregister_driver(&amp;icm20608_spi_driver);</span><br><span class="line">printk(<span class="string">&quot;icm20608_spi_driver_exit ok\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(icm20608_spi_driver_init);</span><br><span class="line">module_exit(icm20608_spi_driver_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="添加字符设备">添加字符设备</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">icm20608_fops</span> =</span> &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.open   = icm20608_open,</span><br><span class="line">.release  = icm20608_close,</span><br><span class="line">.read= icm20608_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_spi_driver_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 1.分配设备号</span></span><br><span class="line"><span class="keyword">if</span>(<span class="type">icm20608_dev_t</span>.major)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">icm20608_dev_t</span>.devid = MKDEV(<span class="type">icm20608_dev_t</span>.major, <span class="number">0</span>);</span><br><span class="line">register_chrdev_region(<span class="type">icm20608_dev_t</span>.devid, <span class="number">1</span>, ICM20608_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">alloc_chrdev_region(&amp;<span class="type">icm20608_dev_t</span>.devid, <span class="number">0</span>, <span class="number">1</span>, ICM20608_NAME);</span><br><span class="line"><span class="type">icm20608_dev_t</span>.major = MAJOR(<span class="type">icm20608_dev_t</span>.devid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.初始化cdev</span></span><br><span class="line">cdev_init(&amp;<span class="type">icm20608_dev_t</span>.cdev, &amp;icm20608_fops);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.添加设备号到cdev</span></span><br><span class="line">cdev_add(&amp;<span class="type">icm20608_dev_t</span>.cdev, <span class="type">icm20608_dev_t</span>.devid, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.创建类</span></span><br><span class="line"><span class="type">icm20608_dev_t</span>.class = class_create(THIS_MODULE, ICM20608_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="type">icm20608_dev_t</span>.device))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="type">icm20608_dev_t</span>.device);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.类下创建设备</span></span><br><span class="line"><span class="type">icm20608_dev_t</span>.device = device_create(<span class="type">icm20608_dev_t</span>.class, <span class="literal">NULL</span>, <span class="type">icm20608_dev_t</span>.devid, <span class="literal">NULL</span>, ICM20608_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="type">icm20608_dev_t</span>.device))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="type">icm20608_dev_t</span>.device);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备树设置软件片选，spi主控制器为自动帮我们操作片选IO，所以就不需要手动控制了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化spi_device结构体 </span></span><br><span class="line">spi-&gt;mode = SPI_MODE_0;  <span class="comment">/* MODE0，CPOL=0，CPHA=0 */</span></span><br><span class="line">spi_setup(spi);</span><br><span class="line"><span class="type">icm20608_dev_t</span>.private_data = spi;<span class="comment">/* 设置私有数据 */</span></span><br><span class="line"></span><br><span class="line">printk(<span class="string">&quot;icm20608_spi_driver_probe ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_spi_driver_remove</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 1.注销设备号</span></span><br><span class="line">unregister_chrdev_region(<span class="type">icm20608_dev_t</span>.devid, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 2.删除设备</span></span><br><span class="line">cdev_del(&amp;<span class="type">icm20608_dev_t</span>.cdev);</span><br><span class="line"><span class="comment">// 3.注销设备节点</span></span><br><span class="line">device_destroy(<span class="type">icm20608_dev_t</span>.class, <span class="type">icm20608_dev_t</span>.devid);</span><br><span class="line"><span class="comment">// 4.删除类</span></span><br><span class="line">class_destroy(<span class="type">icm20608_dev_t</span>.class);</span><br><span class="line"></span><br><span class="line">printk(<span class="string">&quot;icm20608_spi_driver_remove ok\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收发数据函数">收发数据函数</h4><p>前面我们在设备树中将片选 IO 设置为了软中断，且 <strong>Linux 内核中的 SPI 主控制器会自动帮我们操作片选 IO</strong>，因此在收发数据函数中我们不能手动控制片选 IO 了。另外需要注意的是 <strong>SPI 接收的时候会先接收到一个字节的寄存器地址</strong>，读取数据时我们需要跳过该字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : 读取 icm20608 设备多个寄存器数据</span></span><br><span class="line"><span class="comment">* @param – dev : icm20608 设备</span></span><br><span class="line"><span class="comment">* @param – reg : 要读取的寄存器首地址</span></span><br><span class="line"><span class="comment">* @param – val : 读取到的数据</span></span><br><span class="line"><span class="comment">* @param – len : 要读取的数据长度</span></span><br><span class="line"><span class="comment">* @return : 操作结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_read_reg</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, <span class="type">uint8_t</span> reg, <span class="type">void</span> *val, <span class="type">uint8_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">uint8_t</span> tx_data[<span class="number">1</span>];</span><br><span class="line"><span class="type">uint8_t</span> *rx_data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> *<span class="title">t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span> =</span> (<span class="keyword">struct</span> spi_device *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配内存 */</span></span><br><span class="line">t = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> spi_transfer), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span>(!t)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;kzalloc error\n&quot;</span>);</span><br><span class="line">kfree(t);</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rx_data = kzalloc(<span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) + len, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span>(!rx_data)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;kzalloc error\n&quot;</span>);</span><br><span class="line">kfree(rx_data);</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送要读取的寄存地址和接收读取的数据 */</span></span><br><span class="line">tx_data[<span class="number">0</span>] = reg | (<span class="number">0x80</span>); <span class="comment">/* 读数据的时候首寄存器地址bit8 要置1 */</span></span><br><span class="line"></span><br><span class="line">t-&gt;tx_buf = tx_data;<span class="comment">/* 要发送的数据：寄存器地址 */</span></span><br><span class="line">t-&gt;rx_buf = rx_data;<span class="comment">/* 要接收的数据 */</span></span><br><span class="line">t-&gt;len = len + <span class="number">1</span>;<span class="comment">/* t-&gt;len=发送的长度+读取的长度 */</span></span><br><span class="line"></span><br><span class="line">spi_message_init(&amp;msg); <span class="comment">/* 初始化spi_message */</span></span><br><span class="line">spi_message_add_tail(t, &amp;msg);<span class="comment">/* 将spi_transfer 添加到spi_message 队列 */</span></span><br><span class="line">ret = spi_sync(spi, &amp;msg); <span class="comment">/* 同步传输 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SPI接收数据时，第一个字节是寄存器的地址，跳过一个字节即可。</span></span><br><span class="line"><span class="built_in">memcpy</span>(val, rx_data + <span class="number">1</span>, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放内存 */</span></span><br><span class="line">kfree(t);</span><br><span class="line">kfree(rx_data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : 向 icm20608 设备多个寄存器写入数据</span></span><br><span class="line"><span class="comment">* @param – dev : 要写入的设备结构体</span></span><br><span class="line"><span class="comment">* @param – reg : 要写入的寄存器首地址</span></span><br><span class="line"><span class="comment">* @param – val : 要写入的数据缓冲区</span></span><br><span class="line"><span class="comment">* @param – len : 要写入的数据长度</span></span><br><span class="line"><span class="comment">* @return : 操作结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_write_reg</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, <span class="type">uint8_t</span> reg, <span class="type">uint8_t</span> *buf, <span class="type">uint8_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"><span class="type">uint8_t</span> *tx_data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> *<span class="title">t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span> =</span> (<span class="keyword">struct</span> spi_device *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配内存 */</span></span><br><span class="line">t = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> spi_transfer), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span>(!t)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;kzalloc error\n&quot;</span>);</span><br><span class="line">kfree(t);</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tx_data = kzalloc(<span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) + len, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span>(!t)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;kzalloc error\n&quot;</span>);</span><br><span class="line">kfree(tx_data);</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送要读取的寄存地址和写入的数据 */</span></span><br><span class="line">*tx_data = reg &amp; ~(<span class="number">0x80</span>); <span class="comment">/* 写数据的时候寄存器地址bit8要清零 */</span></span><br><span class="line"><span class="built_in">memcpy</span>(tx_data + <span class="number">1</span>, buf, len);<span class="comment">/* 把len 个寄存器拷贝到txdata 里 */</span></span><br><span class="line"></span><br><span class="line">t-&gt;tx_buf = tx_data;<span class="comment">/* 要发送的数据 */</span></span><br><span class="line">t-&gt;len = len + <span class="number">1</span>;<span class="comment">/* t-&gt;len=发送的长度+读取的长度 */</span></span><br><span class="line"></span><br><span class="line">spi_message_init(&amp;msg); <span class="comment">/* 初始化spi_message */</span></span><br><span class="line">spi_message_add_tail(t, &amp;msg);<span class="comment">/* 将spi_transfer 添加到spi_message 队列 */</span></span><br><span class="line">ret = spi_sync(spi, &amp;msg); <span class="comment">/* 同步传输 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放内存 */</span></span><br><span class="line">kfree(t);</span><br><span class="line">kfree(tx_data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="open-函数">open 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">icm20608_deinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 电源管理寄存器1 复位icm20608</span></span><br><span class="line">value = <span class="number">0x80</span>;</span><br><span class="line">icm20608_write_reg(&amp;<span class="type">icm20608_dev_t</span>, ICM20608_PWR_MGMT_1, &amp;value, <span class="number">1</span>);</span><br><span class="line">mdelay(<span class="number">50</span>);</span><br><span class="line">    <span class="comment">// 自动选择最好的时钟源，否则选择内部20MHz晶振</span></span><br><span class="line">value = <span class="number">0x01</span>;</span><br><span class="line">icm20608_write_reg(&amp;<span class="type">icm20608_dev_t</span>, ICM20608_PWR_MGMT_1, &amp;value, <span class="number">1</span>);</span><br><span class="line">mdelay(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ID 寄存器，ICM-20608 的ID为0XAF</span></span><br><span class="line">icm20608_read_reg(&amp;<span class="type">icm20608_dev_t</span>, ICM20608_WHO_AM_I, &amp;value, <span class="number">1</span>);</span><br><span class="line">printk(<span class="string">&quot;ICM20608 ID = %x\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置输出速率分频数：0即速率为INTERNAL_SAMPLE_RATE 8kHz</span></span><br><span class="line">value = <span class="number">0x00</span>;</span><br><span class="line">icm20608_write_reg(&amp;<span class="type">icm20608_dev_t</span>, ICM20608_SMPLRT_DIV, &amp;value, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 设置低通滤波器</span></span><br><span class="line">value = <span class="number">0x04</span>;</span><br><span class="line">icm20608_write_reg(&amp;<span class="type">icm20608_dev_t</span>, ICM20608_CONFIG, &amp;value, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 设置陀螺仪量程 ±2000dps</span></span><br><span class="line">value = <span class="number">0x18</span>; </span><br><span class="line">icm20608_write_reg(&amp;<span class="type">icm20608_dev_t</span>, ICM20608_GYRO_CONFIG, &amp;value, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 设置加速度计的量程 ±16g</span></span><br><span class="line">value = <span class="number">0x18</span>;</span><br><span class="line">icm20608_write_reg(&amp;<span class="type">icm20608_dev_t</span>, ICM20608_ACCEL_CONFIG, &amp;value, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 设置加速度计低通滤波</span></span><br><span class="line">value = <span class="number">0x04</span>;</span><br><span class="line">icm20608_write_reg(&amp;<span class="type">icm20608_dev_t</span>, ICM20608_ACCEL_CONFIG2, &amp;value, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 设置陀螺仪低功耗不使能</span></span><br><span class="line">value = <span class="number">0x00</span>;</span><br><span class="line">icm20608_write_reg(&amp;<span class="type">icm20608_dev_t</span>, ICM20608_LP_MODE_CFG, &amp;value, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 设置FIFO不使能</span></span><br><span class="line">value = <span class="number">0x00</span>;</span><br><span class="line">icm20608_write_reg(&amp;<span class="type">icm20608_dev_t</span>, ICM20608_FIFO_EN, &amp;value, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 电源管理寄存器2 全部使能</span></span><br><span class="line">value = <span class="number">0x00</span>;</span><br><span class="line">icm20608_write_reg(&amp;<span class="type">icm20608_dev_t</span>, ICM20608_PWR_MGMT_2, &amp;value, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">file-&gt;private_data = &amp;<span class="type">icm20608_dev_t</span>;</span><br><span class="line"></span><br><span class="line">icm20608_deinit();</span><br><span class="line">printk(<span class="string">&quot;icm20608_deinit ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="read-函数">read 函数</h4><p>这里需要注意的就是接收到的数据是 8 位的，在合并数据时，数据移位需要提前转换成 uint16_t 类型，否则会丢失数据，最后将合并成的数据存入 kbuf，使用 copy_to_user 将数据传送给应用程序。</p><p>这里接收的数据是 ADC 模拟值不是实际值，需要根据寄存器设置的分辨率进行转换，因为<strong>涉及到浮点运算，就没有在驱动文件里面写，后面再应用程序进行运算即可。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_read_data</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">uint8_t</span> data[<span class="number">14</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">ret = icm20608_read_reg(dev, ACCEL_XOUT_H, data, <span class="number">14</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;icm20608_read_data failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dev-&gt;data.accel_x = (((<span class="type">int16_t</span>)data[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">1</span>]);</span><br><span class="line">dev-&gt;data.accel_y = (((<span class="type">int16_t</span>)data[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">3</span>]);</span><br><span class="line">dev-&gt;data.accel_z = (((<span class="type">int16_t</span>)data[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">dev-&gt;data.temperature = (((<span class="type">int16_t</span>)data[<span class="number">6</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">dev-&gt;data.gyro_x = (((<span class="type">int16_t</span>)data[<span class="number">8</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">9</span>]);</span><br><span class="line">dev-&gt;data.gyro_y = (((<span class="type">int16_t</span>)data[<span class="number">10</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">11</span>]);</span><br><span class="line">dev-&gt;data.gyro_z = (((<span class="type">int16_t</span>)data[<span class="number">12</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">13</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">icm20608_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *ubuf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *<span class="type">loff_t</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">int16_t</span> kbuf[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> icm20608_dev *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">printk(<span class="string">&quot;icm20608_read start\n&quot;</span>);</span><br><span class="line">ret = icm20608_read_data(dev);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;icm20608_read error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kbuf[<span class="number">0</span>] = dev-&gt;data.accel_x;</span><br><span class="line">kbuf[<span class="number">1</span>] = dev-&gt;data.accel_y;</span><br><span class="line">kbuf[<span class="number">2</span>] = dev-&gt;data.accel_z;</span><br><span class="line">kbuf[<span class="number">3</span>] = dev-&gt;data.gyro_x;</span><br><span class="line">kbuf[<span class="number">4</span>] = dev-&gt;data.gyro_y;</span><br><span class="line">kbuf[<span class="number">5</span>] = dev-&gt;data.gyro_z;</span><br><span class="line">kbuf[<span class="number">6</span>] = dev-&gt;data.temperature;</span><br><span class="line"></span><br><span class="line">ret = copy_to_user(ubuf, kbuf, <span class="keyword">sizeof</span>(kbuf));</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;copy_to_user error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">&quot;icm20608_read ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用程序测试">应用程序测试</h2><p>ADC 模拟值转换为实际值取决于陀螺仪和加速度计的分辨率。</p><p>由于寄存器配置时，陀螺仪和加速度计的测量量程范围不同，分辨率就不同，数据手册里面不同测量量程对应不同的分辨率如下：</p><p><img src="image-20240701220844905.png" alt="image-20240701220844905"></p><p><img src="image-20240701220749049.png" alt="image-20240701220749049"></p><p><img src="image-20240701220901623.png" alt="image-20240701220901623"></p><p><img src="image-20240701220800594.png" alt="image-20240701220800594"></p><p>ADC 模拟值转换实际值转换过程如下：16 位 ADC</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>实际值</mtext><mo>=</mo><mfrac><mrow><mi>A</mi><mi>D</mi><mi>C</mi><mtext>模拟值</mtext></mrow><msup><mn>2</mn><mn>15</mn></msup></mfrac><mtext>测量量程的最大值</mtext></mrow><annotation encoding="application/x-tex">实际值 = \frac{ADC模拟值}{2^{15}}测量量程的最大值</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">际</span><span class="mord cjk_fallback">值</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback">模</span><span class="mord cjk_fallback">拟</span><span class="mord cjk_fallback">值</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord cjk_fallback">测</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">程</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">值</span></span></span></span></span></p><p>本质上读取的值在 ADC 模拟值的测量范围的位置映射到具体测量量程的位置。（ADC 模拟值没有含义需要转换成有意义的值）</p><p>FS_SEL = 3时，测量量程为 ±2000dps时，陀螺仪转换如下：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>实际值</mtext><mo>=</mo><mfrac><mrow><mi>A</mi><mi>D</mi><mi>C</mi><mtext>模拟值</mtext></mrow><msup><mn>2</mn><mn>15</mn></msup></mfrac><mn>2000</mn><mo>=</mo><mfrac><mrow><mi>A</mi><mi>D</mi><mi>C</mi><mtext>模拟值</mtext></mrow><mn>16.4</mn></mfrac></mrow><annotation encoding="application/x-tex">实际值 = \frac{ADC模拟值}{2^{15}}2000=\frac{ADC模拟值}{16.4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">际</span><span class="mord cjk_fallback">值</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback">模</span><span class="mord cjk_fallback">拟</span><span class="mord cjk_fallback">值</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">6</span><span class="mord">.</span><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback">模</span><span class="mord cjk_fallback">拟</span><span class="mord cjk_fallback">值</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>AFS_SEL = 3时，测量量程为 ±16g 时，陀螺仪转换如下：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>实际值</mtext><mo>=</mo><mfrac><mrow><mi>A</mi><mi>D</mi><mi>C</mi><mtext>模拟值</mtext></mrow><msup><mn>2</mn><mn>15</mn></msup></mfrac><mn>16</mn><mo>=</mo><mfrac><mrow><mi>A</mi><mi>D</mi><mi>C</mi><mtext>模拟值</mtext></mrow><mn>2048</mn></mfrac></mrow><annotation encoding="application/x-tex">实际值 = \frac{ADC模拟值}{2^{15}}16=\frac{ADC模拟值}{2048}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">际</span><span class="mord cjk_fallback">值</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback">模</span><span class="mord cjk_fallback">拟</span><span class="mord cjk_fallback">值</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">0</span><span class="mord">4</span><span class="mord">8</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback">模</span><span class="mord cjk_fallback">拟</span><span class="mord cjk_fallback">值</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>温度转换成实际值：<code>RoomTemp_Offset</code> 是在 25°C 时的 ADC值偏移量，而 <code>Temp_Sensitivity</code> 是温度传感器的灵敏度，表示每单位温度变化对应的 ADC 计数变化。</p><p><img src="image-20240702000840441.png" alt="image-20240702000840441"></p><p>因此计算方式为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>u</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>a</mi><mi>c</mi><mi>t</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>u</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>a</mi><mi>d</mi><mi>c</mi></mrow></msub><mtext>−</mtext><mn>25</mn></mrow><mn>326.8</mn></mfrac><mo>+</mo><mn>25</mn></mrow><annotation encoding="application/x-tex">temperature_{act}=\frac{temperature_{adc}−25}{326.8}+25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span><span class="mord">2</span><span class="mord">6</span><span class="mord">.</span><span class="mord">8</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">2</span><span class="mord">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span></span></span></span></span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd, ret;</span><br><span class="line"><span class="type">int16_t</span> buf[<span class="number">7</span>];</span><br><span class="line"><span class="type">int16_t</span> accel_x_adc, accel_y_adc, accel_z_adc,</span><br><span class="line">gyro_x_adc, gyro_y_adc, gyro_z_adc,</span><br><span class="line">temperature_adc;</span><br><span class="line"><span class="type">float</span> accel_x_act, accel_y_act, accel_z_act,</span><br><span class="line">  gyro_x_act, gyro_y_act, gyro_z_act,</span><br><span class="line">  temperature_act;</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">&quot;/dev/icm20608&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">accel_x_adc= buf[<span class="number">0</span>];</span><br><span class="line">accel_y_adc = buf[<span class="number">1</span>];</span><br><span class="line">accel_z_adc = buf[<span class="number">2</span>];</span><br><span class="line">gyro_x_adc = buf[<span class="number">3</span>];</span><br><span class="line">gyro_y_adc = buf[<span class="number">4</span>];</span><br><span class="line">gyro_z_adc = buf[<span class="number">5</span>];</span><br><span class="line">temperature_adc = buf[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">accel_x_act = (<span class="type">float</span>)(accel_x_adc) / <span class="number">2048</span>;</span><br><span class="line">accel_y_act = (<span class="type">float</span>)(accel_y_adc) / <span class="number">2048</span>;</span><br><span class="line">accel_z_act = (<span class="type">float</span>)(accel_z_adc) / <span class="number">2048</span>;</span><br><span class="line">gyro_x_act = (<span class="type">float</span>)(gyro_x_adc) / <span class="number">16.4</span>;</span><br><span class="line">gyro_y_act = (<span class="type">float</span>)(gyro_y_adc) / <span class="number">16.4</span>;</span><br><span class="line">gyro_z_act = (<span class="type">float</span>)(gyro_z_adc) / <span class="number">16.4</span>;</span><br><span class="line">temperature_act = (<span class="type">float</span>)(temperature_adc - <span class="number">25</span>) / <span class="number">326.8</span> + <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\r\n 原始值:\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;gx = %d, gy = %d, gz = %d\r\n&quot;</span>, gyro_x_adc,gyro_y_adc, gyro_z_adc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ax = %d, ay = %d, az = %d\r\n&quot;</span>, accel_x_adc, accel_y_adc, accel_z_adc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;temp = %d\r\n&quot;</span>, temperature_adc);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;实际值:&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;act gx = %.2f°/S, act gy = %.2f°/S,act gz = %.2f°/S\r\n&quot;</span>, gyro_x_act, gyro_y_act, gyro_z_act);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;act ax = %.2fg, act ay = %.2fg,act az = %.2fg\r\n&quot;</span>, accel_x_act, accel_y_act, accel_z_act);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;act temp = %.2f°C\r\n&quot;</span>, temperature_act);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">usleep(<span class="number">100000</span>); <span class="comment">/*100ms */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;linux-spi-icm20608&quot;&gt;Linux-SPI-ICM20608&lt;/h2&gt;
&lt;h2 id=&quot;环境&quot;&gt;环境&lt;/h2&gt;
&lt;h3 id=&quot;硬件环境&quot;&gt;硬件环境&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;开发板型号&lt;/strong&gt;： &lt;a href=&quot;ht</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/Linux/"/>
    
    
    <category term="Linux" scheme="http://www.obito.top/tags/Linux/"/>
    
    <category term="嵌入式" scheme="http://www.obito.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux-I2C-AP3216C</title>
    <link href="http://www.obito.top/2024/06/27/Linux-I2C-AP3216C/"/>
    <id>http://www.obito.top/2024/06/27/Linux-I2C-AP3216C/</id>
    <published>2024-06-27T07:46:19.000Z</published>
    <updated>2024-08-22T14:38:39.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-i2c-ap3216c">Linux-I2C-AP3216C</h1><h2 id="环境">环境</h2><h3 id="硬件环境">硬件环境</h3><ul><li><strong>开发板型号</strong>：<a href="https://blog.csdn.net/thisway_diy/article/details/109841372">100ask_imx6ull_pro 开发板</a></li><li><strong>处理器类型</strong>：NXP IMX6ULL</li><li><strong>处理器架构</strong>：恩单核 Cortex-A7</li><li><strong>处理器主频</strong>：800 MHZ</li><li><strong>内存容量</strong>：512 MB DDR3</li><li><strong>存储介质</strong>：4GB eMMC</li><li><strong>本次测试的驱动</strong>：AP3216C 传感器芯片</li></ul><h3 id="软件环境">软件环境</h3><ul><li>宿主机<ul><li><strong>宿主机操作系统</strong>：Ubuntu 18.04</li><li><strong>交叉编译器</strong>：100ask 提供的工具链 arm-buildroot-linux-gnueabihf- <strong>支持的最低内核版本</strong>：4.9.0</li></ul></li><li>开发板<ul><li><strong>U-Boot</strong>：一开始用的 NXP 官方提供的版本但不能正常启动内核，后改为 100ask 提供的版本</li><li><strong>内核版本</strong>： <a href="https://github.com/nxp-imx/linux-imx/tree/imx_4.9.88_2.0.0_ga">NXP 提供的 4.9.88 版本</a></li><li><strong>根文件系统类型</strong>：<a href="https://busybox.net/downloads/">BusyBox 1.29.0</a></li></ul></li></ul><h2 id="ap3216c-介绍">AP3216C 介绍</h2><p>AP3216C 是一款由敦南科技研发的高度集成的三合一环境传感器组件，集成了环境光传感器（ALS——Ambient Light Sensor）、接近传感器（PS——Proximity Sensor）和红外 LED（IR LED——Infrared LED）的三合一数字模块。</p><ul><li>I2C 接口（工作在 FS 模式，400kHz）</li><li>环境光传感器具有 16 位 ADC 输出，确保高精度的环境光检测</li><li>接近传感器具有 10 位 ADC 输出(0~1023)，用于精确的接近距离测量</li><li>设备地址：0x1E，寄存器 8 位，寄存器位宽 8 位</li></ul><p>AP3216C 广泛应用于手机和平板电脑等便携式设备中，例如用于自动调节屏幕背光亮度（根据环境光线强度变化调整），以及在打电话时检测脸部接近的距离以实现熄屏、解锁等功能。</p><p>原理图如下：</p><p><img src="image-20240628110159381.png" alt="image-20240628110159381"></p><p>涉及到的寄存器：</p><p><img src="image-20240628112648480.png" alt="image-20240628112648480"></p><p>SYSTEM_CONFIGURATION 寄存器的配置表：</p><p><img src="image-20240628112802571.png" alt="image-20240628112802571"></p><p>开启三种模式，并且是连续测量的，采集 ALS 需要 100 ms，PS 需要 12.5 ms，因此后续在测试程序的时候需要采集间隔需要延时大于 112.5 ms。</p><p><img src="image-20240628112905922.png" alt="image-20240628112905922"></p><p>复位，复位后需等待 10 ms 以上。</p><p><img src="image-20240628112914332.png" alt="image-20240628112914332"></p><p>接近程度判定依据是通过两组 PS 高低阈值寄存器和 PS Data 寄存器 进行比对，PS Data 高于 PS High Threshold 则判定物体远离，PS Data 低于 PS Low Threshold 则判定物体靠近。</p><h2 id="驱动代码编写">驱动代码编写</h2><h3 id="设备描述信息">设备描述信息</h3><h4 id="无设备树">无设备树</h4><p>无设备树的话，则需要使用 <code>i2c_board_info</code> 结构体添加设备名字和设备地址，接着将设备挂载到对应 I2C 总线。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个i2c适配器指针</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">i2c_adap</span>;</span></span><br><span class="line"><span class="comment">// 分配一个i2c_client指针</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">i2c_client</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> <span class="title">ap3216c_info</span>[] =</span> &#123;</span><br><span class="line">&#123;I2C_BOARD_INFO(<span class="string">&quot;ap3216c&quot;</span>, <span class="number">0x1e</span>)&#125;,</span><br><span class="line">&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ap3216c_i2c_client_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;ap3216c_i2c_client_init init\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原理图是连接到了I2C1 </span></span><br><span class="line"><span class="comment">// 传入0表示 i2c1;1表示i2c2 找了半天md</span></span><br><span class="line"><span class="comment">//调用i2c_get_adapter获得一个i2c总线 将ap3216c挂载到i2c1总线上</span></span><br><span class="line">i2c_adap = i2c_get_adapter(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把i2c client和i2c器件关联起来</span></span><br><span class="line">i2c_client = i2c_new_device(i2c_adap, ap3216c_info);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放i2c控制器</span></span><br><span class="line">i2c_put_adapter(i2c_adap);</span><br><span class="line"></span><br><span class="line">printk(<span class="string">&quot;i2c_new_device ok\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ap3216c_i2c_client_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将前面注册的i2c_driver 也从Linux 内核中注销掉</span></span><br><span class="line">i2c_unregister_device(i2c_client);</span><br><span class="line"></span><br><span class="line">printk(<span class="string">&quot;ap3216c_i2c_client_exit exit ok\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(ap3216c_i2c_client_init);</span><br><span class="line">module_exit(ap3216c_i2c_client_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="设备树">设备树</h4><p>有设备树的话，则需要在设备树中的 I2C 节点中添加设备的信息，接着编译设备树烧录到开发板中。添加信息大致如下：</p><p>由原理图可知，该开发板的 AP3216C 是挂载在 i2c1 下的，i2c1 的引脚复用关系已经有了，因此只需要在 i2c1 节点下添加设备信息即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&amp;iomuxc &#123;</span><br><span class="line">    // 省略...</span><br><span class="line">pinctrl_i2c1: i2c1grp &#123;</span><br><span class="line">            fsl,pins = &lt;</span><br><span class="line">                MX6UL_PAD_UART4_TX_DATA__I2C1_SCL 0x4001b8b0</span><br><span class="line">                MX6UL_PAD_UART4_RX_DATA__I2C1_SDA 0x4001b8b0</span><br><span class="line">            &gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    // 省略...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&amp;i2c1 &#123;</span><br><span class="line">    clock-frequency = &lt;100000&gt;;</span><br><span class="line">    pinctrl-names = &quot;default&quot;;</span><br><span class="line">    pinctrl-0 = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">    status = &quot;okay&quot;;</span><br><span class="line"></span><br><span class="line">    ap3216c@1e &#123; </span><br><span class="line">        compatible = &quot;ap3216c&quot;; </span><br><span class="line">        reg = &lt;0x1e&gt;;</span><br><span class="line">        status = &quot;okay&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="driver-驱动代码">driver 驱动代码</h3><p>这一部分主要是注册 i2c_driver 结构体、添加设备节点、编写 file_operation 中的 open、release、read 成员，open 对 AP3216C 进行初始化——复位和设置模式，read 读取相对应数据的寄存器，release 设置休眠模式。</p><h4 id="寄存器宏定义和-ap3216c-dev-结构体">寄存器宏定义和 ap3216c_dev 结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span> <span class="comment">/*注册设备节点的文件结构体*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span> <span class="comment">// 对字符设备结构cdev 以及一系列的操作函数的定义。包含了cdev 结构及相关函数的定义。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span> <span class="comment">//包含了device、class 等结构的定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span> <span class="comment">//包含了copy_to_user、copy_from_user 等内核访问用户进程内存地址的函数定义。</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字符设备 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_NAME <span class="string">&quot;ap3216c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* AP3216C寄存器 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_SYSTEM_CONFIGURATION 0x00<span class="comment">/* 配置寄存器 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_IRDATALOW 0x0A <span class="comment">/* IR数据低字节 */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_IRDATAHIGH 0x0B <span class="comment">/* IR数据高字节 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_ALSDATALOW 0x0C <span class="comment">/* ALS数据低字节 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_ALSDATAHIGH 0X0D <span class="comment">/* ALS数据高字节 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_PSDATALOW 0X0E <span class="comment">/* PS数据低字节 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_PSDATAHIGH 0X0F<span class="comment">/* PS数据高字节 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span>&#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;<span class="comment">/* 设备号 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">/* cdev  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span><span class="comment">/* 类 */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* 设备 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span><span class="comment">/* 设备节点 */</span></span><br><span class="line"><span class="type">int</span> major;<span class="comment">/* 主设备号 */</span></span><br><span class="line"><span class="type">void</span> *private_data;<span class="comment">/* 私有数据 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> ir, als, ps;<span class="comment">/* 三个光传感器数据 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span> <span class="title">ap3216c_dev_t</span>;</span></span><br></pre></td></tr></table></figure><h4 id="注册-注销-i2c-driver结构体">注册/注销 i2c_driver结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设备树compatible匹配表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table</span>[] =</span> &#123;</span><br><span class="line">&#123;.compatible = <span class="string">&quot;ap3216c&quot;</span>&#125;, </span><br><span class="line">&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 无设备树的匹配ID表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">id_table</span>[] =</span> &#123;</span><br><span class="line">&#123;<span class="string">&quot;ap3216c&quot;</span>&#125;,</span><br><span class="line">&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义i2c总线设备结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ap3216c_i2c_driver</span> =</span> &#123;</span><br><span class="line">.driver = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.name  = <span class="string">&quot;ap3216c&quot;</span>,</span><br><span class="line">.of_match_table = of_match_table,</span><br><span class="line">&#125;,</span><br><span class="line">.probe= ap3216c_i2c_driver_probe,</span><br><span class="line">.remove = ap3216c_i2c_driver_remove,</span><br><span class="line">.id_table= id_table,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ap3216c_i2c_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="comment">// 注册 i2c 驱动</span></span><br><span class="line">ret = i2c_add_driver(&amp;ap3216c_i2c_driver);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ap3216c_i2c_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将前面注册的i2c_driver也从Linux内核中注销掉</span></span><br><span class="line">i2c_del_driver(&amp;ap3216c_i2c_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(ap3216c_i2c_driver_init);</span><br><span class="line">module_exit(ap3216c_i2c_driver_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="添加字符设备">添加字符设备</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ap3216c_fops</span> =</span> &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.open   = ap3216c_open,</span><br><span class="line">.release  = ap3216c_close,</span><br><span class="line">.read= ap3216c_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_i2c_driver_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 1.分配设备号</span></span><br><span class="line"><span class="keyword">if</span>(<span class="type">ap3216c_dev_t</span>.major)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">ap3216c_dev_t</span>.devid = MKDEV(<span class="type">ap3216c_dev_t</span>.major, <span class="number">0</span>);</span><br><span class="line">register_chrdev_region(<span class="type">ap3216c_dev_t</span>.devid, <span class="number">1</span>, AP3216C_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">alloc_chrdev_region(&amp;<span class="type">ap3216c_dev_t</span>.devid, <span class="number">0</span>, <span class="number">1</span>, AP3216C_NAME);</span><br><span class="line"><span class="type">ap3216c_dev_t</span>.major = MAJOR(<span class="type">ap3216c_dev_t</span>.devid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 初始化cdev</span></span><br><span class="line">cdev_init(&amp;<span class="type">ap3216c_dev_t</span>.cdev, &amp;ap3216c_fops);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.添加设备号到cdev</span></span><br><span class="line">cdev_add(&amp;<span class="type">ap3216c_dev_t</span>.cdev, <span class="type">ap3216c_dev_t</span>.devid, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建类</span></span><br><span class="line"><span class="type">ap3216c_dev_t</span>.class = class_create(THIS_MODULE, AP3216C_NAME);</span><br><span class="line"><span class="keyword">if</span>(IS_ERR(<span class="type">ap3216c_dev_t</span>.class))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="type">ap3216c_dev_t</span>.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 类下创建设备</span></span><br><span class="line"><span class="type">ap3216c_dev_t</span>.device = device_create(<span class="type">ap3216c_dev_t</span>.class, <span class="literal">NULL</span>, <span class="type">ap3216c_dev_t</span>.devid, <span class="literal">NULL</span>, AP3216C_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="type">ap3216c_dev_t</span>.device))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="type">ap3216c_dev_t</span>.device);</span><br><span class="line"></span><br><span class="line"><span class="type">ap3216c_dev_t</span>.private_data = client;</span><br><span class="line"></span><br><span class="line">printk(<span class="string">&quot;ap3216c_i2c_driver_probe ok\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_i2c_driver_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 1.注销设备号</span></span><br><span class="line">unregister_chrdev_region(<span class="type">ap3216c_dev_t</span>.devid, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 2.删除设备</span></span><br><span class="line">cdev_del(&amp;<span class="type">ap3216c_dev_t</span>.cdev);</span><br><span class="line"><span class="comment">// 3.注销设备节点</span></span><br><span class="line">device_destroy(<span class="type">ap3216c_dev_t</span>.class, <span class="type">ap3216c_dev_t</span>.devid);</span><br><span class="line"><span class="comment">// 4.删除类</span></span><br><span class="line">class_destroy(<span class="type">ap3216c_dev_t</span>.class);</span><br><span class="line"></span><br><span class="line">printk(<span class="string">&quot;ap3216c_i2c_driver_remove ok\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收发数据函数">收发数据函数</h4><p>主要就是填充 i2c_msg 结构体，例如设备地址、写数据/读数据，寄存器的地址、msg 的长度，写入数据的缓冲区和读取数据的缓冲区，然后调用 i2c_transfer 函数进行传输数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : 读取I2C 设备多个寄存器数据</span></span><br><span class="line"><span class="comment">* @param – dev : I2C 设备</span></span><br><span class="line"><span class="comment">* @param – reg : 要读取的寄存器首地址</span></span><br><span class="line"><span class="comment">* @param – val : 读取到的数据</span></span><br><span class="line"><span class="comment">* @param – len : 要读取的数据长度</span></span><br><span class="line"><span class="comment">* @return : 操作结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_read_reg</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, <span class="type">uint8_t</span> reg, <span class="type">uint8_t</span> *val, <span class="type">uint16_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* msg[0]，第一条写消息，发送要读取的寄存器首地址*/</span></span><br><span class="line">msg[<span class="number">0</span>].addr = client-&gt;addr;<span class="comment">// 设备地址</span></span><br><span class="line">msg[<span class="number">0</span>].flags = <span class="number">0</span>;<span class="comment">// 写数据</span></span><br><span class="line">msg[<span class="number">0</span>].buf = &amp;reg;<span class="comment">// 寄存器地址</span></span><br><span class="line">msg[<span class="number">0</span>].len = <span class="number">1</span>;<span class="comment">// msg长度：寄存器地址长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* msg[1]，第二条读消息，读取寄存器数据*/</span></span><br><span class="line">msg[<span class="number">1</span>].addr = client-&gt;addr;<span class="comment">// 设备地址</span></span><br><span class="line">msg[<span class="number">1</span>].flags = I2C_M_RD;<span class="comment">// 读数据</span></span><br><span class="line">msg[<span class="number">1</span>].buf= val;<span class="comment">// 读取的数据</span></span><br><span class="line">msg[<span class="number">1</span>].len = len;<span class="comment">// msg长度：读取数据的长度</span></span><br><span class="line"></span><br><span class="line">ret =  i2c_transfer(client-&gt;adapter, msg, <span class="number">2</span>);<span class="comment">// 2个msg</span></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">2</span>)</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = -EREMOTEIO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : 向 I2C 设备多个寄存器写入数据</span></span><br><span class="line"><span class="comment">* @param – dev : 要写入的设备结构体</span></span><br><span class="line"><span class="comment">* @param – reg : 要写入的寄存器首地址</span></span><br><span class="line"><span class="comment">* @param – val : 要写入的数据缓冲区</span></span><br><span class="line"><span class="comment">* @param – len : 要写入的数据长度</span></span><br><span class="line"><span class="comment">* @return : 操作结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_write_reg</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, <span class="type">uint8_t</span> reg, <span class="type">uint8_t</span> *buf, <span class="type">uint16_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> tmp[<span class="number">256</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>;</span><span class="comment">// 存放待写入的寄存器地址和数据等信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    tmp[<span class="number">0</span>] = reg;               <span class="comment">// 寄存器地址</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;tmp[<span class="number">1</span>], buf, len); <span class="comment">// 写入的数据</span></span><br><span class="line"></span><br><span class="line">msg.addr = client-&gt;addr;<span class="comment">// 设备地址</span></span><br><span class="line">msg.flags = <span class="number">0</span>;<span class="comment">// 写数据</span></span><br><span class="line">msg.buf = tmp;<span class="comment">// 发送的数据缓冲区</span></span><br><span class="line">msg.len = len + <span class="number">1</span>;<span class="comment">// msg长度：写入的数据长度 + 寄存器地址长度 （单位：字节)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>);<span class="comment">// 1个msg</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="open-函数：">open 函数：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> value;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.复位 </span></span><br><span class="line">file-&gt;private_data = &amp;<span class="type">ap3216c_dev_t</span>;</span><br><span class="line">value = <span class="number">0x04</span>;</span><br><span class="line">ret = ap3216c_write_reg(&amp;<span class="type">ap3216c_dev_t</span>, AP3216C_SYSTEM_CONFIGURATION, &amp;value, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;%s, %s, %d error\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.复位完需要等待10ms以上</span></span><br><span class="line">mdelay(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.设置模式为ALS+PS+IR</span></span><br><span class="line">value = <span class="number">0x03</span>;</span><br><span class="line">ret = ap3216c_write_reg(&amp;<span class="type">ap3216c_dev_t</span>, AP3216C_SYSTEM_CONFIGURATION, &amp;value, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;%s, %s, %d error\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="read-函数">read 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : 读取AP3216C的数据，读取原始数据，包括ALS,PS和IR, 142 </span></span><br><span class="line"><span class="comment">*   : 同时打开ALS,IR+PS的话两次数据读取的间隔要大于112.5ms</span></span><br><span class="line"><span class="comment">* @param - dev : ap3216c_dev结构体，存放传感器数据：ir、als、ps</span></span><br><span class="line"><span class="comment">* @return : 操作结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ap3216c_read_data</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">uint8_t</span> buf[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">ap3216c_read_reg(dev, AP3216C_IRDATALOW + i, &amp;buf[i], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取 IR 传感器的数据 */</span></span><br><span class="line"><span class="keyword">if</span>(buf[<span class="number">0</span>] &amp; <span class="number">0x80</span>)</span><br><span class="line">&#123;</span><br><span class="line">dev-&gt;ir = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">// 需要转16位再移位，否则会丢失数据</span></span><br><span class="line">dev-&gt;ir = ((<span class="type">uint16_t</span>)buf[<span class="number">1</span>] &lt;&lt; <span class="number">2</span>) | (buf[<span class="number">0</span>] &amp; <span class="number">0x03</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取 ALS 数据 */</span></span><br><span class="line">dev-&gt;als = ((<span class="type">uint16_t</span>)buf[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取 PS 传感器的数据 */</span></span><br><span class="line"><span class="keyword">if</span>(buf[<span class="number">4</span>] &amp; <span class="number">0x40</span>)</span><br><span class="line">&#123;</span><br><span class="line">dev-&gt;ps = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">dev-&gt;ps = (((<span class="type">uint16_t</span>)buf[<span class="number">5</span>] &amp; <span class="number">0x3F</span>) &lt;&lt; <span class="number">4</span>) | (buf[<span class="number">4</span>] &amp; <span class="number">0x0F</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">ap3216c_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *ubuf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *<span class="type">loff_t</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">short</span> kbuf[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span> *<span class="title">dev</span> =</span> file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">ap3216c_read_data(dev);</span><br><span class="line">kbuf[<span class="number">0</span>] = dev-&gt;ir;</span><br><span class="line">kbuf[<span class="number">1</span>] = dev-&gt;als;</span><br><span class="line">kbuf[<span class="number">2</span>] = dev-&gt;ps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(copy_to_user(ubuf, kbuf, <span class="keyword">sizeof</span>(kbuf)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;%s, %s, %d error\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="release-函数">release 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> value;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.休眠</span></span><br><span class="line">file-&gt;private_data = &amp;<span class="type">ap3216c_dev_t</span>;</span><br><span class="line">value = <span class="number">0x00</span>;</span><br><span class="line">ret = ap3216c_write_reg(&amp;<span class="type">ap3216c_dev_t</span>, AP3216C_SYSTEM_CONFIGURATION, &amp;value, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;%s, %s, %d error\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用测试程序">应用测试程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> databuf[<span class="number">3</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ir, als, ps;</span><br><span class="line">    <span class="comment">// 打开设备节点</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/ap3216c&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open ap3216c failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = read(fd, databuf, <span class="keyword">sizeof</span>(databuf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>) </span><br><span class="line">        &#123; <span class="comment">/* 数据读取成功 */</span></span><br><span class="line">          ir = databuf[<span class="number">0</span>]; <span class="comment">/* ir 传感器数据 */</span></span><br><span class="line">          als = databuf[<span class="number">1</span>]; <span class="comment">/* als 传感器数据 */</span></span><br><span class="line">          ps = databuf[<span class="number">2</span>]; <span class="comment">/* ps 传感器数据 */</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;ir = %d, als = %d, ps = %d\r\n&quot;</span>, ir, als, ps);</span><br><span class="line">        &#125;</span><br><span class="line">        usleep(<span class="number">200000</span>);<span class="comment">/* 间隔200ms 确保数据已经采集完成 */</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><p><img src="image-20240628133137808.png" alt="image-20240628133137808"></p><h2 id="参考资料">参考资料</h2><blockquote><p><a href="https://developer.aliyun.com/article/1083178">5_2_1_光照信息屏_硬件详解|学习笔记-阿里云开发者社区 (aliyun.com)</a></p><p><a href="https://www.bilibili.com/video/BV1fJ411i7PB/?p=80">https://www.bilibili.com/video/BV1fJ411i7PB/?p=80</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux-i2c-ap3216c&quot;&gt;Linux-I2C-AP3216C&lt;/h1&gt;
&lt;h2 id=&quot;环境&quot;&gt;环境&lt;/h2&gt;
&lt;h3 id=&quot;硬件环境&quot;&gt;硬件环境&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;开发板型号&lt;/strong&gt;：&lt;a href=&quot;https</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/Linux/"/>
    
    
    <category term="Linux" scheme="http://www.obito.top/tags/Linux/"/>
    
    <category term="嵌入式" scheme="http://www.obito.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux-SPI驱动</title>
    <link href="http://www.obito.top/2024/06/27/Linux-SPI%E9%A9%B1%E5%8A%A8/"/>
    <id>http://www.obito.top/2024/06/27/Linux-SPI%E9%A9%B1%E5%8A%A8/</id>
    <published>2024-06-26T16:04:47.000Z</published>
    <updated>2024-07-01T13:18:55.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-spi驱动">Linux-SPI驱动</h1><h2 id="序言">序言</h2><p><em><strong>SPI 具体通信协议本文不涉及，本文主要介绍在 Linux 中 SPI 的驱动框架。</strong></em></p><p>SPI 有四条线：SCLK、MOSI、MISO、SS/CS</p><ul><li>SCLK：时钟线</li><li>MOSI：主机数据输出从机数据输入</li><li>MISO：主机数据输入从机数据输出</li><li>SS/CS：片选信号，由主机控制</li></ul><p><strong>SPI 通信时，SPI 的片选信号可以作为硬件片选与软件片选。</strong></p><ul><li>硬件片选：如果选择使用硬件片选的方式，则在数据传输时，CS 片选信号的电平硬件上会拉低。当数据传输结束后，硬件上CS片选信号的电平拉高。</li><li>软件片选：软件片选即 SPI 通信过程中， CS 片选信号需要在软件上做处理，也就需要嵌入式开发者在数据传输前手动（程序中）拉低 CS 片选信号的电平，在数据传输结束后，也需要软件拉高 CS 片选信号的电平。</li></ul><h2 id="spi-驱动框架">SPI 驱动框架</h2><p>Linux SPI 驱动可分为：SPI 总线驱动和 SPI 设备驱动。</p><ul><li>SPI 总线驱动：主要包含 SPI 硬件体系结构中适配器(SPI 控制器)的控制，用于产生 SPI 读写时序。</li><li>SPI 设备驱动：通过 SPI 主机驱动与 CPU 交换数据。</li></ul><p>SPI 设备驱动涉及字符设备驱动、SPI 核心和 SPI 主机驱动。</p><ul><li><p>字符设备驱动：创建字符设备与应用程序访问数据。</p></li><li><p>SPI核心层：提供SPI控制器驱动和设备驱动的注册方法、注销方法、SPI通信硬件无关接口函数。</p></li><li><p>SPI主机驱动：主要包含SPI硬件体系结构中适配器(spi控制器)的控制，用于产生SPI 读写时序。</p></li></ul><h3 id="spi-总线驱动">SPI 总线驱动</h3><p>SPI 总线驱动主要是 SOC 的 SPI 控制器驱动，SPI 控制器驱动负责与硬件的 SPI 控制器进行交互，完成硬件层面的初始化、配置和操作。这一部分一般由<strong>芯片厂提供</strong>，例如 IMX6ULL 的 SPI 控制器驱动已经由 NXP 公司编写好了，这一部分只需要了解内部如何调用即可。</p><p>主要实现：</p><ul><li>申请并初始化 <code>spi_master</code> 结构体，同 I2C 的 <code>i2c_adapter</code>。</li><li>接着设置 transfer 函数，同 I2C 中的 <code>i2c_algorithm</code> 结构体中的 <code>master_xfer</code> 函数一样数据传输函数。</li><li>最后通过 <code>spi_register_master</code> 函数向 Linux 内核注册设置好的 <code>spi_master</code> 结构体。</li></ul><p><code>spi_master</code> 结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/spi/spi.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_master</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span><span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* other than negative (== assign one dynamically), bus_num is fully</span></span><br><span class="line"><span class="comment"> * board-specific.  usually that simplifies to being SOC-specific.</span></span><br><span class="line"><span class="comment"> * example:  one SOC has three SPI controllers, numbered 0..2,</span></span><br><span class="line"><span class="comment"> * and one board&#x27;s schematics might show it using SPI-2.  software</span></span><br><span class="line"><span class="comment"> * would normally use bus_num=2 for that controller.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">s16bus_num;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* chipselects will be integral to many controllers; some others</span></span><br><span class="line"><span class="comment"> * might use board-specific GPIOs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">u16num_chipselect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* some SPI controllers pose alignment requirements on DMAable</span></span><br><span class="line"><span class="comment"> * buffers; let protocol drivers know about these requirements.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">u16dma_alignment;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* spi_device.mode flags understood by this controller driver */</span></span><br><span class="line">u16mode_bits;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bitmask of supported bits_per_word for transfers */</span></span><br><span class="line">u32bits_per_word_mask;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_BPW_MASK(bits) BIT((bits) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_BIT_MASK(bits) (((bits) == 32) ? ~0U : (BIT(bits) - 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_BPW_RANGE_MASK(min, max) (SPI_BIT_MASK(max) - SPI_BIT_MASK(min - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* limits on transfer speed */</span></span><br><span class="line">u32min_speed_hz;</span><br><span class="line">u32max_speed_hz;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* other constraints relevant to this driver */</span></span><br><span class="line">u16flags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_MASTER_HALF_DUPLEXBIT(0)<span class="comment">/* can&#x27;t do full duplex */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_MASTER_NO_RXBIT(1)<span class="comment">/* can&#x27;t do buffer read */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_MASTER_NO_TXBIT(2)<span class="comment">/* can&#x27;t do buffer write */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_MASTER_MUST_RX      BIT(3)<span class="comment">/* requires rx */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_MASTER_MUST_TX      BIT(4)<span class="comment">/* requires tx */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * on some hardware transfer / message size may be constrained</span></span><br><span class="line"><span class="comment"> * the limit may depend on device transfer settings</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">size_t</span> (*max_transfer_size)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line"><span class="type">size_t</span> (*max_message_size)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I/O mutex */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span><span class="title">io_mutex</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* lock and mutex for SPI bus locking */</span></span><br><span class="line"><span class="type">spinlock_t</span>bus_lock_spinlock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span><span class="title">bus_lock_mutex</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* flag indicating that the SPI bus is locked for exclusive use */</span></span><br><span class="line"><span class="type">bool</span>bus_lock_flag;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Setup mode and clock, etc (spi driver may call many times).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * IMPORTANT:  this may be called when transfers to another</span></span><br><span class="line"><span class="comment"> * device are active.  DO NOT UPDATE SHARED REGISTERS in ways</span></span><br><span class="line"><span class="comment"> * which could break those transfers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>(*setup)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bidirectional bulk transfers</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * + The transfer() method may not sleep; its main role is</span></span><br><span class="line"><span class="comment"> *   just to add the message to the queue.</span></span><br><span class="line"><span class="comment"> * + For now there&#x27;s no remove-from-queue operation, or</span></span><br><span class="line"><span class="comment"> *   any other request management</span></span><br><span class="line"><span class="comment"> * + To a given spi_device, message queueing is pure fifo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * + The master&#x27;s main job is to process its message queue,</span></span><br><span class="line"><span class="comment"> *   selecting a chip then transferring data</span></span><br><span class="line"><span class="comment"> * + If there are multiple spi_device children, the i/o queue</span></span><br><span class="line"><span class="comment"> *   arbitration algorithm is unspecified (round robin, fifo,</span></span><br><span class="line"><span class="comment"> *   priority, reservations, preemption, etc)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * + Chipselect stays active during the entire message</span></span><br><span class="line"><span class="comment"> *   (unless modified by spi_transfer.cs_change != 0).</span></span><br><span class="line"><span class="comment"> * + The message transfers use clock and SPI mode parameters</span></span><br><span class="line"><span class="comment"> *   previously established by setup() for this device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>(*transfer)(<span class="keyword">struct</span> spi_device *spi,</span><br><span class="line"><span class="keyword">struct</span> spi_message *mesg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* called on release() to free memory provided by spi_master */</span></span><br><span class="line"><span class="type">void</span>(*cleanup)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Used to enable core support for DMA handling, if can_dma()</span></span><br><span class="line"><span class="comment"> * exists and returns true then the transfer will be mapped</span></span><br><span class="line"><span class="comment"> * prior to transfer_one() being called.  The driver should</span></span><br><span class="line"><span class="comment"> * not modify or store xfer and dma_tx and dma_rx must be set</span></span><br><span class="line"><span class="comment"> * while the device is prepared.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span>(*can_dma)(<span class="keyword">struct</span> spi_master *master,</span><br><span class="line">   <span class="keyword">struct</span> spi_device *spi,</span><br><span class="line">   <span class="keyword">struct</span> spi_transfer *xfer);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These hooks are for drivers that want to use the generic</span></span><br><span class="line"><span class="comment"> * master transfer queueing mechanism. If these are used, the</span></span><br><span class="line"><span class="comment"> * transfer() function above must NOT be specified by the driver.</span></span><br><span class="line"><span class="comment"> * Over time we expect SPI drivers to be phased over to this API.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span>queued;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kthread_worker</span><span class="title">kworker</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>*<span class="title">kworker_task</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kthread_work</span><span class="title">pump_messages</span>;</span></span><br><span class="line"><span class="type">spinlock_t</span>queue_lock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span>*<span class="title">cur_msg</span>;</span></span><br><span class="line"><span class="type">bool</span>idling;</span><br><span class="line"><span class="type">bool</span>busy;</span><br><span class="line"><span class="type">bool</span>running;</span><br><span class="line"><span class="type">bool</span>rt;</span><br><span class="line"><span class="type">bool</span>auto_runtime_pm;</span><br><span class="line"><span class="type">bool</span>                            cur_msg_prepared;</span><br><span class="line"><span class="type">bool</span>cur_msg_mapped;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span>               <span class="title">xfer_completion</span>;</span></span><br><span class="line"><span class="type">size_t</span>max_dma_len;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*prepare_transfer_hardware)(<span class="keyword">struct</span> spi_master *master);</span><br><span class="line"><span class="type">int</span> (*transfer_one_message)(<span class="keyword">struct</span> spi_master *master,</span><br><span class="line">    <span class="keyword">struct</span> spi_message *mesg);</span><br><span class="line"><span class="type">int</span> (*unprepare_transfer_hardware)(<span class="keyword">struct</span> spi_master *master);</span><br><span class="line"><span class="type">int</span> (*prepare_message)(<span class="keyword">struct</span> spi_master *master,</span><br><span class="line">       <span class="keyword">struct</span> spi_message *message);</span><br><span class="line"><span class="type">int</span> (*unprepare_message)(<span class="keyword">struct</span> spi_master *master,</span><br><span class="line"> <span class="keyword">struct</span> spi_message *message);</span><br><span class="line"><span class="type">int</span> (*spi_flash_read)(<span class="keyword">struct</span>  spi_device *spi,</span><br><span class="line">      <span class="keyword">struct</span> spi_flash_read_message *msg);</span><br><span class="line"><span class="type">bool</span> (*flash_read_supported)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These hooks are for drivers that use a generic implementation</span></span><br><span class="line"><span class="comment"> * of transfer_one_message() provied by the core.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> (*set_cs)(<span class="keyword">struct</span> spi_device *spi, <span class="type">bool</span> enable);</span><br><span class="line"><span class="type">int</span> (*transfer_one)(<span class="keyword">struct</span> spi_master *master, <span class="keyword">struct</span> spi_device *spi,</span><br><span class="line">    <span class="keyword">struct</span> spi_transfer *transfer);</span><br><span class="line"><span class="type">void</span> (*handle_err)(<span class="keyword">struct</span> spi_master *master,</span><br><span class="line">   <span class="keyword">struct</span> spi_message *message);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* gpio chip select */</span></span><br><span class="line"><span class="type">int</span>*cs_gpios;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* statistics */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_statistics</span><span class="title">statistics</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* DMA channels for use with core dmaengine helpers */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_chan</span>*<span class="title">dma_tx</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_chan</span>*<span class="title">dma_rx</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* dummy data for full duplex devices */</span></span><br><span class="line"><span class="type">void</span>*dummy_rx;</span><br><span class="line"><span class="type">void</span>*dummy_tx;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*fw_translate_cs)(<span class="keyword">struct</span> spi_master *master, <span class="type">unsigned</span> cs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="spi-设备驱动">SPI 设备驱动</h3><p>SPI 设备驱动主要是填充两个重要的结构体：<code>spi_client</code> 和 <code>spi_driver</code>，<code>spi_client</code> 是描述设备信息的，<code>spi_driver</code> 是描述驱动内容的，类似于平台总线驱动中的 <code>platform_device</code> 和 <code>platform_driver</code>，如果采用设备树的话，则只需要编写 <code>spi_driver</code> 结构体的内容即可，因为设备树中的 SPI 节点会转换为 <code>spi_client</code> 的内容。</p><p><code>spi_client</code> 结构体如下：</p><p>Linux 内核用 <code>spi_driver</code> 结构体表示 SPI 设备驱动，<code>spi_driver</code> 结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/spi/spi.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line"><span class="type">int</span>(*probe)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line"><span class="type">int</span>(*remove)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line"><span class="type">void</span>(*shutdown)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span><span class="title">driver</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>向内核注册 <code>spi_driver</code> 结构体：使用一个宏定义来代替直接包含头文件的方式获取 <code>THIS_MODULE</code>，从而避免头文件链式依赖。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/spi/spi.h</span></span><br><span class="line"><span class="comment">// drivers/spi/spi.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* use a define to avoid include chaining to get THIS_MODULE */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> spi_register_driver(driver) \</span></span><br><span class="line"><span class="meta">__spi_register_driver(THIS_MODULE, driver)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __spi_register_driver(<span class="keyword">struct</span> module *owner, <span class="keyword">struct</span> spi_driver *sdrv)</span><br><span class="line">&#123;</span><br><span class="line">sdrv-&gt;driver.owner = owner;</span><br><span class="line">sdrv-&gt;driver.bus = &amp;spi_bus_type;</span><br><span class="line"><span class="keyword">if</span> (sdrv-&gt;probe)</span><br><span class="line">sdrv-&gt;driver.probe = spi_drv_probe;</span><br><span class="line"><span class="keyword">if</span> (sdrv-&gt;remove)</span><br><span class="line">sdrv-&gt;driver.remove = spi_drv_remove;</span><br><span class="line"><span class="keyword">if</span> (sdrv-&gt;shutdown)</span><br><span class="line">sdrv-&gt;driver.shutdown = spi_drv_shutdown;</span><br><span class="line"><span class="keyword">return</span> driver_register(&amp;sdrv-&gt;driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体注册 spi_driver 的注册流程同 <code>platform_driver</code> 一致。</p><h4 id="spi-设备和驱动匹配过程">SPI 设备和驱动匹配过程</h4><p>SPI 设备和驱动的匹配过程是由 SPI 总线来完成的，这点和 platform、I2C 等驱动一样。</p><p>SPI 总线定义了一个 <code>bus_type</code> 结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/spi/spi.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">spi_bus_type</span> =</span> &#123;</span><br><span class="line">.name= <span class="string">&quot;spi&quot;</span>,</span><br><span class="line">.dev_groups= spi_dev_groups,</span><br><span class="line">.match= spi_match_device,</span><br><span class="line">.uevent= spi_uevent,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(spi_bus_type);<span class="comment">// 使得别的模块可调用该结构体</span></span><br></pre></td></tr></table></figure><p>匹配函数为 <code>spi_match_device</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spi_match_device</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span>*<span class="title">spi</span> =</span> to_spi_device(dev);</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span>*<span class="title">sdrv</span> =</span> to_spi_driver(drv);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Attempt an OF style match */</span></span><br><span class="line"><span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Then try ACPI */</span></span><br><span class="line"><span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sdrv-&gt;id_table)</span><br><span class="line"><span class="keyword">return</span> !!spi_match_id(sdrv-&gt;id_table, spi);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(spi-&gt;modalias, drv-&gt;name) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先 <code>of_driver_match_device</code> 函数用于完成设备树设备和驱动的匹配，比较设备节点的 compatible 属性和 <code>of_device_id</code> 结构体中的 compatible 属性是否相等。</p></li><li><p>若上一步匹配失败，则进行 ACPI 形式的匹配。</p></li><li><p>若上一半匹配也失败，则进行传统的无设备树的匹配方式，比较 <code>spi_driver</code> 结构体中的 <code>spi_device_id</code> 表和  <code>spi_device</code> 结构体中 <code>modalias</code> 成员变量是否有匹配的。</p></li><li><p>最后则是比较 <code>spi_device</code> 结构体中 <code>modalias</code> 成员变量和 <code>device_driver</code> 中的 <code>name</code> 成员变量是否相等。</p></li></ul><h2 id="spi-设备驱动代码编写">SPI 设备驱动代码编写</h2><p>首先是 SPI 设备的信息，有两种方法：未使用设备树和使用设备树。</p><h3 id="spi-设备信息描述">SPI 设备信息描述</h3><h4 id="未使用设备树">未使用设备树</h4><p>跟 I2C 类似，新建一个模块进行注册 <code>spi_device</code> 结构体。</p><h4 id="使用设备树">使用设备树</h4><p>使用设备树文件时，只需要在设备树文件中添加相应的 SPI 设备节点即可例如：添加 icm20608 设备，需要注意的是添加 SPI 设备节点有要求，形式如：别名:设备名@通道号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&amp;iomuxc &#123;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_hog_1&gt;;</span><br><span class="line">    imx6ul-evk &#123;</span><br><span class="line">pinctrl_ecspi3: ecspi3 &#123;              </span><br><span class="line">                    fsl,pins = &lt;</span><br><span class="line">                MX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI         <span class="number">0x000010B0</span></span><br><span class="line">                MX6UL_PAD_UART2_RTS_B__ECSPI3_MISO         <span class="number">0x000010B0</span></span><br><span class="line">                MX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK       <span class="number">0x000010B0</span></span><br><span class="line">                <span class="comment">//MX6UL_PAD_UART2_TX_DATA__ECSPI3_SS0        0x000010B0</span></span><br><span class="line">                MX6UL_PAD_UART2_TX_DATA__GPIO1_IO20        <span class="number">0x000010B0</span></span><br><span class="line">            &gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&amp;ecspi3 &#123; </span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_ecspi3&gt;;</span><br><span class="line">    cs-gpios = &lt;&amp;gpio1 <span class="number">20</span> GPIO_ACTIVE_LOW&gt;;<span class="comment">// 片选IO直接置0</span></span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    spidev: icm20608@<span class="number">0</span>&#123;<span class="comment">// 此处的命名有要求：设备名@通道号 0表示该设备使用 ECSPI 0通道</span></span><br><span class="line">        compatible = <span class="string">&quot;invensense,icm20608&quot;</span>;</span><br><span class="line">        interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">        interrupts = &lt;<span class="number">1</span> <span class="number">1</span>&gt;;</span><br><span class="line">        spi-max-frequency = &lt;<span class="number">8000000</span>&gt;; <span class="comment">// 最高频率8MHz</span></span><br><span class="line">        reg = &lt;<span class="number">0</span>&gt;; <span class="comment">// 这里表示该设备使用 ECSPI 0通道</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>MX6UL_PAD_UART2_TX_DATA__GPIO1_IO20 这个 IO 是 ICM20608 的片选信号，这里我们并没有将其复用为 ECSPI3的 SS0 信号，而是将其复用为了普通的 GPIO 。这里选择软件片选使用，NXP 的针对 IMX6U系列的 SPI 主机控制器驱动中，有实现 SPI 的软件片选！！</p><p>一定要使用 “cs-gpios” 属性来描述片选引脚，SPI主机驱动就会控制片选引脚，SPI主机控制器驱动实现了SPI的软件片选功能， 后面我们在编写SPI设备驱动时，软件上不用手动设置片选电平的高低。</p><p><a href="https://blog.csdn.net/wojiaxiaohuang2014/article/details/137755653">I.MX6ULL SPI 主机控制器驱动：软件片选处理（片选信号）_spi软件片选-CSDN博客</a></p></blockquote><p>drivers/spi/spi.c 中有函数将节点中的名为： <code>cs-gpios</code> 的 gpio 添加到 <code>spi_master</code> 结构体的 <code>cs_gpios</code> 成员中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">of_spi_register_master</span><span class="params">(<span class="keyword">struct</span> spi_master *master)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> nb, i, *cs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> master-&gt;dev.of_node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!np)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">nb = of_gpio_named_count(np, <span class="string">&quot;cs-gpios&quot;</span>);</span><br><span class="line">master-&gt;num_chipselect = <span class="type">max_t</span>(<span class="type">int</span>, nb, master-&gt;num_chipselect);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return error only for an incorrectly formed cs-gpios property */</span></span><br><span class="line"><span class="keyword">if</span> (nb == <span class="number">0</span> || nb == -ENOENT)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nb &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> nb;</span><br><span class="line"></span><br><span class="line">cs = devm_kzalloc(&amp;master-&gt;dev,</span><br><span class="line">  <span class="keyword">sizeof</span>(<span class="type">int</span>) * master-&gt;num_chipselect,</span><br><span class="line">  GFP_KERNEL);</span><br><span class="line">master-&gt;cs_gpios = cs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!master-&gt;cs_gpios)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; master-&gt;num_chipselect; i++)</span><br><span class="line">cs[i] = -ENOENT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nb; i++)</span><br><span class="line">cs[i] = of_get_named_gpio(np, <span class="string">&quot;cs-gpios&quot;</span>, i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IMX6ULL 的 ECSPI 主机驱动文件为 drivers/spi/spi-imx.c，有以下两个函数实现了软件片选 IO 的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spi_imx_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line">master-&gt;dev.of_node = pdev-&gt;dev.of_node;</span><br><span class="line">ret = spi_bitbang_start(&amp;spi_imx-&gt;bitbang);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;bitbang start failed with %d\n&quot;</span>, ret);</span><br><span class="line"><span class="keyword">goto</span> out_clk_put;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!master-&gt;cs_gpios) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;No CS GPIOs available\n&quot;</span>);</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out_clk_put;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; master-&gt;num_chipselect; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!gpio_is_valid(master-&gt;cs_gpios[i]))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">ret = devm_gpio_request(&amp;pdev-&gt;dev, master-&gt;cs_gpios[i],</span><br><span class="line">DRIVER_NAME);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Can&#x27;t get CS GPIO %i\n&quot;</span>,</span><br><span class="line">master-&gt;cs_gpios[i]);</span><br><span class="line"><span class="keyword">goto</span> out_clk_put;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;probed\n&quot;</span>);</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">spi_imx_chipselect</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="type">int</span> is_active)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> active = is_active != BITBANG_CS_INACTIVE;</span><br><span class="line"><span class="type">int</span> dev_is_lowactive = !(spi-&gt;mode &amp; SPI_CS_HIGH);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!gpio_is_valid(spi-&gt;cs_gpio))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">gpio_set_value(spi-&gt;cs_gpio, dev_is_lowactive ^ active);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spi-driver-驱动">SPI driver 驱动</h3><h4 id="注册-driver-驱动">注册 driver 驱动</h4><p>注册 <code>spi_driver</code> 结构体驱动文件通用结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spi/spi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> &#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;<span class="comment">/* 设备号 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">/* cdev  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span><span class="comment">/* 类 */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* 设备 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span><span class="comment">/* 设备节点 */</span></span><br><span class="line"><span class="type">int</span> major;<span class="comment">/* 主设备号 */</span></span><br><span class="line"><span class="type">void</span> *private_data;<span class="comment">/* 私有数据 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> <span class="title">xxx_dev_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_spi_driver_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 注册字符设备操作 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化spi_device结构体 </span></span><br><span class="line">spi-&gt;mode = SPI_MODE_0;  <span class="comment">/* 设置模式 MODE0，CPOL=0，CPHA=0 */</span></span><br><span class="line">spi_setup(spi);</span><br><span class="line"><span class="type">xxx_dev_t</span>.private_data = spi;<span class="comment">/* 设置私有数据 */</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_spi_driver_remove</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 注销字符设备操作 */</span></span><br><span class="line">    </span><br><span class="line">printk(<span class="string">&quot;xxx_spi_driver_remove ok\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备树compatible匹配表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table</span>[] =</span> &#123;</span><br><span class="line">&#123;.compatible = <span class="string">&quot;xxx&quot;</span>&#125;, </span><br><span class="line">&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 无设备树的匹配ID表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device_id</span> <span class="title">id_table</span>[] =</span> &#123;</span><br><span class="line">&#123;<span class="string">&quot;xxx&quot;</span>&#125;,</span><br><span class="line">&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义spi总线设备结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> <span class="title">xxx_spi_driver</span> =</span> &#123;</span><br><span class="line">.driver = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.name  = <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">.of_match_table = of_match_table,</span><br><span class="line">&#125;,</span><br><span class="line">.probe= xxx_spi_driver_probe,</span><br><span class="line">.remove = xxx_spi_driver_remove,</span><br><span class="line">.id_table= id_table,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_spi_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="comment">// 注册 spi 驱动</span></span><br><span class="line">ret = spi_register_driver(&amp;xxx_spi_driver);</span><br><span class="line"></span><br><span class="line">printk(<span class="string">&quot;xxx_spi_driver_init ok\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_spi_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将前面注册的spi_driver也从Linux内核中注销掉</span></span><br><span class="line">spi_unregister_driver(&amp;xxx_spi_driver);</span><br><span class="line">printk(<span class="string">&quot;xxx_spi_driver_exit ok\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(xxx_spi_driver_init);</span><br><span class="line">module_exit(xxx_spi_driver_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="注册字符设备">注册字符设备</h4><p>匹配成功时注册字符设备：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span> <span class="comment">/*注册设备节点的文件结构体*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span> <span class="comment">// 对字符设备结构cdev 以及一系列的操作函数的定义。包含了cdev 结构及相关函数的定义。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span> <span class="comment">//包含了device、class 等结构的定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">xxx_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *ubuf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *<span class="type">loff_t</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">xxx_fops</span> =</span> &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.open   = xxx_open,</span><br><span class="line">.release  = xxx_close,</span><br><span class="line">.read= xxx_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_spi_driver_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 1.分配设备号</span></span><br><span class="line"><span class="keyword">if</span>(<span class="type">xxx_dev_t</span>.major)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">xxx_dev_t</span>.devid = MKDEV(<span class="type">xxx_dev_t</span>.major, <span class="number">0</span>);</span><br><span class="line">register_chrdev_region(<span class="type">xxx_dev_t</span>.devid, <span class="number">1</span>, xxx_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">alloc_chrdev_region(&amp;<span class="type">xxx_dev_t</span>.devid, <span class="number">0</span>, <span class="number">1</span>, xxx_NAME);</span><br><span class="line"><span class="type">xxx_dev_t</span>.major = MAJOR(<span class="type">xxx_dev_t</span>.devid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.初始化cdev</span></span><br><span class="line">cdev_init(&amp;<span class="type">xxx_dev_t</span>.cdev, &amp;xxx_fops);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.添加设备号到cdev</span></span><br><span class="line">cdev_add(&amp;<span class="type">xxx_dev_t</span>.cdev, <span class="type">xxx_dev_t</span>.devid, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.创建类</span></span><br><span class="line"><span class="type">xxx_dev_t</span>.class = class_create(THIS_MODULE, xxx_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="type">xxx_dev_t</span>.device))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="type">xxx_dev_t</span>.device);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.类下创建设备</span></span><br><span class="line"><span class="type">xxx_dev_t</span>.device = device_create(<span class="type">xxx_dev_t</span>.class, <span class="literal">NULL</span>, <span class="type">xxx_dev_t</span>.devid, <span class="literal">NULL</span>, xxx_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="type">xxx_dev_t</span>.device))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="type">xxx_dev_t</span>.device);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_spi_driver_remove</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 1.注销设备号</span></span><br><span class="line">unregister_chrdev_region(<span class="type">xxx_dev_t</span>.devid, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 2.删除设备</span></span><br><span class="line">cdev_del(&amp;<span class="type">xxx_dev_t</span>.cdev);</span><br><span class="line"><span class="comment">// 3.注销设备节点</span></span><br><span class="line">device_destroy(<span class="type">xxx_dev_t</span>.class, <span class="type">xxx_dev_t</span>.devid);</span><br><span class="line"><span class="comment">// 4.删除类</span></span><br><span class="line">class_destroy(<span class="type">xxx_dev_t</span>.class);</span><br><span class="line">printk(<span class="string">&quot;xxx_spi_driver_remove ok\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="spi-设备数据收发和处理">SPI 设备数据收发和处理</h4><p>定义一个 <code>xxx_dev</code> 结构体用来存放一些创建设备需要的变量和获取到的信息，读取和写入函数主要是填充 <code>spi_transfer</code> 结构体，接着添加到 <code>spi_message</code> 队列去，使用 <code>spi_sync</code> 进行发送。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : 读取 xxx 设备多个寄存器数据</span></span><br><span class="line"><span class="comment">* @param – dev : xxx 设备</span></span><br><span class="line"><span class="comment">* @param – reg : 要读取的寄存器首地址</span></span><br><span class="line"><span class="comment">* @param – val : 读取到的数据</span></span><br><span class="line"><span class="comment">* @param – len : 要读取的数据长度</span></span><br><span class="line"><span class="comment">* @return : 操作结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_read_reg</span><span class="params">(<span class="keyword">struct</span> xxx_dev *dev, <span class="type">uint8_t</span> reg, <span class="type">void</span> *val, <span class="type">uint8_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">uint8_t</span> tx_data[<span class="number">1</span>];</span><br><span class="line"><span class="type">uint8_t</span> *rx_data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> *<span class="title">t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span> =</span> (<span class="keyword">struct</span> spi_device *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配内存 */</span></span><br><span class="line">t = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> spi_transfer), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span>(!t)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;kzalloc error\n&quot;</span>);</span><br><span class="line">kfree(t);</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rx_data = kzalloc(<span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) + len, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span>(!rx_data)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;kzalloc error\n&quot;</span>);</span><br><span class="line">kfree(rx_data);</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送要读取的寄存地址和接收读取的数据 */</span></span><br><span class="line">tx_data[<span class="number">0</span>] = ; <span class="comment">/* 首位1还是0看芯片手册  */</span></span><br><span class="line"></span><br><span class="line">t-&gt;tx_buf = tx_data;<span class="comment">/* 要发送的数据：寄存器地址 */</span></span><br><span class="line">t-&gt;rx_buf = rx_data;<span class="comment">/* 要接收的数据 */</span></span><br><span class="line">t-&gt;len = len + <span class="number">1</span>;<span class="comment">/* t-&gt;len=发送的长度+读取的长度 */</span></span><br><span class="line"></span><br><span class="line">spi_message_init(&amp;msg); <span class="comment">/* 初始化spi_message */</span></span><br><span class="line">spi_message_add_tail(t, &amp;msg);<span class="comment">/* 将spi_transfer 添加到spi_message 队列 */</span></span><br><span class="line">ret = spi_sync(spi, &amp;msg); <span class="comment">/* 同步传输 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SPI接收数据时，第一个字节是寄存器的地址，跳过一个字节即可。</span></span><br><span class="line"><span class="built_in">memcpy</span>(val, rx_data + <span class="number">1</span>, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放内存 */</span></span><br><span class="line">kfree(t);</span><br><span class="line">kfree(rx_data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : 向 xxx 设备多个寄存器写入数据</span></span><br><span class="line"><span class="comment">* @param – dev : 要写入的设备结构体</span></span><br><span class="line"><span class="comment">* @param – reg : 要写入的寄存器首地址</span></span><br><span class="line"><span class="comment">* @param – val : 要写入的数据缓冲区</span></span><br><span class="line"><span class="comment">* @param – len : 要写入的数据长度</span></span><br><span class="line"><span class="comment">* @return : 操作结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_write_reg</span><span class="params">(<span class="keyword">struct</span> xxx_dev *dev, <span class="type">uint8_t</span> reg, <span class="type">uint8_t</span> *buf, <span class="type">uint8_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"><span class="type">uint8_t</span> *tx_data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> *<span class="title">t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span> =</span> (<span class="keyword">struct</span> spi_device *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配内存 */</span></span><br><span class="line">t = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> spi_transfer), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span>(!t)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;kzalloc error\n&quot;</span>);</span><br><span class="line">kfree(t);</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tx_data = kzalloc(<span class="keyword">sizeof</span>(<span class="type">uint8_t</span>) + len, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span>(!t)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;kzalloc error\n&quot;</span>);</span><br><span class="line">kfree(tx_data);</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送要读取的寄存地址和写入的数据 */</span></span><br><span class="line">*tx_data = reg &amp; ~(<span class="number">0x80</span>); <span class="comment">/* 写数据的时候寄存器地址bit8要清零 */</span></span><br><span class="line"><span class="built_in">memcpy</span>(tx_data + <span class="number">1</span>, buf, len);<span class="comment">/* 把len 个寄存器拷贝到txdata 里 */</span></span><br><span class="line"></span><br><span class="line">t-&gt;tx_buf = tx_data;<span class="comment">/* 要发送的数据 */</span></span><br><span class="line">t-&gt;len = len + <span class="number">1</span>;<span class="comment">/* t-&gt;len=发送的长度+读取的长度 */</span></span><br><span class="line"></span><br><span class="line">spi_message_init(&amp;msg); <span class="comment">/* 初始化spi_message */</span></span><br><span class="line">spi_message_add_tail(t, &amp;msg);<span class="comment">/* 将spi_transfer 添加到spi_message 队列 */</span></span><br><span class="line">ret = spi_sync(spi, &amp;msg); <span class="comment">/* 同步传输 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放内存 */</span></span><br><span class="line">kfree(t);</span><br><span class="line">kfree(tx_data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux-spi驱动&quot;&gt;Linux-SPI驱动&lt;/h1&gt;
&lt;h2 id=&quot;序言&quot;&gt;序言&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;SPI 具体通信协议本文不涉及，本文主要介绍在 Linux 中 SPI 的驱动框架。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;SPI</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/Linux/"/>
    
    
    <category term="Linux" scheme="http://www.obito.top/tags/Linux/"/>
    
    <category term="嵌入式" scheme="http://www.obito.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux输入子系统</title>
    <link href="http://www.obito.top/2024/06/27/Linux%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.obito.top/2024/06/27/Linux%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-06-26T16:04:23.000Z</published>
    <updated>2024-06-28T06:02:10.292Z</updated>
    
    
    
    
    <category term="嵌入式" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/Linux/"/>
    
    
    <category term="Linux" scheme="http://www.obito.top/tags/Linux/"/>
    
    <category term="嵌入式" scheme="http://www.obito.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux-I2C驱动</title>
    <link href="http://www.obito.top/2024/06/27/Linux-I2C%E9%A9%B1%E5%8A%A8/"/>
    <id>http://www.obito.top/2024/06/27/Linux-I2C%E9%A9%B1%E5%8A%A8/</id>
    <published>2024-06-26T16:03:52.000Z</published>
    <updated>2024-06-29T09:25:51.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-i2c-驱动">Linux-I2C 驱动</h1><h2 id="序言">序言</h2><p><em><strong>I2C 具体通信协议本文不涉及，本文主要介绍在 Linux 中 I2C 的驱动框架。</strong></em></p><p>I2C 有两条信号线：SCL 和 SDA。</p><ul><li>SCL：时钟线，数据收发同步</li><li>SDA：数据线，传输具体数据</li></ul><h2 id="i2c-驱动框架">I2C 驱动框架</h2><p><strong>Linux I2C 驱动由三部分组成：I2C 核心、I2C 总线驱动、I2C 设备驱动。</strong></p><ul><li>I2C 核心层驱动作为顶层驱动，管理整个I2C子系统，并提供了基本的I2C操作接口。</li><li>I2C 适配器驱动负责与底层硬件的 I2C 控制器进行交互，通过适配器驱动，I2C总线核心驱动能够与硬件进行通信。</li><li>I2C 设备驱动则针对具体的 I2C 设备编写，实现了对设备的初始化、读写数据等操作。</li></ul><h3 id="i2c-核心-i2c-core-driver">I2C 核心（I2C Core Driver）</h3><p>I2C 核心负责管理 I2C 总线适配器和设备，提供 I2C 总线驱动和设备驱动和注册、注销方法，完成 I2C 设备和 I2C 驱动匹配过程。这一部分不涉及硬件的操作，一般由<strong>系统厂编写</strong>。</p><p>I2C 核心中主要函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.i2c_adapter 注册/注销函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_del_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter * adap)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.i2c_driver 注册/注销函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_register_driver</span><span class="params">(<span class="keyword">struct</span> module *owner, <span class="keyword">struct</span> i2c_driver *driver)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_driver</span> <span class="params">(<span class="keyword">struct</span> i2c_driver *driver)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_del_driver</span><span class="params">(<span class="keyword">struct</span> i2c_driver *driver)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.创建并注册一个I2C设备</span></span><br><span class="line"><span class="keyword">struct</span> i2c_client *<span class="title function_">i2c_new_device</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_board_info <span class="type">const</span> *info)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.I2C 传输、发送、接收</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_transfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_master_send</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> count)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_master_recv</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client, <span class="type">char</span> *buf, <span class="type">int</span> count)</span></span><br></pre></td></tr></table></figure><p><code>i2c_transfer</code> 函数可以进行复杂的多消息传输，而 <code>i2c_master_send</code> 和 <code>i2c_master_recv</code> 函数用于单个数据消息的发送和接收。<code>i2c_transfer</code> 由于其灵活性，通常被优先使用。</p><h3 id="i2c-总线驱动">I2C 总线驱动</h3><p>I2C 总线驱动重点是 <strong>I2C 适配器驱动（I2C Adapter Driver）</strong>，I2C 适配器驱动负责与硬件的 I2C 控制器进行交互，完成硬件层面的初始化、配置和操作。它将底层硬件的特定接口与 I2C 总线核心驱动进行连接，使得核心驱动能够通过适配器驱动来访问硬件。这一部分一般由<strong>芯片厂提供</strong>，例如 IMX6ULL 的 I2C 适配器驱动已经由 NXP 公司编写好了。</p><p>I2C 适配器驱动主要涉及两个结构体：<code>i2c_adapter</code> 和 <code>i2c_algorithm</code>。</p><p><code>i2c_adapter</code> 结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/i2c.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span>  <span class="comment">/* classes to allow probing for */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span> <span class="comment">/* the algorithm to access the bus */</span></span><br><span class="line"><span class="type">void</span> *algo_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* data fields that are valid for all devices*/</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_lock_operations</span> *<span class="title">lock_ops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">mux_lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> timeout;<span class="comment">/* in jiffies */</span></span><br><span class="line"><span class="type">int</span> retries;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span><span class="comment">/* the adapter device */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nr;</span><br><span class="line"><span class="type">char</span> name[<span class="number">48</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">userspace_clients_lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">userspace_clients</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_bus_recovery_info</span> *<span class="title">bus_recovery_info</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter_quirks</span> *<span class="title">quirks</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>i2c_algprithm</code> 结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/i2c.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line"><span class="comment">/* If an adapter algorithm can&#x27;t do I2C-level access, set master_xfer</span></span><br><span class="line"><span class="comment">   to NULL. If an adapter algorithm can do SMBus access, set</span></span><br><span class="line"><span class="comment">   smbus_xfer. If set to NULL, the SMBus protocol is simulated</span></span><br><span class="line"><span class="comment">   using common I2C messages */</span></span><br><span class="line"><span class="comment">/* master_xfer should return the number of messages successfully</span></span><br><span class="line"><span class="comment">   processed, or a negative value on error */</span></span><br><span class="line"><span class="type">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs,</span><br><span class="line">   <span class="type">int</span> num);</span><br><span class="line"><span class="type">int</span> (*smbus_xfer) (<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line">   u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">u32 (*functionality) (<span class="keyword">struct</span> i2c_adapter *);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line"><span class="type">int</span> (*reg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line"><span class="type">int</span> (*unreg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>master_xfer 就是 I2C 适配器的传输函数，可以通过此函数来完成与 I2C 设备之间的通信。</li><li>smbus_xfer 就是 SMBUS 总线的传输函数。</li></ul><p>I2C 总线驱动，或者说 I2C 适配器驱动的主要工作就是初始化 <code>i2c_adapter</code> 结构体变量，里面由个成员变量：algorithm 中存在一系列函数指针，这些函数指针指向真正硬件操作代码。</p><h3 id="i2c-设备驱动-i2c-device-driver">I2C 设备驱动（I2C Device Driver）</h3><p>I2C 设备驱动是针对特定类型的 I2C 设备编写的驱动程序。它包含了对具体设备的操作和控制逻辑，通过调用I2C 总线核心驱动提供的 API 函数与设备进行通信。设备驱动的主要任务包括初始化设备、读写数据、配置设备参数等。这一部分由<strong>开发者编写</strong>。</p><p>I2C 设备驱动主要是填充两个重要的结构体：<code>i2c_client</code> 和 <code>i2c_driver</code>，<code>i2c_client</code> 是描述设备信息的，<code>i2c_driver</code> 是描述驱动内容的，类似于平台总线驱动中的 <code>platform_device</code> 和 <code>platform_driver</code>，如果采用设备树的话，则只需要编写 <code>i2c_driver</code> 结构体的内容即可，因为设备树中的 I2C 节点会转换为 <code>i2c_client</code> 的内容。</p><p><code>i2c_client</code> 结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/i2c.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> flags;<span class="comment">/* div., see below*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> addr;<span class="comment">/* chip address - <span class="doctag">NOTE:</span> 7bit*/</span></span><br><span class="line"><span class="comment">/* addresses are stored in the*/</span></span><br><span class="line"><span class="comment">/* _LOWER_ 7 bits*/</span></span><br><span class="line"><span class="type">char</span> name[I2C_NAME_SIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span><span class="comment">/* the adapter we sit on*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span><span class="comment">/* the device structure*/</span></span><br><span class="line"><span class="type">int</span> irq;<span class="comment">/* irq issued by device*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">detected</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line"><span class="type">i2c_slave_cb_t</span> slave_cb;<span class="comment">/* callback for slave mode*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>i2c_driver</code> 结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/i2c.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Notifies the driver that a new bus has appeared. You should avoid</span></span><br><span class="line"><span class="comment"> * using this, it will be removed in a near future.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*attach_adapter)(<span class="keyword">struct</span> i2c_adapter *) __deprecated;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Standard driver model interfaces */</span></span><br><span class="line"><span class="type">int</span> (*probe)(<span class="keyword">struct</span> i2c_client *, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *);</span><br><span class="line"><span class="type">int</span> (*remove)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* driver model interfaces that don&#x27;t relate to enumeration  */</span></span><br><span class="line"><span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Alert callback, for example for the SMBus alert protocol.</span></span><br><span class="line"><span class="comment"> * The format and meaning of the data value depends on the protocol.</span></span><br><span class="line"><span class="comment"> * For the SMBus alert protocol, there is a single bit of data passed</span></span><br><span class="line"><span class="comment"> * as the alert response&#x27;s low bit (&quot;event flag&quot;).</span></span><br><span class="line"><span class="comment"> * For the SMBus Host Notify protocol, the data corresponds to the</span></span><br><span class="line"><span class="comment"> * 16-bit payload data reported by the slave device acting as master.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> (*alert)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">enum</span> i2c_alert_protocol protocol,</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> data);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* a ioctl like command that can be used to perform specific functions</span></span><br><span class="line"><span class="comment"> * with the device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*command)(<span class="keyword">struct</span> i2c_client *client, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> *arg);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Device detection callback for automatic device creation */</span></span><br><span class="line"><span class="type">int</span> (*detect)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">struct</span> i2c_board_info *);</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *address_list;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clients</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="i2c-设备和驱动匹配过程">I2C 设备和驱动匹配过程</h4><p>I2C 设备和驱动的匹配过程是由 I2C 总线来完成的，这点和 platform驱动一样。</p><p>I2c 总线定义了一个 <code>bus_type</code> 结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/i2c/i2c-core.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">i2c_bus_type</span> =</span> &#123;</span><br><span class="line">.name= <span class="string">&quot;i2c&quot;</span>,</span><br><span class="line">.match= i2c_device_match,</span><br><span class="line">.probe= i2c_device_probe,</span><br><span class="line">.remove= i2c_device_remove,</span><br><span class="line">.shutdown= i2c_device_shutdown,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_device_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span>*<span class="title">client</span> =</span> i2c_verify_client(dev);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span>*<span class="title">driver</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!client)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Attempt an OF style match */</span></span><br><span class="line"><span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Then ACPI style match */</span></span><br><span class="line"><span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">driver = to_i2c_driver(drv);</span><br><span class="line"><span class="comment">/* match on an id table if there is one */</span></span><br><span class="line"><span class="keyword">if</span> (driver-&gt;id_table)</span><br><span class="line"><span class="keyword">return</span> i2c_match_id(driver-&gt;id_table, client) != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先 <code>of_driver_match_device</code> 函数用于完成设备树设备和驱动的匹配，比较设备节点的 compatible 属性和 <code>of_device_id</code> 结构体中的 compatible 属性是否相等。</p></li><li><p>若上一步匹配失败，则进行 ACPI 形式的匹配。</p></li><li><p>最后则是进行传统的无设备树的匹配方式，比较 <code>i2c_client</code> 结构体中 name 成员变量和 <code>i2c_driver</code> 结构体中 <code>i2c_device_id</code> 表是否有匹配的。</p></li></ul><h2 id="i2c-设备驱动编写过程">I2C 设备驱动编写过程</h2><p>首先是 I2C 设备的信息，有两种方法：未使用设备树和使用设备树。</p><h3 id="i2c-设备信息描述">I2C 设备信息描述</h3><h4 id="未使用设备树">未使用设备树</h4><p>未使用设备树的话，则需要在新建一个文件例如 <code>xxx_i2c_client.c</code> 文件（命名无要求）。</p><ul><li>在该文件下使用 <code>i2c_borad_info</code> 结构体描述 I2C 设备的信息——设备名字和设备地址，</li><li>接着将该设备挂载在相对应的 I2C 总线上</li></ul><p><code>i2c_borad_info</code> 结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/i2c.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> &#123;</span></span><br><span class="line"><span class="type">char</span>type[I2C_NAME_SIZE];<span class="comment">/* I2C 设备名字*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>flags;<span class="comment">/* 标志*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>addr;<span class="comment">/* I2C 器件地址*/</span></span><br><span class="line"><span class="type">void</span>*platform_data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span>*<span class="title">archdata</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span>;</span></span><br><span class="line"><span class="type">int</span>irq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 type 和 addr 这两个成员变量必须要设置，使用如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个i2c适配器指针</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">i2c_adap</span>;</span></span><br><span class="line"><span class="comment">// 分配一个i2c_client指针</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">i2c_client</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C 设备信息：设备名字 设备地址 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> <span class="title">xxx_board_info</span>[] =</span> &#123;</span><br><span class="line">&#123;I2C_BOARD_INFO(<span class="string">&quot;xxx@xx&quot;</span>, <span class="number">0x00</span>)&#125;,</span><br><span class="line">&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_i2c_client_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 调用i2c_get_adapter获得一个i2c总线 将xxx挂载到i2c(fd+1)总线上</span></span><br><span class="line">    <span class="comment">// 这里的fd取决于你的设备挂载在哪根I2C总线上（看原理图）</span></span><br><span class="line">    <span class="comment">// 接着看着根I2C总线在你开发板中的设备树或内核配置中的顺序编号(一般从0开始)</span></span><br><span class="line">i2c_adap = i2c_get_adapter(fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把i2c client和i2c器件关联起来</span></span><br><span class="line">i2c_client = i2c_new_device(i2c_adap, xxx_info);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放i2c控制器</span></span><br><span class="line">i2c_put_adapter(i2c_adap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_i2c_client_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将前面注册的i2c_driver 也从Linux 内核中注销掉</span></span><br><span class="line">i2c_unregister_device(i2c_client);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(xxx_i2c_client_init);</span><br><span class="line">module_exit(xxx_i2c_client_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="使用设备树">使用设备树</h4><p>使用设备树文件时，只需要在设备树文件中添加相应的 I2C 设备节点即可例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c1 &#123;</span><br><span class="line">    clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加以下信息即可：设备名字和设备地址</span></span><br><span class="line">    ap3216c@<span class="number">1</span>e &#123; </span><br><span class="line">        compatible = <span class="string">&quot;ap3216c&quot;</span>; </span><br><span class="line">        reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="i2c-driver-驱动">I2C driver 驱动</h3><h4 id="注册-driver-驱动">注册 driver 驱动</h4><p>注册 <code>i2c_driver</code> 结构体驱动文件通用结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_i2c_driver_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 注册字符设备操作 */</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 设置私有数据</span></span><br><span class="line"><span class="type">xxx_dev_t</span>.private_data = client;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_i2c_driver_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 注销字符设备操作 */</span></span><br><span class="line">    </span><br><span class="line">    printk(<span class="string">&quot;xxx_i2c_driver_remove ok\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备树compatible匹配表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table</span>[] =</span> &#123;</span><br><span class="line">&#123;.compatible = <span class="string">&quot;xxx&quot;</span>&#125;, </span><br><span class="line">&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 无设备树的匹配ID表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">id_table</span>[] =</span> &#123;</span><br><span class="line">&#123;<span class="string">&quot;xxx&quot;</span>&#125;,</span><br><span class="line">&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义i2c总线设备结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">xxx_i2c_driver</span> =</span> &#123;</span><br><span class="line">.driver = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.name  = <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">.of_match_table = of_match_table,</span><br><span class="line">&#125;,</span><br><span class="line">.probe= xxx_i2c_driver_probe,</span><br><span class="line">.remove = xxx_i2c_driver_remove,</span><br><span class="line">.id_table= id_table,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_i2c_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="comment">// 注册 i2c 驱动</span></span><br><span class="line">ret = i2c_add_driver(&amp;xxx_i2c_driver);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_i2c_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将前面注册的i2c_driver也从Linux内核中注销掉</span></span><br><span class="line">i2c_del_driver(&amp;xxx_i2c_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(xxx_i2c_driver_init);</span><br><span class="line">module_exit(xxx_i2c_driver_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="注册字符设备">注册字符设备</h4><p>匹配成功时注册字符设备：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span> <span class="comment">/*注册设备节点的文件结构体*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span> <span class="comment">// 对字符设备结构cdev 以及一系列的操作函数的定义。包含了cdev 结构及相关函数的定义。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span> <span class="comment">//包含了device、class 等结构的定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">xxx_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *ubuf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *<span class="type">loff_t</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">xxx_fops</span> =</span> &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.open   = xxx_open,</span><br><span class="line">.release  = xxx_close,</span><br><span class="line">.read= xxx_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_spi_driver_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 1.分配设备号</span></span><br><span class="line"><span class="keyword">if</span>(<span class="type">xxx_dev_t</span>.major)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">xxx_dev_t</span>.devid = MKDEV(<span class="type">xxx_dev_t</span>.major, <span class="number">0</span>);</span><br><span class="line">register_chrdev_region(<span class="type">xxx_dev_t</span>.devid, <span class="number">1</span>, xxx_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">alloc_chrdev_region(&amp;<span class="type">xxx_dev_t</span>.devid, <span class="number">0</span>, <span class="number">1</span>, xxx_NAME);</span><br><span class="line"><span class="type">xxx_dev_t</span>.major = MAJOR(<span class="type">xxx_dev_t</span>.devid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.初始化cdev</span></span><br><span class="line">cdev_init(&amp;<span class="type">xxx_dev_t</span>.cdev, &amp;xxx_fops);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.添加设备号到cdev</span></span><br><span class="line">cdev_add(&amp;<span class="type">xxx_dev_t</span>.cdev, <span class="type">xxx_dev_t</span>.devid, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.创建类</span></span><br><span class="line"><span class="type">xxx_dev_t</span>.class = class_create(THIS_MODULE, xxx_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="type">xxx_dev_t</span>.device))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="type">xxx_dev_t</span>.device);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.类下创建设备</span></span><br><span class="line"><span class="type">xxx_dev_t</span>.device = device_create(<span class="type">xxx_dev_t</span>.class, <span class="literal">NULL</span>, <span class="type">xxx_dev_t</span>.devid, <span class="literal">NULL</span>, xxx_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="type">xxx_dev_t</span>.device))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="type">xxx_dev_t</span>.device);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_spi_driver_remove</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 1.注销设备号</span></span><br><span class="line">unregister_chrdev_region(<span class="type">xxx_dev_t</span>.devid, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 2.删除设备</span></span><br><span class="line">cdev_del(&amp;<span class="type">xxx_dev_t</span>.cdev);</span><br><span class="line"><span class="comment">// 3.注销设备节点</span></span><br><span class="line">device_destroy(<span class="type">xxx_dev_t</span>.class, <span class="type">xxx_dev_t</span>.devid);</span><br><span class="line"><span class="comment">// 4.删除类</span></span><br><span class="line">class_destroy(<span class="type">xxx_dev_t</span>.class);</span><br><span class="line">printk(<span class="string">&quot;xxx_spi_driver_remove ok\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="i2c-设备的数据收发和处理">I2C 设备的数据收发和处理</h4><p>定义一个 <code>xxx_dev</code> 结构体用来存放一些创建设备需要的变量和获取到的信息，读取和写入函数主要是填充 <code>i2c_msg</code> 结构体，然后使用 <code>i2c_transfer</code> 函数传输数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 设备号这些添加进来是为了方便管理 */</span></span><br><span class="line"><span class="type">dev_t</span> devid;<span class="comment">/* 设备号 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">/* cdev  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span><span class="comment">/* 类 */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* 设备 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span><span class="comment">/* 设备节点 */</span></span><br><span class="line"><span class="type">int</span> major;<span class="comment">/* 主设备号 */</span></span><br><span class="line"><span class="type">void</span> *private_data;<span class="comment">/* 私有数据 一般转换为 struct i2c_client * */</span></span><br><span class="line"><span class="comment">/* 数据 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> <span class="title">xxx_dev_t</span>;</span><span class="comment">// 定义结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : 读取I2C 设备多个寄存器数据</span></span><br><span class="line"><span class="comment">* @param – dev : I2C 设备</span></span><br><span class="line"><span class="comment">* @param – reg : 要读取的寄存器首地址</span></span><br><span class="line"><span class="comment">* @param – val : 读取到的数据</span></span><br><span class="line"><span class="comment">* @param – len : 要读取的数据长度</span></span><br><span class="line"><span class="comment">* @return : 操作结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_read_reg</span><span class="params">(<span class="keyword">struct</span> xxx_dev *dev, <span class="type">uint8_t</span> reg, <span class="type">uint8_t</span> *val, <span class="type">uint16_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* msg[0]，第一条写消息，发送要读取的寄存器首地址*/</span></span><br><span class="line">msg[<span class="number">0</span>].addr = client-&gt;addr;<span class="comment">// 设备地址</span></span><br><span class="line">msg[<span class="number">0</span>].flags = <span class="number">0</span>;<span class="comment">// 写数据</span></span><br><span class="line">msg[<span class="number">0</span>].buf = &amp;reg;<span class="comment">// 寄存器地址</span></span><br><span class="line">msg[<span class="number">0</span>].len = <span class="number">1</span>;<span class="comment">// msg长度：寄存器地址长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* msg[1]，第二条读消息，读取寄存器数据*/</span></span><br><span class="line">msg[<span class="number">1</span>].addr = client-&gt;addr;<span class="comment">// 设备地址</span></span><br><span class="line">msg[<span class="number">1</span>].flags = I2C_M_RD;<span class="comment">// 读数据</span></span><br><span class="line">msg[<span class="number">1</span>].buf= data;<span class="comment">// 读取的数据</span></span><br><span class="line">msg[<span class="number">1</span>].len = len;<span class="comment">// msg长度：读取数据的长度</span></span><br><span class="line"></span><br><span class="line">ret =  i2c_transfer(client-&gt;adapter, msg, <span class="number">2</span>);<span class="comment">// 2个msg</span></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">2</span>)</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = -EREMOTEIO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : 向 I2C 设备多个寄存器写入数据</span></span><br><span class="line"><span class="comment">* @param – dev : 要写入的设备结构体</span></span><br><span class="line"><span class="comment">* @param – reg : 要写入的寄存器首地址</span></span><br><span class="line"><span class="comment">* @param – val : 要写入的数据缓冲区</span></span><br><span class="line"><span class="comment">* @param – len : 要写入的数据长度</span></span><br><span class="line"><span class="comment">* @return : 操作结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_write_reg</span><span class="params">(<span class="keyword">struct</span> xxx_dev *dev, <span class="type">uint8_t</span> reg, <span class="type">uint8_t</span> *buf, <span class="type">uint16_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> tmp[<span class="number">256</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>;</span><span class="comment">// 存放待写入的寄存器地址和数据等信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    tmp[<span class="number">0</span>] = reg;               <span class="comment">// 寄存器地址</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;tmp[<span class="number">1</span>], buf, len); <span class="comment">// 写入的数据</span></span><br><span class="line"></span><br><span class="line">msg.addr = client-&gt;addr;<span class="comment">// 设备地址</span></span><br><span class="line">msg.flags = <span class="number">0</span>;<span class="comment">// 写数据</span></span><br><span class="line">msg.buf = tmp;<span class="comment">// 发送的数据缓冲区</span></span><br><span class="line">msg.len = len + <span class="number">1</span>;<span class="comment">// msg长度：写入的数据长度 + 寄存器地址长度 （单位：字节)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>);<span class="comment">// 1个msg</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="i2c-tools">i2c-tools</h2><p>i2c-tools 是一个专门调试 i2c 的开源工具，可以获取挂载的设备及设备地址，还可以读写 I2C 设备寄存器。</p><p>在调试新的 I2C 设备驱动时，需要多次修改寄存器看结果现象，正常做法是修改驱动代码寄存器值——编译烧录——运行看结果，费时费力，使用 i2c-tools 可以省去很多时间。</p><blockquote><p>i2c-tools 官方说明：<a href="https://archive.kernel.org/oldwiki/i2c.wiki.kernel.org/index.php/I2C_Tools.html">I2C Tools - Linux i2c Wiki (kernel.org)</a></p></blockquote><p>i2c-tools 是通过操作 /dev 路径 i2c-× 设备文件完成，因此你的 kernel 必须开启 CONFIG_I2C_CHARDEV 宏控，否者会报找不到节点。</p><p>检测开发板是否有 i2c-tools 工具，检测相应工具是否存在即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2cdetect -V</span><br></pre></td></tr></table></figure><p>如果没有的话，则需要交叉工具链进行交叉编译，编译生成五个工具：i2cdetect、i2cset、i2cget、i2cdump、i2ctransfer，拷贝到开发板中就可以使用，也可以直接把 i2c-tools 源码包放到自己的源码中，直接编译进固件。</p><ul><li>i2cdetect：用于扫描 i2c 总线上的设备，并显示地址</li><li>i2cset：设置 i2c 设备某个寄存器的值</li><li>i2cget：读取 i2c 设备某个寄存器的值</li><li>i2cdump：读取某个 i2c 设备所有寄存器的值</li><li>i2ctransfer：一次性读写多个字节</li></ul><p>查看已经挂载的 i2c 设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@100ask:~]# ls /sys/bus/i2c/devices/</span><br><span class="line">1-001a  1-0039  1-005d  i2c-0  i2c-1</span><br></pre></td></tr></table></figure><h3 id="使用示例">使用示例</h3><h4 id="i2cdetect">i2cdetect</h4><p>i2cdetect 用于扫描 i2c 总线上的设备，并显示地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Usage: i2cdetect [-y] [-a] [-q|-r] I2CBUS [FIRST LAST]</span><br><span class="line">       i2cdetect -F I2CBUS</span><br><span class="line">       i2cdetect -l</span><br><span class="line">  I2CBUS is an integer or an I2C bus name</span><br><span class="line">  If provided, FIRST and LAST limit the probing range.</span><br><span class="line"></span><br><span class="line">I2CBUS：指定要扫描的I2C总线编号或者总线名称。</span><br><span class="line">-y：在检测到设备时自动确认，不提示用户输入。</span><br><span class="line">-a：扫描整个I2C总线地址空间，包括扩展的地址（7位地址）。</span><br><span class="line">-q 或 -r：使用快速或慢速扫描模式。快速模式（-q）会更快地扫描地址空间，但可能漏掉一些慢响应的设备。慢速模式（-r）会等待更长的时间来检测每个地址，确保检测到所有设备。</span><br><span class="line">-F：当与 I2CBUS 一起使用时，i2cdetect 将尝试检测总线上的每个设备的功能性。</span><br><span class="line">-l：列出所有可用的I2C总线。</span><br><span class="line">FIRST LAST：扫描的地址范围</span><br></pre></td></tr></table></figure><p><code>i2cdetect -l</code> 显示所有可用的 i2c 总线：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="number">100</span>ask:~]# i2cdetect -l</span><br><span class="line">i2c<span class="number">-1</span>   i2c             <span class="number">21</span>a4000.i2c                             I2C adapter</span><br><span class="line">i2c<span class="number">-0</span>   i2c             <span class="number">21</span>a0000.i2c                             I2C adapter</span><br></pre></td></tr></table></figure><p><code>i2cdetect -y 0</code> 显示指定 i2c 总线挂载设备的情况：</p><p><img src="/image-20240628120005177.png" alt="image-20240628120005177"></p><p>– 表示该地址被检测，但是无设备应答，UU 表示该地址被当前内核驱动使用，由上图可知 i2c-1 总线当前有三个被内核驱动使用的设备，设备地址为：0x1a、0x39、0x5d。另外还显示了两个设备的具体地址，表示硬件上连接了 i2c 总线，只是没有被内核驱动使用。</p><h4 id="i2cset">i2cset</h4><p>i2cset：设置 i2c 设备某个寄存器的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Usage: i2cset [-f] [-y] [-m MASK] [-r] [-a] I2CBUS CHIP-ADDRESS DATA-ADDRESS [VALUE] ... [MODE]</span><br><span class="line">  I2CBUS is an integer or an I2C bus name</span><br><span class="line">  ADDRESS is an integer (0x03 - 0x77, or 0x00 - 0x7f if -a is given)</span><br><span class="line">  MODE is one of:</span><br><span class="line">    c (byte, no value)</span><br><span class="line">    b (byte data, default)</span><br><span class="line">    w (word data)</span><br><span class="line">    i (I2C block data)</span><br><span class="line">    s (SMBus block data)</span><br><span class="line">    Append p for SMBus PEC</span><br><span class="line">    </span><br><span class="line">-f：强制执行，即使在某些情况下可能不安全。</span><br><span class="line">-y：自动应答，不提示用户确认。</span><br><span class="line">-m MASK：对数据应用掩码。只有掩码中为1的位会被写入，其余位保持不变。</span><br><span class="line">-r：如果设置了，并且指定了模式 c（即无值的字节命令），则在写入命令后立即读取一个字节的数据。</span><br><span class="line">-a：允许10位地址的设备。默认情况下，i2cset 只处理7位地址的设备。</span><br><span class="line">I2CBUS：指定I2C总线的编号或名称。</span><br><span class="line">CHIP-ADDRESS：i2c设备地址。</span><br><span class="line">DATA-ADDRESS：i2c寄存器地址</span><br><span class="line">VALUE：要写入的数据值。具体需要根据后面指定的 MODE 来确定数据格式。</span><br><span class="line">MODE：指定数据传输的模式，可以是以下几种之一：</span><br><span class="line">    c：发送一个无数据的字节命令。</span><br><span class="line">    b：发送一个字节的数据（默认模式）。</span><br><span class="line">    w：发送一个字（16位）的数据。</span><br><span class="line">    i：发送I2C块数据。</span><br><span class="line">    s：发送SMBus块数据。</span><br></pre></td></tr></table></figure><p>设置 i2c-0 总线上 0x1E 设备的 0x00 寄存器值为 0x03：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2cset -f -y 0 0x1e 0x00 0x03</span><br></pre></td></tr></table></figure><h4 id="i2cget">i2cget</h4><p>i2cget：读取 i2c 设备某个寄存器的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Usage: i2cget [-f] [-y] [-a] I2CBUS CHIP-ADDRESS [DATA-ADDRESS [MODE]]</span><br><span class="line">  I2CBUS is an integer or an I2C bus name</span><br><span class="line">  ADDRESS is an integer (0x03 - 0x77, or 0x00 - 0x7f if -a is given)</span><br><span class="line">  MODE is one of:</span><br><span class="line">    b (read byte data, default)</span><br><span class="line">    w (read word data)</span><br><span class="line">    c (write byte/read byte)</span><br><span class="line">    Append p for SMBus PEC</span><br><span class="line">-f：强制执行，即使在某些情况下可能不安全。</span><br><span class="line">-y：自动应答，不提示用户确认。</span><br><span class="line">-a：允许10位地址的设备。默认情况下，i2cset 只处理7位地址的设备。</span><br><span class="line">I2CBUS：指定I2C总线的编号或名称。</span><br><span class="line">CHIP-ADDRESS：i2c设备地址。</span><br><span class="line">DATA-ADDRESS：i2c寄存器地址</span><br><span class="line">MODE：指定数据传输的模式，可以是以下几种之一：</span><br><span class="line">    c：发送一个无数据的字节命令。</span><br><span class="line">    b：发送一个字节的数据（默认模式）。</span><br><span class="line">    w：发送一个字（16位）的数据。</span><br><span class="line">    i：发送I2C块数据。</span><br><span class="line">    s：发送SMBus块数据。</span><br></pre></td></tr></table></figure><p>获取 i2c-0 总线上 0x1E 设备的 0x00 寄存器的值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2cget -f -y 0 0x1e 0x00</span><br></pre></td></tr></table></figure><h4 id="i2cdump">i2cdump</h4><p>i2cdump：读取某个 i2c 设备所有寄存器的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Usage: i2cdump [-f] [-y] [-r first-last] [-a] I2CBUS ADDRESS [MODE [BANK [BANKREG]]]</span><br><span class="line">  I2CBUS is an integer or an I2C bus name</span><br><span class="line">  ADDRESS is an integer (0x03 - 0x77, or 0x00 - 0x7f if -a is given)</span><br><span class="line">  MODE is one of:</span><br><span class="line">    b (byte, default)</span><br><span class="line">    w (word)</span><br><span class="line">    W (word on even register addresses)</span><br><span class="line">    s (SMBus block)</span><br><span class="line">    i (I2C block)</span><br><span class="line">    c (consecutive byte)</span><br><span class="line">    Append p for SMBus PEC</span><br><span class="line">-f：强制执行，即使可能存在风险的操作也会执行。</span><br><span class="line">-y：自动应答，不提示用户确认。</span><br><span class="line">-r first-last：指定要读取的寄存器地址范围。first 是起始地址，last 是结束地址。</span><br><span class="line">-a：允许使用10位地址的设备。默认情况下，i2cdump 只处理7位地址的设备。</span><br><span class="line">I2CBUS：指定要读取的I2C总线的编号或名称。</span><br><span class="line">ADDRESS：i2c设备地址</span><br><span class="line">MODE：指定读取数据的模式，可以是以下几种之一：</span><br><span class="line">    b：按字节读取（默认模式）。</span><br><span class="line">    w：按字（16位）读取。</span><br><span class="line">    W：按字（16位）读取，但只在偶数寄存器地址上读取。</span><br><span class="line">    s：SMBus块数据读取。</span><br><span class="line">    i：I2C块数据读取。</span><br><span class="line">    c：连续字节读取。</span><br><span class="line">BANK：对于需要切换寄存器银行的设备，指定要读取的寄存器银行。</span><br><span class="line">BANKREG：寄存器银行切换寄存器的地址。</span><br><span class="line">PEC：如果模式以 p 结尾，表示启用SMBus数据包错误校正（PEC）。</span><br></pre></td></tr></table></figure><p>获取 i2c-0 总线上 0x1E 设备所有寄存器的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2cdump -f -y 0 0x1e</span><br></pre></td></tr></table></figure><h4 id="i2ctransfer">i2ctransfer</h4><p>i2ctransfer：一次性读写多个字节</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Usage: i2ctransfer [-f] [-y] [-v] [-V] [-a] I2CBUS DESC [DATA] [DESC [DATA]]...</span><br><span class="line">  I2CBUS is an integer or an I2C bus name</span><br><span class="line">  DESC describes the transfer in the form: &#123;r|w&#125;LENGTH[@address]</span><br><span class="line">    1) read/write-flag 2) LENGTH (range 0-65535) 3) I2C address (use last one if omitted)</span><br><span class="line">  DATA are LENGTH bytes for a write message. They can be shortened by a suffix:</span><br><span class="line">    = (keep value constant until LENGTH)</span><br><span class="line">    + (increase value by 1 until LENGTH)</span><br><span class="line">    - (decrease value by 1 until LENGTH)</span><br><span class="line">    p (use pseudo random generator until LENGTH with value as seed)</span><br><span class="line"></span><br><span class="line">Example (bus 0, read 8 byte at offset 0x64 from EEPROM at 0x50):</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">i2ctransfer 0 w1@0x50 0x64 r8</span></span><br><span class="line">Example (same EEPROM, at offset 0x42 write 0xff 0xfe ... 0xf0):</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">i2ctransfer 0 w17@0x50 0x42 0xff-</span></span><br><span class="line"></span><br><span class="line">-f：强制执行，用于覆盖某些安全限制。</span><br><span class="line">-y：自动应答，不提示用户确认。</span><br><span class="line">-v：增加输出的详细程度，显示更多的信息。</span><br><span class="line">-V：显示程序版本信息。</span><br><span class="line">-a：允许使用10位地址的设备。默认情况下，i2ctransfer 只处理7位地址的设备。</span><br><span class="line">I2CBUS：指定I2C总线的编号或名称。</span><br><span class="line">DESC：描述传输操作，格式为 &#123;r|w&#125;LENGTH[@address]，其中：</span><br><span class="line">r 表示读取数据。</span><br><span class="line">w 表示写入数据。</span><br><span class="line">LENGTH 是要传输的数据长度，范围从0到65535。</span><br><span class="line">@address 是I2C设备的寄存器地址，如果省略，将使用上一个操作的地址。</span><br><span class="line">DATA：对于写操作，DATA 是要写入的数据，可以是一系列的字节、字或块数据。数据可以通过后缀进一步定义模式：</span><br><span class="line">= 表示保持当前值不变，直到达到 LENGTH。</span><br><span class="line">+ 表示从当前值开始递增，直到达到 LENGTH。</span><br><span class="line">- 表示从当前值开始递减，直到达到 LENGTH。</span><br><span class="line">p 表示使用伪随机生成器，使用当前值作为种子，直到达到 LENGTH。</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><blockquote><p><a href="https://blog.csdn.net/qq_45172832/article/details/131221971">https://blog.csdn.net/qq_45172832/article/details/131221971</a></p><p><a href="https://www.51cto.com/article/706269.html">手把手教你使用 i2c-tools-i2c-tools使用 (51cto.com)</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux-i2c-驱动&quot;&gt;Linux-I2C 驱动&lt;/h1&gt;
&lt;h2 id=&quot;序言&quot;&gt;序言&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;I2C 具体通信协议本文不涉及，本文主要介绍在 Linux 中 I2C 的驱动框架。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="http://www.obito.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/Linux/"/>
    
    
    <category term="Linux" scheme="http://www.obito.top/tags/Linux/"/>
    
    <category term="嵌入式" scheme="http://www.obito.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>基于IIC的OLED驱动代码编写</title>
    <link href="http://www.obito.top/2024/06/18/%E5%9F%BA%E4%BA%8EIIC%E7%9A%84OLED%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/"/>
    <id>http://www.obito.top/2024/06/18/%E5%9F%BA%E4%BA%8EIIC%E7%9A%84OLED%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/</id>
    <published>2024-06-18T10:47:38.000Z</published>
    <updated>2024-06-18T10:48:42.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于iic的oled驱动代码编写">基于IIC的OLED驱动代码编写</h1><h2 id="序言">序言</h2><p>支持软件 IIC 和硬件 IIC。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于iic的oled驱动代码编写&quot;&gt;基于IIC的OLED驱动代码编写&lt;/h1&gt;
&lt;h2 id=&quot;序言&quot;&gt;序言&lt;/h2&gt;
&lt;p&gt;支持软件 IIC 和硬件 IIC。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
